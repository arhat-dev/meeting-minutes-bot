// Package telegram provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.0 DO NOT EDIT.
package telegram

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// Defines values for ChatType.
const (
	ChatTypeChannel    ChatType = "channel"
	ChatTypeGroup      ChatType = "group"
	ChatTypePrivate    ChatType = "private"
	ChatTypeSupergroup ChatType = "supergroup"
)

// Defines values for EncryptedPassportElementType.
const (
	EncryptedPassportElementTypeAddress               EncryptedPassportElementType = "address"
	EncryptedPassportElementTypeBankStatement         EncryptedPassportElementType = "bank_statement"
	EncryptedPassportElementTypeDriverLicense         EncryptedPassportElementType = "driver_license"
	EncryptedPassportElementTypeEmail                 EncryptedPassportElementType = "email"
	EncryptedPassportElementTypeIdentityCard          EncryptedPassportElementType = "identity_card"
	EncryptedPassportElementTypeInternalPassport      EncryptedPassportElementType = "internal_passport"
	EncryptedPassportElementTypePassport              EncryptedPassportElementType = "passport"
	EncryptedPassportElementTypePassportRegistration  EncryptedPassportElementType = "passport_registration"
	EncryptedPassportElementTypePersonalDetails       EncryptedPassportElementType = "personal_details"
	EncryptedPassportElementTypePhoneNumber           EncryptedPassportElementType = "phone_number"
	EncryptedPassportElementTypeRentalAgreement       EncryptedPassportElementType = "rental_agreement"
	EncryptedPassportElementTypeTemporaryRegistration EncryptedPassportElementType = "temporary_registration"
	EncryptedPassportElementTypeUtilityBill           EncryptedPassportElementType = "utility_bill"
)

// Defines values for InlineQueryChatType.
const (
	InlineQueryChatTypeChannel    InlineQueryChatType = "channel"
	InlineQueryChatTypeGroup      InlineQueryChatType = "group"
	InlineQueryChatTypePrivate    InlineQueryChatType = "private"
	InlineQueryChatTypeSender     InlineQueryChatType = "sender"
	InlineQueryChatTypeSupergroup InlineQueryChatType = "supergroup"
)

// Defines values for InlineQueryResultDocumentMimeType.
const (
	Applicationpdf InlineQueryResultDocumentMimeType = "application/pdf"
	Applicationzip InlineQueryResultDocumentMimeType = "application/zip"
)

// Defines values for InlineQueryResultGifThumbMimeType.
const (
	InlineQueryResultGifThumbMimeTypeImagegif  InlineQueryResultGifThumbMimeType = "image/gif"
	InlineQueryResultGifThumbMimeTypeImagejpeg InlineQueryResultGifThumbMimeType = "image/jpeg"
	InlineQueryResultGifThumbMimeTypeVideomp4  InlineQueryResultGifThumbMimeType = "video/mp4"
)

// Defines values for InlineQueryResultMpeg4GifThumbMimeType.
const (
	InlineQueryResultMpeg4GifThumbMimeTypeImagegif  InlineQueryResultMpeg4GifThumbMimeType = "image/gif"
	InlineQueryResultMpeg4GifThumbMimeTypeImagejpeg InlineQueryResultMpeg4GifThumbMimeType = "image/jpeg"
	InlineQueryResultMpeg4GifThumbMimeTypeVideomp4  InlineQueryResultMpeg4GifThumbMimeType = "video/mp4"
)

// Defines values for InlineQueryResultVideoMimeType.
const (
	Texthtml InlineQueryResultVideoMimeType = "text/html"
	Videomp4 InlineQueryResultVideoMimeType = "video/mp4"
)

// Defines values for MaskPositionPoint.
const (
	Chin     MaskPositionPoint = "chin"
	Eyes     MaskPositionPoint = "eyes"
	Forehead MaskPositionPoint = "forehead"
	Mouth    MaskPositionPoint = "mouth"
)

// Defines values for MessageEntityType.
const (
	MessageEntityTypeBold          MessageEntityType = "bold"
	MessageEntityTypeBotCommand    MessageEntityType = "bot_command"
	MessageEntityTypeCashtag       MessageEntityType = "cashtag"
	MessageEntityTypeCode          MessageEntityType = "code"
	MessageEntityTypeEmail         MessageEntityType = "email"
	MessageEntityTypeHashtag       MessageEntityType = "hashtag"
	MessageEntityTypeItalic        MessageEntityType = "italic"
	MessageEntityTypeMention       MessageEntityType = "mention"
	MessageEntityTypePhoneNumber   MessageEntityType = "phone_number"
	MessageEntityTypePre           MessageEntityType = "pre"
	MessageEntityTypeSpoiler       MessageEntityType = "spoiler"
	MessageEntityTypeStrikethrough MessageEntityType = "strikethrough"
	MessageEntityTypeTextLink      MessageEntityType = "text_link"
	MessageEntityTypeTextMention   MessageEntityType = "text_mention"
	MessageEntityTypeUnderline     MessageEntityType = "underline"
	MessageEntityTypeUrl           MessageEntityType = "url"
)

// Defines values for PassportElementErrorDataFieldType.
const (
	PassportElementErrorDataFieldTypeAddress          PassportElementErrorDataFieldType = "address"
	PassportElementErrorDataFieldTypeDriverLicense    PassportElementErrorDataFieldType = "driver_license"
	PassportElementErrorDataFieldTypeIdentityCard     PassportElementErrorDataFieldType = "identity_card"
	PassportElementErrorDataFieldTypeInternalPassport PassportElementErrorDataFieldType = "internal_passport"
	PassportElementErrorDataFieldTypePassport         PassportElementErrorDataFieldType = "passport"
	PassportElementErrorDataFieldTypePersonalDetails  PassportElementErrorDataFieldType = "personal_details"
)

// Defines values for PassportElementErrorFileType.
const (
	PassportElementErrorFileTypeBankStatement         PassportElementErrorFileType = "bank_statement"
	PassportElementErrorFileTypePassportRegistration  PassportElementErrorFileType = "passport_registration"
	PassportElementErrorFileTypeRentalAgreement       PassportElementErrorFileType = "rental_agreement"
	PassportElementErrorFileTypeTemporaryRegistration PassportElementErrorFileType = "temporary_registration"
	PassportElementErrorFileTypeUtilityBill           PassportElementErrorFileType = "utility_bill"
)

// Defines values for PassportElementErrorFilesType.
const (
	PassportElementErrorFilesTypeBankStatement         PassportElementErrorFilesType = "bank_statement"
	PassportElementErrorFilesTypePassportRegistration  PassportElementErrorFilesType = "passport_registration"
	PassportElementErrorFilesTypeRentalAgreement       PassportElementErrorFilesType = "rental_agreement"
	PassportElementErrorFilesTypeTemporaryRegistration PassportElementErrorFilesType = "temporary_registration"
	PassportElementErrorFilesTypeUtilityBill           PassportElementErrorFilesType = "utility_bill"
)

// Defines values for PassportElementErrorFrontSideType.
const (
	PassportElementErrorFrontSideTypeDriverLicense    PassportElementErrorFrontSideType = "driver_license"
	PassportElementErrorFrontSideTypeIdentityCard     PassportElementErrorFrontSideType = "identity_card"
	PassportElementErrorFrontSideTypeInternalPassport PassportElementErrorFrontSideType = "internal_passport"
	PassportElementErrorFrontSideTypePassport         PassportElementErrorFrontSideType = "passport"
)

// Defines values for PassportElementErrorReverseSideType.
const (
	PassportElementErrorReverseSideTypeDriverLicense PassportElementErrorReverseSideType = "driver_license"
	PassportElementErrorReverseSideTypeIdentityCard  PassportElementErrorReverseSideType = "identity_card"
)

// Defines values for PassportElementErrorSelfieType.
const (
	PassportElementErrorSelfieTypeDriverLicense    PassportElementErrorSelfieType = "driver_license"
	PassportElementErrorSelfieTypeIdentityCard     PassportElementErrorSelfieType = "identity_card"
	PassportElementErrorSelfieTypeInternalPassport PassportElementErrorSelfieType = "internal_passport"
	PassportElementErrorSelfieTypePassport         PassportElementErrorSelfieType = "passport"
)

// Defines values for PassportElementErrorTranslationFileType.
const (
	PassportElementErrorTranslationFileTypeBankStatement         PassportElementErrorTranslationFileType = "bank_statement"
	PassportElementErrorTranslationFileTypeDriverLicense         PassportElementErrorTranslationFileType = "driver_license"
	PassportElementErrorTranslationFileTypeIdentityCard          PassportElementErrorTranslationFileType = "identity_card"
	PassportElementErrorTranslationFileTypeInternalPassport      PassportElementErrorTranslationFileType = "internal_passport"
	PassportElementErrorTranslationFileTypePassport              PassportElementErrorTranslationFileType = "passport"
	PassportElementErrorTranslationFileTypePassportRegistration  PassportElementErrorTranslationFileType = "passport_registration"
	PassportElementErrorTranslationFileTypeRentalAgreement       PassportElementErrorTranslationFileType = "rental_agreement"
	PassportElementErrorTranslationFileTypeTemporaryRegistration PassportElementErrorTranslationFileType = "temporary_registration"
	PassportElementErrorTranslationFileTypeUtilityBill           PassportElementErrorTranslationFileType = "utility_bill"
)

// Defines values for PassportElementErrorTranslationFilesType.
const (
	PassportElementErrorTranslationFilesTypeBankStatement         PassportElementErrorTranslationFilesType = "bank_statement"
	PassportElementErrorTranslationFilesTypeDriverLicense         PassportElementErrorTranslationFilesType = "driver_license"
	PassportElementErrorTranslationFilesTypeIdentityCard          PassportElementErrorTranslationFilesType = "identity_card"
	PassportElementErrorTranslationFilesTypeInternalPassport      PassportElementErrorTranslationFilesType = "internal_passport"
	PassportElementErrorTranslationFilesTypePassport              PassportElementErrorTranslationFilesType = "passport"
	PassportElementErrorTranslationFilesTypePassportRegistration  PassportElementErrorTranslationFilesType = "passport_registration"
	PassportElementErrorTranslationFilesTypeRentalAgreement       PassportElementErrorTranslationFilesType = "rental_agreement"
	PassportElementErrorTranslationFilesTypeTemporaryRegistration PassportElementErrorTranslationFilesType = "temporary_registration"
	PassportElementErrorTranslationFilesTypeUtilityBill           PassportElementErrorTranslationFilesType = "utility_bill"
)

// Defines values for PollType.
const (
	Quiz    PollType = "quiz"
	Regular PollType = "regular"
)

// This object represents an animation file (GIF or H.264/MPEG-4 AVC video without sound).
type Animation struct {
	// Duration of the video in seconds as defined by sender
	Duration int `json:"duration"`

	// Identifier for this file, which can be used to download or reuse the file
	FileId string `json:"file_id"`

	// *Optional*. Original animation filename as defined by sender
	FileName *string `json:"file_name,omitempty"`

	// *Optional*. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value.
	FileSize *int `json:"file_size,omitempty"`

	// Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file.
	FileUniqueId string `json:"file_unique_id"`

	// Video height as defined by sender
	Height int `json:"height"`

	// *Optional*. MIME type of the file as defined by sender
	MimeType *string `json:"mime_type,omitempty"`

	// This object represents one size of a photo or a [file](https://core.telegram.org/bots/api/#document) / [sticker](https://core.telegram.org/bots/api/#sticker) thumbnail.
	Thumb *PhotoSize `json:"thumb,omitempty"`

	// Video width as defined by sender
	Width int `json:"width"`
}

// This object represents an audio file to be treated as music by the Telegram clients.
type Audio struct {
	// Duration of the audio in seconds as defined by sender
	Duration int `json:"duration"`

	// Identifier for this file, which can be used to download or reuse the file
	FileId string `json:"file_id"`

	// *Optional*. Original filename as defined by sender
	FileName *string `json:"file_name,omitempty"`

	// *Optional*. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value.
	FileSize *int `json:"file_size,omitempty"`

	// Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file.
	FileUniqueId string `json:"file_unique_id"`

	// *Optional*. MIME type of the file as defined by sender
	MimeType *string `json:"mime_type,omitempty"`

	// *Optional*. Performer of the audio as defined by sender or by audio tags
	Performer *string `json:"performer,omitempty"`

	// This object represents one size of a photo or a [file](https://core.telegram.org/bots/api/#document) / [sticker](https://core.telegram.org/bots/api/#sticker) thumbnail.
	Thumb *PhotoSize `json:"thumb,omitempty"`

	// *Optional*. Title of the audio as defined by sender or by audio tags
	Title *string `json:"title,omitempty"`
}

// This object represents a bot command.
type BotCommand struct {
	// Text of the command; 1-32 characters. Can contain only lowercase English letters, digits and underscores.
	Command string `json:"command"`

	// Description of the command; 1-256 characters.
	Description string `json:"description"`
}

// This object represents the scope to which bot commands are applied. Currently, the following 7 scopes are supported:
//
// * [BotCommandScopeDefault](https://core.telegram.org/bots/api/#botcommandscopedefault)
// * [BotCommandScopeAllPrivateChats](https://core.telegram.org/bots/api/#botcommandscopeallprivatechats)
// * [BotCommandScopeAllGroupChats](https://core.telegram.org/bots/api/#botcommandscopeallgroupchats)
// * [BotCommandScopeAllChatAdministrators](https://core.telegram.org/bots/api/#botcommandscopeallchatadministrators)
// * [BotCommandScopeChat](https://core.telegram.org/bots/api/#botcommandscopechat)
// * [BotCommandScopeChatAdministrators](https://core.telegram.org/bots/api/#botcommandscopechatadministrators)
// * [BotCommandScopeChatMember](https://core.telegram.org/bots/api/#botcommandscopechatmember)
type BotCommandScope interface{}

// Represents the [scope](https://core.telegram.org/bots/api/#botcommandscope) of bot commands, covering all group and supergroup chat administrators.
type BotCommandScopeAllChatAdministrators struct {
	// Scope type, must be *all\_chat\_administrators*
	Type string `json:"type"`
}

// Represents the [scope](https://core.telegram.org/bots/api/#botcommandscope) of bot commands, covering all group and supergroup chats.
type BotCommandScopeAllGroupChats struct {
	// Scope type, must be *all\_group\_chats*
	Type string `json:"type"`
}

// Represents the [scope](https://core.telegram.org/bots/api/#botcommandscope) of bot commands, covering all private chats.
type BotCommandScopeAllPrivateChats struct {
	// Scope type, must be *all\_private\_chats*
	Type string `json:"type"`
}

// Represents the [scope](https://core.telegram.org/bots/api/#botcommandscope) of bot commands, covering a specific chat.
type BotCommandScopeChat struct {
	// Unique identifier for the target chat or username of the target supergroup (in the format `@supergroupusername`)
	ChatId interface{} `json:"chat_id"`

	// Scope type, must be *chat*
	Type string `json:"type"`
}

// Represents the [scope](https://core.telegram.org/bots/api/#botcommandscope) of bot commands, covering all administrators of a specific group or supergroup chat.
type BotCommandScopeChatAdministrators struct {
	// Unique identifier for the target chat or username of the target supergroup (in the format `@supergroupusername`)
	ChatId interface{} `json:"chat_id"`

	// Scope type, must be *chat\_administrators*
	Type string `json:"type"`
}

// Represents the [scope](https://core.telegram.org/bots/api/#botcommandscope) of bot commands, covering a specific member of a group or supergroup chat.
type BotCommandScopeChatMember struct {
	// Unique identifier for the target chat or username of the target supergroup (in the format `@supergroupusername`)
	ChatId interface{} `json:"chat_id"`

	// Scope type, must be *chat\_member*
	Type string `json:"type"`

	// Unique identifier of the target user
	UserId int `json:"user_id"`
}

// Represents the default [scope](https://core.telegram.org/bots/api/#botcommandscope) of bot commands. Default commands are used if no commands with a [narrower scope](https://core.telegram.org/bots/api/#determining-list-of-commands) are specified for the user.
type BotCommandScopeDefault struct {
	// Scope type, must be *default*
	Type string `json:"type"`
}

// A placeholder, currently holds no information. Use [BotFather](https://t.me/botfather) to set up your game.
type CallbackGame = interface{}

// This object represents an incoming callback query from a callback button in an [inline keyboard](https://core.telegram.org/bots#inline-keyboards-and-on-the-fly-updating). If the button that originated the query was attached to a message sent by the bot, the field *message* will be present. If the button was attached to a message sent via the bot (in [inline mode](https://core.telegram.org/bots/api/#inline-mode)), the field *inline\_message\_id* will be present. Exactly one of the fields *data* or *game\_short\_name* will be present.
type CallbackQuery struct {
	// Global identifier, uniquely corresponding to the chat to which the message with the callback button was sent. Useful for high scores in [games](https://core.telegram.org/bots/api/#games).
	ChatInstance string `json:"chat_instance"`

	// *Optional*. Data associated with the callback button. Be aware that the message originated the query can contain no callback buttons with this data.
	Data *string `json:"data,omitempty"`

	// This object represents a Telegram user or bot.
	From User `json:"from"`

	// *Optional*. Short name of a [Game](https://core.telegram.org/bots/api/#games) to be returned, serves as the unique identifier for the game
	GameShortName *string `json:"game_short_name,omitempty"`

	// Unique identifier for this query
	Id string `json:"id"`

	// *Optional*. Identifier of the message sent via the bot in inline mode, that originated the query.
	InlineMessageId *string `json:"inline_message_id,omitempty"`

	// This object represents a message.
	Message *Message `json:"message,omitempty"`
}

// This object represents a chat.
type Chat struct {
	// *Optional*. Bio of the other party in a private chat. Returned only in [getChat](https://core.telegram.org/bots/api/#getchat).
	Bio *string `json:"bio,omitempty"`

	// *Optional*. *True*, if the bot can change the group sticker set. Returned only in [getChat](https://core.telegram.org/bots/api/#getchat).
	CanSetStickerSet *bool `json:"can_set_sticker_set,omitempty"`

	// *Optional*. Description, for groups, supergroups and channel chats. Returned only in [getChat](https://core.telegram.org/bots/api/#getchat).
	Description *string `json:"description,omitempty"`

	// *Optional*. First name of the other party in a private chat
	FirstName *string `json:"first_name,omitempty"`

	// *Optional*. *True*, if privacy settings of the other party in the private chat allows to use `tg://user?id=<user_id>` links only in chats with the user. Returned only in [getChat](https://core.telegram.org/bots/api/#getchat).
	HasPrivateForwards *bool `json:"has_private_forwards,omitempty"`

	// *Optional*. *True*, if messages from the chat can't be forwarded to other chats. Returned only in [getChat](https://core.telegram.org/bots/api/#getchat).
	HasProtectedContent *bool `json:"has_protected_content,omitempty"`

	// Unique identifier for this chat. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier.
	Id int `json:"id"`

	// *Optional*. Primary invite link, for groups, supergroups and channel chats. Returned only in [getChat](https://core.telegram.org/bots/api/#getchat).
	InviteLink *string `json:"invite_link,omitempty"`

	// *Optional*. *True*, if all users directly joining the supergroup need to be approved by supergroup administrators. Returned only in [getChat](https://core.telegram.org/bots/api/#getchat).
	JoinByRequest *bool `json:"join_by_request,omitempty"`

	// *Optional*. *True*, if users need to join the supergroup before they can send messages. Returned only in [getChat](https://core.telegram.org/bots/api/#getchat).
	JoinToSendMessages *bool `json:"join_to_send_messages,omitempty"`

	// *Optional*. Last name of the other party in a private chat
	LastName *string `json:"last_name,omitempty"`

	// *Optional*. Unique identifier for the linked chat, i.e. the discussion group identifier for a channel and vice versa; for supergroups and channel chats. This identifier may be greater than 32 bits and some programming languages may have difficulty/silent defects in interpreting it. But it is smaller than 52 bits, so a signed 64 bit integer or double-precision float type are safe for storing this identifier. Returned only in [getChat](https://core.telegram.org/bots/api/#getchat).
	LinkedChatId *int `json:"linked_chat_id,omitempty"`

	// Represents a location to which a chat is connected.
	Location *ChatLocation `json:"location,omitempty"`

	// *Optional*. The time after which all messages sent to the chat will be automatically deleted; in seconds. Returned only in [getChat](https://core.telegram.org/bots/api/#getchat).
	MessageAutoDeleteTime *int `json:"message_auto_delete_time,omitempty"`

	// Describes actions that a non-administrator user is allowed to take in a chat.
	Permissions *ChatPermissions `json:"permissions,omitempty"`

	// This object represents a chat photo.
	Photo *ChatPhoto `json:"photo,omitempty"`

	// This object represents a message.
	PinnedMessage *Message `json:"pinned_message,omitempty"`

	// *Optional*. For supergroups, the minimum allowed delay between consecutive messages sent by each unpriviledged user; in seconds. Returned only in [getChat](https://core.telegram.org/bots/api/#getchat).
	SlowModeDelay *int `json:"slow_mode_delay,omitempty"`

	// *Optional*. For supergroups, name of group sticker set. Returned only in [getChat](https://core.telegram.org/bots/api/#getchat).
	StickerSetName *string `json:"sticker_set_name,omitempty"`

	// *Optional*. Title, for supergroups, channels and group chats
	Title *string `json:"title,omitempty"`

	// Type of chat, can be either ‚Äúprivate‚Äù, ‚Äúgroup‚Äù, ‚Äúsupergroup‚Äù or ‚Äúchannel‚Äù
	Type ChatType `json:"type"`

	// *Optional*. Username, for private chats, supergroups and channels if available
	Username *string `json:"username,omitempty"`
}

// Type of chat, can be either ‚Äúprivate‚Äù, ‚Äúgroup‚Äù, ‚Äúsupergroup‚Äù or ‚Äúchannel‚Äù
type ChatType string

// Represents the rights of an administrator in a chat.
type ChatAdministratorRights struct {
	// *True*, if the user is allowed to change the chat title, photo and other settings
	CanChangeInfo bool `json:"can_change_info"`

	// *True*, if the administrator can delete messages of other users
	CanDeleteMessages bool `json:"can_delete_messages"`

	// *Optional*. *True*, if the administrator can edit messages of other users and can pin messages; channels only
	CanEditMessages *bool `json:"can_edit_messages,omitempty"`

	// *True*, if the user is allowed to invite new users to the chat
	CanInviteUsers bool `json:"can_invite_users"`

	// *True*, if the administrator can access the chat event log, chat statistics, message statistics in channels, see channel members, see anonymous administrators in supergroups and ignore slow mode. Implied by any other administrator privilege
	CanManageChat bool `json:"can_manage_chat"`

	// *True*, if the administrator can manage video chats
	CanManageVideoChats bool `json:"can_manage_video_chats"`

	// *Optional*. *True*, if the user is allowed to pin messages; groups and supergroups only
	CanPinMessages *bool `json:"can_pin_messages,omitempty"`

	// *Optional*. *True*, if the administrator can post in the channel; channels only
	CanPostMessages *bool `json:"can_post_messages,omitempty"`

	// *True*, if the administrator can add new administrators with a subset of their own privileges or demote administrators that he has promoted, directly or indirectly (promoted by administrators that were appointed by the user)
	CanPromoteMembers bool `json:"can_promote_members"`

	// *True*, if the administrator can restrict, ban or unban chat members
	CanRestrictMembers bool `json:"can_restrict_members"`

	// *True*, if the user's presence in the chat is hidden
	IsAnonymous bool `json:"is_anonymous"`
}

// Represents an invite link for a chat.
type ChatInviteLink struct {
	// *True*, if users joining the chat via the link need to be approved by chat administrators
	CreatesJoinRequest bool `json:"creates_join_request"`

	// This object represents a Telegram user or bot.
	Creator User `json:"creator"`

	// *Optional*. Point in time (Unix timestamp) when the link will expire or has been expired
	ExpireDate *int `json:"expire_date,omitempty"`

	// The invite link. If the link was created by another chat administrator, then the second part of the link will be replaced with ‚Äú‚Ä¶‚Äù.
	InviteLink string `json:"invite_link"`

	// *True*, if the link is primary
	IsPrimary bool `json:"is_primary"`

	// *True*, if the link is revoked
	IsRevoked bool `json:"is_revoked"`

	// *Optional*. The maximum number of users that can be members of the chat simultaneously after joining the chat via this invite link; 1-99999
	MemberLimit *int `json:"member_limit,omitempty"`

	// *Optional*. Invite link name
	Name *string `json:"name,omitempty"`

	// *Optional*. Number of pending join requests created using this link
	PendingJoinRequestCount *int `json:"pending_join_request_count,omitempty"`
}

// Represents a join request sent to a chat.
type ChatJoinRequest struct {
	// *Optional*. Bio of the user.
	Bio *string `json:"bio,omitempty"`

	// This object represents a chat.
	Chat Chat `json:"chat"`

	// Date the request was sent in Unix time
	Date int `json:"date"`

	// This object represents a Telegram user or bot.
	From User `json:"from"`

	// Represents an invite link for a chat.
	InviteLink *ChatInviteLink `json:"invite_link,omitempty"`
}

// Represents a location to which a chat is connected.
type ChatLocation struct {
	// Location address; 1-64 characters, as defined by the chat owner
	Address string `json:"address"`

	// This object represents a point on the map.
	Location Location `json:"location"`
}

// This object contains information about one member of a chat. Currently, the following 6 types of chat members are supported:
//
// * [ChatMemberOwner](https://core.telegram.org/bots/api/#chatmemberowner)
// * [ChatMemberAdministrator](https://core.telegram.org/bots/api/#chatmemberadministrator)
// * [ChatMemberMember](https://core.telegram.org/bots/api/#chatmembermember)
// * [ChatMemberRestricted](https://core.telegram.org/bots/api/#chatmemberrestricted)
// * [ChatMemberLeft](https://core.telegram.org/bots/api/#chatmemberleft)
// * [ChatMemberBanned](https://core.telegram.org/bots/api/#chatmemberbanned)
type ChatMember interface{}

// Represents a [chat member](https://core.telegram.org/bots/api/#chatmember) that has some additional privileges.
type ChatMemberAdministrator struct {
	// *True*, if the bot is allowed to edit administrator privileges of that user
	CanBeEdited bool `json:"can_be_edited"`

	// *True*, if the user is allowed to change the chat title, photo and other settings
	CanChangeInfo bool `json:"can_change_info"`

	// *True*, if the administrator can delete messages of other users
	CanDeleteMessages bool `json:"can_delete_messages"`

	// *Optional*. *True*, if the administrator can edit messages of other users and can pin messages; channels only
	CanEditMessages *bool `json:"can_edit_messages,omitempty"`

	// *True*, if the user is allowed to invite new users to the chat
	CanInviteUsers bool `json:"can_invite_users"`

	// *True*, if the administrator can access the chat event log, chat statistics, message statistics in channels, see channel members, see anonymous administrators in supergroups and ignore slow mode. Implied by any other administrator privilege
	CanManageChat bool `json:"can_manage_chat"`

	// *True*, if the administrator can manage video chats
	CanManageVideoChats bool `json:"can_manage_video_chats"`

	// *Optional*. *True*, if the user is allowed to pin messages; groups and supergroups only
	CanPinMessages *bool `json:"can_pin_messages,omitempty"`

	// *Optional*. *True*, if the administrator can post in the channel; channels only
	CanPostMessages *bool `json:"can_post_messages,omitempty"`

	// *True*, if the administrator can add new administrators with a subset of their own privileges or demote administrators that he has promoted, directly or indirectly (promoted by administrators that were appointed by the user)
	CanPromoteMembers bool `json:"can_promote_members"`

	// *True*, if the administrator can restrict, ban or unban chat members
	CanRestrictMembers bool `json:"can_restrict_members"`

	// *Optional*. Custom title for this user
	CustomTitle *string `json:"custom_title,omitempty"`

	// *True*, if the user's presence in the chat is hidden
	IsAnonymous bool `json:"is_anonymous"`

	// The member's status in the chat, always ‚Äúadministrator‚Äù
	Status string `json:"status"`

	// This object represents a Telegram user or bot.
	User User `json:"user"`
}

// Represents a [chat member](https://core.telegram.org/bots/api/#chatmember) that was banned in the chat and can't return to the chat or view chat messages.
type ChatMemberBanned struct {
	// The member's status in the chat, always ‚Äúkicked‚Äù
	Status string `json:"status"`

	// Date when restrictions will be lifted for this user; unix time. If 0, then the user is banned forever
	UntilDate int `json:"until_date"`

	// This object represents a Telegram user or bot.
	User User `json:"user"`
}

// Represents a [chat member](https://core.telegram.org/bots/api/#chatmember) that isn't currently a member of the chat, but may join it themselves.
type ChatMemberLeft struct {
	// The member's status in the chat, always ‚Äúleft‚Äù
	Status string `json:"status"`

	// This object represents a Telegram user or bot.
	User User `json:"user"`
}

// Represents a [chat member](https://core.telegram.org/bots/api/#chatmember) that has no additional privileges or restrictions.
type ChatMemberMember struct {
	// The member's status in the chat, always ‚Äúmember‚Äù
	Status string `json:"status"`

	// This object represents a Telegram user or bot.
	User User `json:"user"`
}

// Represents a [chat member](https://core.telegram.org/bots/api/#chatmember) that owns the chat and has all administrator privileges.
type ChatMemberOwner struct {
	// *Optional*. Custom title for this user
	CustomTitle *string `json:"custom_title,omitempty"`

	// *True*, if the user's presence in the chat is hidden
	IsAnonymous bool `json:"is_anonymous"`

	// The member's status in the chat, always ‚Äúcreator‚Äù
	Status string `json:"status"`

	// This object represents a Telegram user or bot.
	User User `json:"user"`
}

// Represents a [chat member](https://core.telegram.org/bots/api/#chatmember) that is under certain restrictions in the chat. Supergroups only.
type ChatMemberRestricted struct {
	// *True*, if the user is allowed to add web page previews to their messages
	CanAddWebPagePreviews bool `json:"can_add_web_page_previews"`

	// *True*, if the user is allowed to change the chat title, photo and other settings
	CanChangeInfo bool `json:"can_change_info"`

	// *True*, if the user is allowed to invite new users to the chat
	CanInviteUsers bool `json:"can_invite_users"`

	// *True*, if the user is allowed to pin messages
	CanPinMessages bool `json:"can_pin_messages"`

	// *True*, if the user is allowed to send audios, documents, photos, videos, video notes and voice notes
	CanSendMediaMessages bool `json:"can_send_media_messages"`

	// *True*, if the user is allowed to send text messages, contacts, locations and venues
	CanSendMessages bool `json:"can_send_messages"`

	// *True*, if the user is allowed to send animations, games, stickers and use inline bots
	CanSendOtherMessages bool `json:"can_send_other_messages"`

	// *True*, if the user is allowed to send polls
	CanSendPolls bool `json:"can_send_polls"`

	// *True*, if the user is a member of the chat at the moment of the request
	IsMember bool `json:"is_member"`

	// The member's status in the chat, always ‚Äúrestricted‚Äù
	Status string `json:"status"`

	// Date when restrictions will be lifted for this user; unix time. If 0, then the user is restricted forever
	UntilDate int `json:"until_date"`

	// This object represents a Telegram user or bot.
	User User `json:"user"`
}

// This object represents changes in the status of a chat member.
type ChatMemberUpdated struct {
	// This object represents a chat.
	Chat Chat `json:"chat"`

	// Date the change was done in Unix time
	Date int `json:"date"`

	// This object represents a Telegram user or bot.
	From User `json:"from"`

	// Represents an invite link for a chat.
	InviteLink *ChatInviteLink `json:"invite_link,omitempty"`

	// This object contains information about one member of a chat. Currently, the following 6 types of chat members are supported:
	//
	// * [ChatMemberOwner](https://core.telegram.org/bots/api/#chatmemberowner)
	// * [ChatMemberAdministrator](https://core.telegram.org/bots/api/#chatmemberadministrator)
	// * [ChatMemberMember](https://core.telegram.org/bots/api/#chatmembermember)
	// * [ChatMemberRestricted](https://core.telegram.org/bots/api/#chatmemberrestricted)
	// * [ChatMemberLeft](https://core.telegram.org/bots/api/#chatmemberleft)
	// * [ChatMemberBanned](https://core.telegram.org/bots/api/#chatmemberbanned)
	NewChatMember ChatMember `json:"new_chat_member"`

	// This object contains information about one member of a chat. Currently, the following 6 types of chat members are supported:
	//
	// * [ChatMemberOwner](https://core.telegram.org/bots/api/#chatmemberowner)
	// * [ChatMemberAdministrator](https://core.telegram.org/bots/api/#chatmemberadministrator)
	// * [ChatMemberMember](https://core.telegram.org/bots/api/#chatmembermember)
	// * [ChatMemberRestricted](https://core.telegram.org/bots/api/#chatmemberrestricted)
	// * [ChatMemberLeft](https://core.telegram.org/bots/api/#chatmemberleft)
	// * [ChatMemberBanned](https://core.telegram.org/bots/api/#chatmemberbanned)
	OldChatMember ChatMember `json:"old_chat_member"`
}

// Describes actions that a non-administrator user is allowed to take in a chat.
type ChatPermissions struct {
	// *Optional*. *True*, if the user is allowed to add web page previews to their messages, implies can\_send\_media\_messages
	CanAddWebPagePreviews *bool `json:"can_add_web_page_previews,omitempty"`

	// *Optional*. *True*, if the user is allowed to change the chat title, photo and other settings. Ignored in public supergroups
	CanChangeInfo *bool `json:"can_change_info,omitempty"`

	// *Optional*. *True*, if the user is allowed to invite new users to the chat
	CanInviteUsers *bool `json:"can_invite_users,omitempty"`

	// *Optional*. *True*, if the user is allowed to pin messages. Ignored in public supergroups
	CanPinMessages *bool `json:"can_pin_messages,omitempty"`

	// *Optional*. *True*, if the user is allowed to send audios, documents, photos, videos, video notes and voice notes, implies can\_send\_messages
	CanSendMediaMessages *bool `json:"can_send_media_messages,omitempty"`

	// *Optional*. *True*, if the user is allowed to send text messages, contacts, locations and venues
	CanSendMessages *bool `json:"can_send_messages,omitempty"`

	// *Optional*. *True*, if the user is allowed to send animations, games, stickers and use inline bots, implies can\_send\_media\_messages
	CanSendOtherMessages *bool `json:"can_send_other_messages,omitempty"`

	// *Optional*. *True*, if the user is allowed to send polls, implies can\_send\_messages
	CanSendPolls *bool `json:"can_send_polls,omitempty"`
}

// This object represents a chat photo.
type ChatPhoto struct {
	// File identifier of big (640x640) chat photo. This file\_id can be used only for photo download and only for as long as the photo is not changed.
	BigFileId string `json:"big_file_id"`

	// Unique file identifier of big (640x640) chat photo, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file.
	BigFileUniqueId string `json:"big_file_unique_id"`

	// File identifier of small (160x160) chat photo. This file\_id can be used only for photo download and only for as long as the photo is not changed.
	SmallFileId string `json:"small_file_id"`

	// Unique file identifier of small (160x160) chat photo, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file.
	SmallFileUniqueId string `json:"small_file_unique_id"`
}

// Represents a [result](https://core.telegram.org/bots/api/#inlinequeryresult) of an inline query that was chosen by the user and sent to their chat partner.
type ChosenInlineResult struct {
	// This object represents a Telegram user or bot.
	From User `json:"from"`

	// *Optional*. Identifier of the sent inline message. Available only if there is an [inline keyboard](https://core.telegram.org/bots/api/#inlinekeyboardmarkup) attached to the message. Will be also received in [callback queries](https://core.telegram.org/bots/api/#callbackquery) and can be used to [edit](https://core.telegram.org/bots/api/#updating-messages) the message.
	InlineMessageId *string `json:"inline_message_id,omitempty"`

	// This object represents a point on the map.
	Location *Location `json:"location,omitempty"`

	// The query that was used to obtain the result
	Query string `json:"query"`

	// The unique identifier for the result that was chosen
	ResultId string `json:"result_id"`
}

// This object represents a phone contact.
type Contact struct {
	// Contact's first name
	FirstName string `json:"first_name"`

	// *Optional*. Contact's last name
	LastName *string `json:"last_name,omitempty"`

	// Contact's phone number
	PhoneNumber string `json:"phone_number"`

	// *Optional*. Contact's user identifier in Telegram. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier.
	UserId *int `json:"user_id,omitempty"`

	// *Optional*. Additional data about the contact in the form of a [vCard](https://en.wikipedia.org/wiki/VCard)
	Vcard *string `json:"vcard,omitempty"`
}

// This object represents an animated emoji that displays a random value.
type Dice struct {
	// Emoji on which the dice throw animation is based
	Emoji string `json:"emoji"`

	// Value of the dice, 1-6 for ‚Äúüé≤‚Äù, ‚ÄúüéØ‚Äù and ‚Äúüé≥‚Äù base emoji, 1-5 for ‚ÄúüèÄ‚Äù and ‚Äú‚öΩ‚Äù base emoji, 1-64 for ‚Äúüé∞‚Äù base emoji
	Value int `json:"value"`
}

// This object represents a general file (as opposed to [photos](https://core.telegram.org/bots/api/#photosize), [voice messages](https://core.telegram.org/bots/api/#voice) and [audio files](https://core.telegram.org/bots/api/#audio)).
type Document struct {
	// Identifier for this file, which can be used to download or reuse the file
	FileId string `json:"file_id"`

	// *Optional*. Original filename as defined by sender
	FileName *string `json:"file_name,omitempty"`

	// *Optional*. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value.
	FileSize *int `json:"file_size,omitempty"`

	// Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file.
	FileUniqueId string `json:"file_unique_id"`

	// *Optional*. MIME type of the file as defined by sender
	MimeType *string `json:"mime_type,omitempty"`

	// This object represents one size of a photo or a [file](https://core.telegram.org/bots/api/#document) / [sticker](https://core.telegram.org/bots/api/#sticker) thumbnail.
	Thumb *PhotoSize `json:"thumb,omitempty"`
}

// Describes data required for decrypting and authenticating [EncryptedPassportElement](https://core.telegram.org/bots/api/#encryptedpassportelement). See the [Telegram Passport Documentation](https://core.telegram.org/passport#receiving-information) for a complete description of the data decryption and authentication processes.
type EncryptedCredentials struct {
	// Base64-encoded encrypted JSON-serialized data with unique user's payload, data hashes and secrets required for [EncryptedPassportElement](https://core.telegram.org/bots/api/#encryptedpassportelement) decryption and authentication
	Data string `json:"data"`

	// Base64-encoded data hash for data authentication
	Hash string `json:"hash"`

	// Base64-encoded secret, encrypted with the bot's public RSA key, required for data decryption
	Secret string `json:"secret"`
}

// Describes documents or other Telegram Passport elements shared with the bot by the user.
type EncryptedPassportElement struct {
	// *Optional*. Base64-encoded encrypted Telegram Passport element data provided by the user, available for ‚Äúpersonal\_details‚Äù, ‚Äúpassport‚Äù, ‚Äúdriver\_license‚Äù, ‚Äúidentity\_card‚Äù, ‚Äúinternal\_passport‚Äù and ‚Äúaddress‚Äù types. Can be decrypted and verified using the accompanying [EncryptedCredentials](https://core.telegram.org/bots/api/#encryptedcredentials).
	Data *string `json:"data,omitempty"`

	// *Optional*. User's verified email address, available only for ‚Äúemail‚Äù type
	Email *string `json:"email,omitempty"`

	// *Optional*. Array of encrypted files with documents provided by the user, available for ‚Äúutility\_bill‚Äù, ‚Äúbank\_statement‚Äù, ‚Äúrental\_agreement‚Äù, ‚Äúpassport\_registration‚Äù and ‚Äútemporary\_registration‚Äù types. Files can be decrypted and verified using the accompanying [EncryptedCredentials](https://core.telegram.org/bots/api/#encryptedcredentials).
	Files *[]PassportFile `json:"files,omitempty"`

	// This object represents a file uploaded to Telegram Passport. Currently all Telegram Passport files are in JPEG format when decrypted and don't exceed 10MB.
	FrontSide *PassportFile `json:"front_side,omitempty"`

	// Base64-encoded element hash for using in [PassportElementErrorUnspecified](https://core.telegram.org/bots/api/#passportelementerrorunspecified)
	Hash string `json:"hash"`

	// *Optional*. User's verified phone number, available only for ‚Äúphone\_number‚Äù type
	PhoneNumber *string `json:"phone_number,omitempty"`

	// This object represents a file uploaded to Telegram Passport. Currently all Telegram Passport files are in JPEG format when decrypted and don't exceed 10MB.
	ReverseSide *PassportFile `json:"reverse_side,omitempty"`

	// This object represents a file uploaded to Telegram Passport. Currently all Telegram Passport files are in JPEG format when decrypted and don't exceed 10MB.
	Selfie *PassportFile `json:"selfie,omitempty"`

	// *Optional*. Array of encrypted files with translated versions of documents provided by the user. Available if requested for ‚Äúpassport‚Äù, ‚Äúdriver\_license‚Äù, ‚Äúidentity\_card‚Äù, ‚Äúinternal\_passport‚Äù, ‚Äúutility\_bill‚Äù, ‚Äúbank\_statement‚Äù, ‚Äúrental\_agreement‚Äù, ‚Äúpassport\_registration‚Äù and ‚Äútemporary\_registration‚Äù types. Files can be decrypted and verified using the accompanying [EncryptedCredentials](https://core.telegram.org/bots/api/#encryptedcredentials).
	Translation *[]PassportFile `json:"translation,omitempty"`

	// Element type. One of ‚Äúpersonal\_details‚Äù, ‚Äúpassport‚Äù, ‚Äúdriver\_license‚Äù, ‚Äúidentity\_card‚Äù, ‚Äúinternal\_passport‚Äù, ‚Äúaddress‚Äù, ‚Äúutility\_bill‚Äù, ‚Äúbank\_statement‚Äù, ‚Äúrental\_agreement‚Äù, ‚Äúpassport\_registration‚Äù, ‚Äútemporary\_registration‚Äù, ‚Äúphone\_number‚Äù, ‚Äúemail‚Äù.
	Type EncryptedPassportElementType `json:"type"`
}

// Element type. One of ‚Äúpersonal\_details‚Äù, ‚Äúpassport‚Äù, ‚Äúdriver\_license‚Äù, ‚Äúidentity\_card‚Äù, ‚Äúinternal\_passport‚Äù, ‚Äúaddress‚Äù, ‚Äúutility\_bill‚Äù, ‚Äúbank\_statement‚Äù, ‚Äúrental\_agreement‚Äù, ‚Äúpassport\_registration‚Äù, ‚Äútemporary\_registration‚Äù, ‚Äúphone\_number‚Äù, ‚Äúemail‚Äù.
type EncryptedPassportElementType string

// Error defines model for Error.
type Error struct {
	Description string `json:"description"`
	ErrorCode   int    `json:"error_code"`
	Ok          bool   `json:"ok"`

	// Describes why a request was unsuccessful.
	Parameters *ResponseParameters `json:"parameters,omitempty"`
}

// This object represents a file ready to be downloaded. The file can be downloaded via the link `https://api.telegram.org/file/bot<token>/<file_path>`. It is guaranteed that the link will be valid for at least 1 hour. When the link expires, a new one can be requested by calling [getFile](https://core.telegram.org/bots/api/#getfile).
//
// The maximum file size to download is 20 MB
type File struct {
	// Identifier for this file, which can be used to download or reuse the file
	FileId string `json:"file_id"`

	// *Optional*. File path. Use `https://api.telegram.org/file/bot<token>/<file_path>` to get the file.
	FilePath *string `json:"file_path,omitempty"`

	// *Optional*. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value.
	FileSize *int `json:"file_size,omitempty"`

	// Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file.
	FileUniqueId string `json:"file_unique_id"`
}

// Upon receiving a message with this object, Telegram clients will display a reply interface to the user (act as if the user has selected the bot's message and tapped 'Reply'). This can be extremely useful if you want to create user-friendly step-by-step interfaces without having to sacrifice [privacy mode](https://core.telegram.org/bots#privacy-mode).
type ForceReply struct {
	// Shows reply interface to the user, as if they manually selected the bot's message and tapped 'Reply'
	ForceReply bool `json:"force_reply"`

	// *Optional*. The placeholder to be shown in the input field when the reply is active; 1-64 characters
	InputFieldPlaceholder *string `json:"input_field_placeholder,omitempty"`

	// *Optional*. Use this parameter if you want to force reply from specific users only. Targets: 1) users that are @mentioned in the *text* of the [Message](https://core.telegram.org/bots/api/#message) object; 2) if the bot's message is a reply (has *reply\_to\_message\_id*), sender of the original message.
	Selective *bool `json:"selective,omitempty"`
}

// This object represents a game. Use BotFather to create and edit games, their short names will act as unique identifiers.
type Game struct {
	// This object represents an animation file (GIF or H.264/MPEG-4 AVC video without sound).
	Animation *Animation `json:"animation,omitempty"`

	// Description of the game
	Description string `json:"description"`

	// Photo that will be displayed in the game message in chats.
	Photo []PhotoSize `json:"photo"`

	// *Optional*. Brief description of the game or high scores included in the game message. Can be automatically edited to include current high scores for the game when the bot calls [setGameScore](https://core.telegram.org/bots/api/#setgamescore), or manually edited using [editMessageText](https://core.telegram.org/bots/api/#editmessagetext). 0-4096 characters.
	Text *string `json:"text,omitempty"`

	// *Optional*. Special entities that appear in *text*, such as usernames, URLs, bot commands, etc.
	TextEntities *[]MessageEntity `json:"text_entities,omitempty"`

	// Title of the game
	Title string `json:"title"`
}

// This object represents one row of the high scores table for a game.
type GameHighScore struct {
	// Position in high score table for the game
	Position int `json:"position"`

	// Score
	Score int `json:"score"`

	// This object represents a Telegram user or bot.
	User User `json:"user"`
}

// This object represents one button of an inline keyboard. You **must** use exactly one of the optional fields.
type InlineKeyboardButton struct {
	// *Optional*. Data to be sent in a [callback query](https://core.telegram.org/bots/api/#callbackquery) to the bot when button is pressed, 1-64 bytes
	CallbackData *string `json:"callback_data,omitempty"`

	// A placeholder, currently holds no information. Use [BotFather](https://t.me/botfather) to set up your game.
	CallbackGame *CallbackGame `json:"callback_game,omitempty"`

	// This object represents a parameter of the inline keyboard button used to automatically authorize a user. Serves as a great replacement for the [Telegram Login Widget](https://core.telegram.org/widgets/login) when the user is coming from Telegram. All the user needs to do is tap/click a button and confirm that they want to log in:
	//
	// Telegram apps support these buttons as of [version 5.7](https://telegram.org/blog/privacy-discussions-web-bots#meet-seamless-web-bots).
	//
	// Sample bot: [@discussbot](https://t.me/discussbot)
	LoginUrl *LoginUrl `json:"login_url,omitempty"`

	// *Optional*. Specify *True*, to send a [Pay button](https://core.telegram.org/bots/api/#payments).
	//
	// **NOTE:** This type of button **must** always be the first button in the first row and can only be used in invoice messages.
	Pay *bool `json:"pay,omitempty"`

	// *Optional*. If set, pressing the button will prompt the user to select one of their chats, open that chat and insert the bot's username and the specified inline query in the input field. May be empty, in which case just the bot's username will be inserted.
	//
	// **Note:** This offers an easy way for users to start using your bot in [inline mode](https://core.telegram.org/bots/inline) when they are currently in a private chat with it. Especially useful when combined with [*switch\_pm‚Ä¶*](https://core.telegram.org/bots/api/#answerinlinequery) actions - in this case the user will be automatically returned to the chat they switched from, skipping the chat selection screen.
	SwitchInlineQuery *string `json:"switch_inline_query,omitempty"`

	// *Optional*. If set, pressing the button will insert the bot's username and the specified inline query in the current chat's input field. May be empty, in which case only the bot's username will be inserted.
	//
	// This offers a quick way for the user to open your bot in inline mode in the same chat - good for selecting something from multiple options.
	SwitchInlineQueryCurrentChat *string `json:"switch_inline_query_current_chat,omitempty"`

	// Label text on the button
	Text string `json:"text"`

	// *Optional*. HTTP or tg:// URL to be opened when the button is pressed. Links `tg://user?id=<user_id>` can be used to mention a user by their ID without using a username, if this is allowed by their privacy settings.
	Url *string `json:"url,omitempty"`

	// Describes a [Web App](https://core.telegram.org/bots/webapps).
	WebApp *WebAppInfo `json:"web_app,omitempty"`
}

// This object represents an [inline keyboard](https://core.telegram.org/bots#inline-keyboards-and-on-the-fly-updating) that appears right next to the message it belongs to.
type InlineKeyboardMarkup struct {
	// Array of button rows, each represented by an Array of [InlineKeyboardButton](https://core.telegram.org/bots/api/#inlinekeyboardbutton) objects
	InlineKeyboard [][]InlineKeyboardButton `json:"inline_keyboard"`
}

// This object represents an incoming inline query. When the user sends an empty query, your bot could return some default or trending results.
type InlineQuery struct {
	// *Optional*. Type of the chat from which the inline query was sent. Can be either ‚Äúsender‚Äù for a private chat with the inline query sender, ‚Äúprivate‚Äù, ‚Äúgroup‚Äù, ‚Äúsupergroup‚Äù, or ‚Äúchannel‚Äù. The chat type should be always known for requests sent from official clients and most third-party clients, unless the request was sent from a secret chat
	ChatType *InlineQueryChatType `json:"chat_type,omitempty"`

	// This object represents a Telegram user or bot.
	From User `json:"from"`

	// Unique identifier for this query
	Id string `json:"id"`

	// This object represents a point on the map.
	Location *Location `json:"location,omitempty"`

	// Offset of the results to be returned, can be controlled by the bot
	Offset string `json:"offset"`

	// Text of the query (up to 256 characters)
	Query string `json:"query"`
}

// *Optional*. Type of the chat from which the inline query was sent. Can be either ‚Äúsender‚Äù for a private chat with the inline query sender, ‚Äúprivate‚Äù, ‚Äúgroup‚Äù, ‚Äúsupergroup‚Äù, or ‚Äúchannel‚Äù. The chat type should be always known for requests sent from official clients and most third-party clients, unless the request was sent from a secret chat
type InlineQueryChatType string

// This object represents one result of an inline query. Telegram clients currently support results of the following 20 types:
//
// * [InlineQueryResultCachedAudio](https://core.telegram.org/bots/api/#inlinequeryresultcachedaudio)
// * [InlineQueryResultCachedDocument](https://core.telegram.org/bots/api/#inlinequeryresultcacheddocument)
// * [InlineQueryResultCachedGif](https://core.telegram.org/bots/api/#inlinequeryresultcachedgif)
// * [InlineQueryResultCachedMpeg4Gif](https://core.telegram.org/bots/api/#inlinequeryresultcachedmpeg4gif)
// * [InlineQueryResultCachedPhoto](https://core.telegram.org/bots/api/#inlinequeryresultcachedphoto)
// * [InlineQueryResultCachedSticker](https://core.telegram.org/bots/api/#inlinequeryresultcachedsticker)
// * [InlineQueryResultCachedVideo](https://core.telegram.org/bots/api/#inlinequeryresultcachedvideo)
// * [InlineQueryResultCachedVoice](https://core.telegram.org/bots/api/#inlinequeryresultcachedvoice)
// * [InlineQueryResultArticle](https://core.telegram.org/bots/api/#inlinequeryresultarticle)
// * [InlineQueryResultAudio](https://core.telegram.org/bots/api/#inlinequeryresultaudio)
// * [InlineQueryResultContact](https://core.telegram.org/bots/api/#inlinequeryresultcontact)
// * [InlineQueryResultGame](https://core.telegram.org/bots/api/#inlinequeryresultgame)
// * [InlineQueryResultDocument](https://core.telegram.org/bots/api/#inlinequeryresultdocument)
// * [InlineQueryResultGif](https://core.telegram.org/bots/api/#inlinequeryresultgif)
// * [InlineQueryResultLocation](https://core.telegram.org/bots/api/#inlinequeryresultlocation)
// * [InlineQueryResultMpeg4Gif](https://core.telegram.org/bots/api/#inlinequeryresultmpeg4gif)
// * [InlineQueryResultPhoto](https://core.telegram.org/bots/api/#inlinequeryresultphoto)
// * [InlineQueryResultVenue](https://core.telegram.org/bots/api/#inlinequeryresultvenue)
// * [InlineQueryResultVideo](https://core.telegram.org/bots/api/#inlinequeryresultvideo)
// * [InlineQueryResultVoice](https://core.telegram.org/bots/api/#inlinequeryresultvoice)
type InlineQueryResult interface{}

// Represents a link to an article or web page.
type InlineQueryResultArticle struct {
	// *Optional*. Short description of the result
	Description *string `json:"description,omitempty"`

	// *Optional*. Pass *True*, if you don't want the URL to be shown in the message
	HideUrl *bool `json:"hide_url,omitempty"`

	// Unique identifier for this result, 1-64 Bytes
	Id string `json:"id"`

	// This object represents the content of a message to be sent as a result of an inline query. Telegram clients currently support the following 5 types:
	//
	// * [InputTextMessageContent](https://core.telegram.org/bots/api/#inputtextmessagecontent)
	// * [InputLocationMessageContent](https://core.telegram.org/bots/api/#inputlocationmessagecontent)
	// * [InputVenueMessageContent](https://core.telegram.org/bots/api/#inputvenuemessagecontent)
	// * [InputContactMessageContent](https://core.telegram.org/bots/api/#inputcontactmessagecontent)
	// * [InputInvoiceMessageContent](https://core.telegram.org/bots/api/#inputinvoicemessagecontent)
	InputMessageContent InputMessageContent `json:"input_message_content"`

	// This object represents an [inline keyboard](https://core.telegram.org/bots#inline-keyboards-and-on-the-fly-updating) that appears right next to the message it belongs to.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`

	// *Optional*. Thumbnail height
	ThumbHeight *int `json:"thumb_height,omitempty"`

	// *Optional*. Url of the thumbnail for the result
	ThumbUrl *string `json:"thumb_url,omitempty"`

	// *Optional*. Thumbnail width
	ThumbWidth *int `json:"thumb_width,omitempty"`

	// Title of the result
	Title string `json:"title"`

	// Type of the result, must be *article*
	Type string `json:"type"`

	// *Optional*. URL of the result
	Url *string `json:"url,omitempty"`
}

// Represents a link to an MP3 audio file. By default, this audio file will be sent by the user. Alternatively, you can use *input\_message\_content* to send a message with the specified content instead of the audio.
type InlineQueryResultAudio struct {
	// *Optional*. Audio duration in seconds
	AudioDuration *int `json:"audio_duration,omitempty"`

	// A valid URL for the audio file
	AudioUrl string `json:"audio_url"`

	// *Optional*. Caption, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`

	// *Optional*. List of special entities that appear in the caption, which can be specified instead of *parse\_mode*
	CaptionEntities *[]MessageEntity `json:"caption_entities,omitempty"`

	// Unique identifier for this result, 1-64 bytes
	Id string `json:"id"`

	// This object represents the content of a message to be sent as a result of an inline query. Telegram clients currently support the following 5 types:
	//
	// * [InputTextMessageContent](https://core.telegram.org/bots/api/#inputtextmessagecontent)
	// * [InputLocationMessageContent](https://core.telegram.org/bots/api/#inputlocationmessagecontent)
	// * [InputVenueMessageContent](https://core.telegram.org/bots/api/#inputvenuemessagecontent)
	// * [InputContactMessageContent](https://core.telegram.org/bots/api/#inputcontactmessagecontent)
	// * [InputInvoiceMessageContent](https://core.telegram.org/bots/api/#inputinvoicemessagecontent)
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`

	// *Optional*. Mode for parsing entities in the audio caption. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
	ParseMode *string `json:"parse_mode,omitempty"`

	// *Optional*. Performer
	Performer *string `json:"performer,omitempty"`

	// This object represents an [inline keyboard](https://core.telegram.org/bots#inline-keyboards-and-on-the-fly-updating) that appears right next to the message it belongs to.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`

	// Title
	Title string `json:"title"`

	// Type of the result, must be *audio*
	Type string `json:"type"`
}

// Represents a link to an MP3 audio file stored on the Telegram servers. By default, this audio file will be sent by the user. Alternatively, you can use *input\_message\_content* to send a message with the specified content instead of the audio.
type InlineQueryResultCachedAudio struct {
	// A valid file identifier for the audio file
	AudioFileId string `json:"audio_file_id"`

	// *Optional*. Caption, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`

	// *Optional*. List of special entities that appear in the caption, which can be specified instead of *parse\_mode*
	CaptionEntities *[]MessageEntity `json:"caption_entities,omitempty"`

	// Unique identifier for this result, 1-64 bytes
	Id string `json:"id"`

	// This object represents the content of a message to be sent as a result of an inline query. Telegram clients currently support the following 5 types:
	//
	// * [InputTextMessageContent](https://core.telegram.org/bots/api/#inputtextmessagecontent)
	// * [InputLocationMessageContent](https://core.telegram.org/bots/api/#inputlocationmessagecontent)
	// * [InputVenueMessageContent](https://core.telegram.org/bots/api/#inputvenuemessagecontent)
	// * [InputContactMessageContent](https://core.telegram.org/bots/api/#inputcontactmessagecontent)
	// * [InputInvoiceMessageContent](https://core.telegram.org/bots/api/#inputinvoicemessagecontent)
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`

	// *Optional*. Mode for parsing entities in the audio caption. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
	ParseMode *string `json:"parse_mode,omitempty"`

	// This object represents an [inline keyboard](https://core.telegram.org/bots#inline-keyboards-and-on-the-fly-updating) that appears right next to the message it belongs to.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`

	// Type of the result, must be *audio*
	Type string `json:"type"`
}

// Represents a link to a file stored on the Telegram servers. By default, this file will be sent by the user with an optional caption. Alternatively, you can use *input\_message\_content* to send a message with the specified content instead of the file.
type InlineQueryResultCachedDocument struct {
	// *Optional*. Caption of the document to be sent, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`

	// *Optional*. List of special entities that appear in the caption, which can be specified instead of *parse\_mode*
	CaptionEntities *[]MessageEntity `json:"caption_entities,omitempty"`

	// *Optional*. Short description of the result
	Description *string `json:"description,omitempty"`

	// A valid file identifier for the file
	DocumentFileId string `json:"document_file_id"`

	// Unique identifier for this result, 1-64 bytes
	Id string `json:"id"`

	// This object represents the content of a message to be sent as a result of an inline query. Telegram clients currently support the following 5 types:
	//
	// * [InputTextMessageContent](https://core.telegram.org/bots/api/#inputtextmessagecontent)
	// * [InputLocationMessageContent](https://core.telegram.org/bots/api/#inputlocationmessagecontent)
	// * [InputVenueMessageContent](https://core.telegram.org/bots/api/#inputvenuemessagecontent)
	// * [InputContactMessageContent](https://core.telegram.org/bots/api/#inputcontactmessagecontent)
	// * [InputInvoiceMessageContent](https://core.telegram.org/bots/api/#inputinvoicemessagecontent)
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`

	// *Optional*. Mode for parsing entities in the document caption. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
	ParseMode *string `json:"parse_mode,omitempty"`

	// This object represents an [inline keyboard](https://core.telegram.org/bots#inline-keyboards-and-on-the-fly-updating) that appears right next to the message it belongs to.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`

	// Title for the result
	Title string `json:"title"`

	// Type of the result, must be *document*
	Type string `json:"type"`
}

// Represents a link to an animated GIF file stored on the Telegram servers. By default, this animated GIF file will be sent by the user with an optional caption. Alternatively, you can use *input\_message\_content* to send a message with specified content instead of the animation.
type InlineQueryResultCachedGif struct {
	// *Optional*. Caption of the GIF file to be sent, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`

	// *Optional*. List of special entities that appear in the caption, which can be specified instead of *parse\_mode*
	CaptionEntities *[]MessageEntity `json:"caption_entities,omitempty"`

	// A valid file identifier for the GIF file
	GifFileId string `json:"gif_file_id"`

	// Unique identifier for this result, 1-64 bytes
	Id string `json:"id"`

	// This object represents the content of a message to be sent as a result of an inline query. Telegram clients currently support the following 5 types:
	//
	// * [InputTextMessageContent](https://core.telegram.org/bots/api/#inputtextmessagecontent)
	// * [InputLocationMessageContent](https://core.telegram.org/bots/api/#inputlocationmessagecontent)
	// * [InputVenueMessageContent](https://core.telegram.org/bots/api/#inputvenuemessagecontent)
	// * [InputContactMessageContent](https://core.telegram.org/bots/api/#inputcontactmessagecontent)
	// * [InputInvoiceMessageContent](https://core.telegram.org/bots/api/#inputinvoicemessagecontent)
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`

	// *Optional*. Mode for parsing entities in the caption. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
	ParseMode *string `json:"parse_mode,omitempty"`

	// This object represents an [inline keyboard](https://core.telegram.org/bots#inline-keyboards-and-on-the-fly-updating) that appears right next to the message it belongs to.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`

	// *Optional*. Title for the result
	Title *string `json:"title,omitempty"`

	// Type of the result, must be *gif*
	Type string `json:"type"`
}

// Represents a link to a video animation (H.264/MPEG-4 AVC video without sound) stored on the Telegram servers. By default, this animated MPEG-4 file will be sent by the user with an optional caption. Alternatively, you can use *input\_message\_content* to send a message with the specified content instead of the animation.
type InlineQueryResultCachedMpeg4Gif struct {
	// *Optional*. Caption of the MPEG-4 file to be sent, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`

	// *Optional*. List of special entities that appear in the caption, which can be specified instead of *parse\_mode*
	CaptionEntities *[]MessageEntity `json:"caption_entities,omitempty"`

	// Unique identifier for this result, 1-64 bytes
	Id string `json:"id"`

	// This object represents the content of a message to be sent as a result of an inline query. Telegram clients currently support the following 5 types:
	//
	// * [InputTextMessageContent](https://core.telegram.org/bots/api/#inputtextmessagecontent)
	// * [InputLocationMessageContent](https://core.telegram.org/bots/api/#inputlocationmessagecontent)
	// * [InputVenueMessageContent](https://core.telegram.org/bots/api/#inputvenuemessagecontent)
	// * [InputContactMessageContent](https://core.telegram.org/bots/api/#inputcontactmessagecontent)
	// * [InputInvoiceMessageContent](https://core.telegram.org/bots/api/#inputinvoicemessagecontent)
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`

	// A valid file identifier for the MPEG4 file
	Mpeg4FileId string `json:"mpeg4_file_id"`

	// *Optional*. Mode for parsing entities in the caption. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
	ParseMode *string `json:"parse_mode,omitempty"`

	// This object represents an [inline keyboard](https://core.telegram.org/bots#inline-keyboards-and-on-the-fly-updating) that appears right next to the message it belongs to.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`

	// *Optional*. Title for the result
	Title *string `json:"title,omitempty"`

	// Type of the result, must be *mpeg4\_gif*
	Type string `json:"type"`
}

// Represents a link to a photo stored on the Telegram servers. By default, this photo will be sent by the user with an optional caption. Alternatively, you can use *input\_message\_content* to send a message with the specified content instead of the photo.
type InlineQueryResultCachedPhoto struct {
	// *Optional*. Caption of the photo to be sent, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`

	// *Optional*. List of special entities that appear in the caption, which can be specified instead of *parse\_mode*
	CaptionEntities *[]MessageEntity `json:"caption_entities,omitempty"`

	// *Optional*. Short description of the result
	Description *string `json:"description,omitempty"`

	// Unique identifier for this result, 1-64 bytes
	Id string `json:"id"`

	// This object represents the content of a message to be sent as a result of an inline query. Telegram clients currently support the following 5 types:
	//
	// * [InputTextMessageContent](https://core.telegram.org/bots/api/#inputtextmessagecontent)
	// * [InputLocationMessageContent](https://core.telegram.org/bots/api/#inputlocationmessagecontent)
	// * [InputVenueMessageContent](https://core.telegram.org/bots/api/#inputvenuemessagecontent)
	// * [InputContactMessageContent](https://core.telegram.org/bots/api/#inputcontactmessagecontent)
	// * [InputInvoiceMessageContent](https://core.telegram.org/bots/api/#inputinvoicemessagecontent)
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`

	// *Optional*. Mode for parsing entities in the photo caption. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
	ParseMode *string `json:"parse_mode,omitempty"`

	// A valid file identifier of the photo
	PhotoFileId string `json:"photo_file_id"`

	// This object represents an [inline keyboard](https://core.telegram.org/bots#inline-keyboards-and-on-the-fly-updating) that appears right next to the message it belongs to.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`

	// *Optional*. Title for the result
	Title *string `json:"title,omitempty"`

	// Type of the result, must be *photo*
	Type string `json:"type"`
}

// Represents a link to a sticker stored on the Telegram servers. By default, this sticker will be sent by the user. Alternatively, you can use *input\_message\_content* to send a message with the specified content instead of the sticker.
type InlineQueryResultCachedSticker struct {
	// Unique identifier for this result, 1-64 bytes
	Id string `json:"id"`

	// This object represents the content of a message to be sent as a result of an inline query. Telegram clients currently support the following 5 types:
	//
	// * [InputTextMessageContent](https://core.telegram.org/bots/api/#inputtextmessagecontent)
	// * [InputLocationMessageContent](https://core.telegram.org/bots/api/#inputlocationmessagecontent)
	// * [InputVenueMessageContent](https://core.telegram.org/bots/api/#inputvenuemessagecontent)
	// * [InputContactMessageContent](https://core.telegram.org/bots/api/#inputcontactmessagecontent)
	// * [InputInvoiceMessageContent](https://core.telegram.org/bots/api/#inputinvoicemessagecontent)
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`

	// This object represents an [inline keyboard](https://core.telegram.org/bots#inline-keyboards-and-on-the-fly-updating) that appears right next to the message it belongs to.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`

	// A valid file identifier of the sticker
	StickerFileId string `json:"sticker_file_id"`

	// Type of the result, must be *sticker*
	Type string `json:"type"`
}

// Represents a link to a video file stored on the Telegram servers. By default, this video file will be sent by the user with an optional caption. Alternatively, you can use *input\_message\_content* to send a message with the specified content instead of the video.
type InlineQueryResultCachedVideo struct {
	// *Optional*. Caption of the video to be sent, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`

	// *Optional*. List of special entities that appear in the caption, which can be specified instead of *parse\_mode*
	CaptionEntities *[]MessageEntity `json:"caption_entities,omitempty"`

	// *Optional*. Short description of the result
	Description *string `json:"description,omitempty"`

	// Unique identifier for this result, 1-64 bytes
	Id string `json:"id"`

	// This object represents the content of a message to be sent as a result of an inline query. Telegram clients currently support the following 5 types:
	//
	// * [InputTextMessageContent](https://core.telegram.org/bots/api/#inputtextmessagecontent)
	// * [InputLocationMessageContent](https://core.telegram.org/bots/api/#inputlocationmessagecontent)
	// * [InputVenueMessageContent](https://core.telegram.org/bots/api/#inputvenuemessagecontent)
	// * [InputContactMessageContent](https://core.telegram.org/bots/api/#inputcontactmessagecontent)
	// * [InputInvoiceMessageContent](https://core.telegram.org/bots/api/#inputinvoicemessagecontent)
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`

	// *Optional*. Mode for parsing entities in the video caption. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
	ParseMode *string `json:"parse_mode,omitempty"`

	// This object represents an [inline keyboard](https://core.telegram.org/bots#inline-keyboards-and-on-the-fly-updating) that appears right next to the message it belongs to.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`

	// Title for the result
	Title string `json:"title"`

	// Type of the result, must be *video*
	Type string `json:"type"`

	// A valid file identifier for the video file
	VideoFileId string `json:"video_file_id"`
}

// Represents a link to a voice message stored on the Telegram servers. By default, this voice message will be sent by the user. Alternatively, you can use *input\_message\_content* to send a message with the specified content instead of the voice message.
type InlineQueryResultCachedVoice struct {
	// *Optional*. Caption, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`

	// *Optional*. List of special entities that appear in the caption, which can be specified instead of *parse\_mode*
	CaptionEntities *[]MessageEntity `json:"caption_entities,omitempty"`

	// Unique identifier for this result, 1-64 bytes
	Id string `json:"id"`

	// This object represents the content of a message to be sent as a result of an inline query. Telegram clients currently support the following 5 types:
	//
	// * [InputTextMessageContent](https://core.telegram.org/bots/api/#inputtextmessagecontent)
	// * [InputLocationMessageContent](https://core.telegram.org/bots/api/#inputlocationmessagecontent)
	// * [InputVenueMessageContent](https://core.telegram.org/bots/api/#inputvenuemessagecontent)
	// * [InputContactMessageContent](https://core.telegram.org/bots/api/#inputcontactmessagecontent)
	// * [InputInvoiceMessageContent](https://core.telegram.org/bots/api/#inputinvoicemessagecontent)
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`

	// *Optional*. Mode for parsing entities in the voice message caption. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
	ParseMode *string `json:"parse_mode,omitempty"`

	// This object represents an [inline keyboard](https://core.telegram.org/bots#inline-keyboards-and-on-the-fly-updating) that appears right next to the message it belongs to.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`

	// Voice message title
	Title string `json:"title"`

	// Type of the result, must be *voice*
	Type string `json:"type"`

	// A valid file identifier for the voice message
	VoiceFileId string `json:"voice_file_id"`
}

// Represents a contact with a phone number. By default, this contact will be sent by the user. Alternatively, you can use *input\_message\_content* to send a message with the specified content instead of the contact.
type InlineQueryResultContact struct {
	// Contact's first name
	FirstName string `json:"first_name"`

	// Unique identifier for this result, 1-64 Bytes
	Id string `json:"id"`

	// This object represents the content of a message to be sent as a result of an inline query. Telegram clients currently support the following 5 types:
	//
	// * [InputTextMessageContent](https://core.telegram.org/bots/api/#inputtextmessagecontent)
	// * [InputLocationMessageContent](https://core.telegram.org/bots/api/#inputlocationmessagecontent)
	// * [InputVenueMessageContent](https://core.telegram.org/bots/api/#inputvenuemessagecontent)
	// * [InputContactMessageContent](https://core.telegram.org/bots/api/#inputcontactmessagecontent)
	// * [InputInvoiceMessageContent](https://core.telegram.org/bots/api/#inputinvoicemessagecontent)
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`

	// *Optional*. Contact's last name
	LastName *string `json:"last_name,omitempty"`

	// Contact's phone number
	PhoneNumber string `json:"phone_number"`

	// This object represents an [inline keyboard](https://core.telegram.org/bots#inline-keyboards-and-on-the-fly-updating) that appears right next to the message it belongs to.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`

	// *Optional*. Thumbnail height
	ThumbHeight *int `json:"thumb_height,omitempty"`

	// *Optional*. Url of the thumbnail for the result
	ThumbUrl *string `json:"thumb_url,omitempty"`

	// *Optional*. Thumbnail width
	ThumbWidth *int `json:"thumb_width,omitempty"`

	// Type of the result, must be *contact*
	Type string `json:"type"`

	// *Optional*. Additional data about the contact in the form of a [vCard](https://en.wikipedia.org/wiki/VCard), 0-2048 bytes
	Vcard *string `json:"vcard,omitempty"`
}

// Represents a link to a file. By default, this file will be sent by the user with an optional caption. Alternatively, you can use *input\_message\_content* to send a message with the specified content instead of the file. Currently, only **.PDF** and **.ZIP** files can be sent using this method.
type InlineQueryResultDocument struct {
	// *Optional*. Caption of the document to be sent, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`

	// *Optional*. List of special entities that appear in the caption, which can be specified instead of *parse\_mode*
	CaptionEntities *[]MessageEntity `json:"caption_entities,omitempty"`

	// *Optional*. Short description of the result
	Description *string `json:"description,omitempty"`

	// A valid URL for the file
	DocumentUrl string `json:"document_url"`

	// Unique identifier for this result, 1-64 bytes
	Id string `json:"id"`

	// This object represents the content of a message to be sent as a result of an inline query. Telegram clients currently support the following 5 types:
	//
	// * [InputTextMessageContent](https://core.telegram.org/bots/api/#inputtextmessagecontent)
	// * [InputLocationMessageContent](https://core.telegram.org/bots/api/#inputlocationmessagecontent)
	// * [InputVenueMessageContent](https://core.telegram.org/bots/api/#inputvenuemessagecontent)
	// * [InputContactMessageContent](https://core.telegram.org/bots/api/#inputcontactmessagecontent)
	// * [InputInvoiceMessageContent](https://core.telegram.org/bots/api/#inputinvoicemessagecontent)
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`

	// MIME type of the content of the file, either ‚Äúapplication/pdf‚Äù or ‚Äúapplication/zip‚Äù
	MimeType InlineQueryResultDocumentMimeType `json:"mime_type"`

	// *Optional*. Mode for parsing entities in the document caption. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
	ParseMode *string `json:"parse_mode,omitempty"`

	// This object represents an [inline keyboard](https://core.telegram.org/bots#inline-keyboards-and-on-the-fly-updating) that appears right next to the message it belongs to.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`

	// *Optional*. Thumbnail height
	ThumbHeight *int `json:"thumb_height,omitempty"`

	// *Optional*. URL of the thumbnail (JPEG only) for the file
	ThumbUrl *string `json:"thumb_url,omitempty"`

	// *Optional*. Thumbnail width
	ThumbWidth *int `json:"thumb_width,omitempty"`

	// Title for the result
	Title string `json:"title"`

	// Type of the result, must be *document*
	Type string `json:"type"`
}

// MIME type of the content of the file, either ‚Äúapplication/pdf‚Äù or ‚Äúapplication/zip‚Äù
type InlineQueryResultDocumentMimeType string

// Represents a [Game](https://core.telegram.org/bots/api/#games).
type InlineQueryResultGame struct {
	// Short name of the game
	GameShortName string `json:"game_short_name"`

	// Unique identifier for this result, 1-64 bytes
	Id string `json:"id"`

	// This object represents an [inline keyboard](https://core.telegram.org/bots#inline-keyboards-and-on-the-fly-updating) that appears right next to the message it belongs to.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`

	// Type of the result, must be *game*
	Type string `json:"type"`
}

// Represents a link to an animated GIF file. By default, this animated GIF file will be sent by the user with optional caption. Alternatively, you can use *input\_message\_content* to send a message with the specified content instead of the animation.
type InlineQueryResultGif struct {
	// *Optional*. Caption of the GIF file to be sent, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`

	// *Optional*. List of special entities that appear in the caption, which can be specified instead of *parse\_mode*
	CaptionEntities *[]MessageEntity `json:"caption_entities,omitempty"`

	// *Optional*. Duration of the GIF in seconds
	GifDuration *int `json:"gif_duration,omitempty"`

	// *Optional*. Height of the GIF
	GifHeight *int `json:"gif_height,omitempty"`

	// A valid URL for the GIF file. File size must not exceed 1MB
	GifUrl string `json:"gif_url"`

	// *Optional*. Width of the GIF
	GifWidth *int `json:"gif_width,omitempty"`

	// Unique identifier for this result, 1-64 bytes
	Id string `json:"id"`

	// This object represents the content of a message to be sent as a result of an inline query. Telegram clients currently support the following 5 types:
	//
	// * [InputTextMessageContent](https://core.telegram.org/bots/api/#inputtextmessagecontent)
	// * [InputLocationMessageContent](https://core.telegram.org/bots/api/#inputlocationmessagecontent)
	// * [InputVenueMessageContent](https://core.telegram.org/bots/api/#inputvenuemessagecontent)
	// * [InputContactMessageContent](https://core.telegram.org/bots/api/#inputcontactmessagecontent)
	// * [InputInvoiceMessageContent](https://core.telegram.org/bots/api/#inputinvoicemessagecontent)
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`

	// *Optional*. Mode for parsing entities in the caption. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
	ParseMode *string `json:"parse_mode,omitempty"`

	// This object represents an [inline keyboard](https://core.telegram.org/bots#inline-keyboards-and-on-the-fly-updating) that appears right next to the message it belongs to.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`

	// *Optional*. MIME type of the thumbnail, must be one of ‚Äúimage/jpeg‚Äù, ‚Äúimage/gif‚Äù, or ‚Äúvideo/mp4‚Äù. Defaults to ‚Äúimage/jpeg‚Äù
	ThumbMimeType *InlineQueryResultGifThumbMimeType `json:"thumb_mime_type,omitempty"`

	// URL of the static (JPEG or GIF) or animated (MPEG4) thumbnail for the result
	ThumbUrl string `json:"thumb_url"`

	// *Optional*. Title for the result
	Title *string `json:"title,omitempty"`

	// Type of the result, must be *gif*
	Type string `json:"type"`
}

// *Optional*. MIME type of the thumbnail, must be one of ‚Äúimage/jpeg‚Äù, ‚Äúimage/gif‚Äù, or ‚Äúvideo/mp4‚Äù. Defaults to ‚Äúimage/jpeg‚Äù
type InlineQueryResultGifThumbMimeType string

// Represents a location on a map. By default, the location will be sent by the user. Alternatively, you can use *input\_message\_content* to send a message with the specified content instead of the location.
type InlineQueryResultLocation struct {
	// *Optional*. For live locations, a direction in which the user is moving, in degrees. Must be between 1 and 360 if specified.
	Heading *int `json:"heading,omitempty"`

	// *Optional*. The radius of uncertainty for the location, measured in meters; 0-1500
	HorizontalAccuracy *float32 `json:"horizontal_accuracy,omitempty"`

	// Unique identifier for this result, 1-64 Bytes
	Id string `json:"id"`

	// This object represents the content of a message to be sent as a result of an inline query. Telegram clients currently support the following 5 types:
	//
	// * [InputTextMessageContent](https://core.telegram.org/bots/api/#inputtextmessagecontent)
	// * [InputLocationMessageContent](https://core.telegram.org/bots/api/#inputlocationmessagecontent)
	// * [InputVenueMessageContent](https://core.telegram.org/bots/api/#inputvenuemessagecontent)
	// * [InputContactMessageContent](https://core.telegram.org/bots/api/#inputcontactmessagecontent)
	// * [InputInvoiceMessageContent](https://core.telegram.org/bots/api/#inputinvoicemessagecontent)
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`

	// Location latitude in degrees
	Latitude float32 `json:"latitude"`

	// *Optional*. Period in seconds for which the location can be updated, should be between 60 and 86400.
	LivePeriod *int `json:"live_period,omitempty"`

	// Location longitude in degrees
	Longitude float32 `json:"longitude"`

	// *Optional*. For live locations, a maximum distance for proximity alerts about approaching another chat member, in meters. Must be between 1 and 100000 if specified.
	ProximityAlertRadius *int `json:"proximity_alert_radius,omitempty"`

	// This object represents an [inline keyboard](https://core.telegram.org/bots#inline-keyboards-and-on-the-fly-updating) that appears right next to the message it belongs to.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`

	// *Optional*. Thumbnail height
	ThumbHeight *int `json:"thumb_height,omitempty"`

	// *Optional*. Url of the thumbnail for the result
	ThumbUrl *string `json:"thumb_url,omitempty"`

	// *Optional*. Thumbnail width
	ThumbWidth *int `json:"thumb_width,omitempty"`

	// Location title
	Title string `json:"title"`

	// Type of the result, must be *location*
	Type string `json:"type"`
}

// Represents a link to a video animation (H.264/MPEG-4 AVC video without sound). By default, this animated MPEG-4 file will be sent by the user with optional caption. Alternatively, you can use *input\_message\_content* to send a message with the specified content instead of the animation.
type InlineQueryResultMpeg4Gif struct {
	// *Optional*. Caption of the MPEG-4 file to be sent, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`

	// *Optional*. List of special entities that appear in the caption, which can be specified instead of *parse\_mode*
	CaptionEntities *[]MessageEntity `json:"caption_entities,omitempty"`

	// Unique identifier for this result, 1-64 bytes
	Id string `json:"id"`

	// This object represents the content of a message to be sent as a result of an inline query. Telegram clients currently support the following 5 types:
	//
	// * [InputTextMessageContent](https://core.telegram.org/bots/api/#inputtextmessagecontent)
	// * [InputLocationMessageContent](https://core.telegram.org/bots/api/#inputlocationmessagecontent)
	// * [InputVenueMessageContent](https://core.telegram.org/bots/api/#inputvenuemessagecontent)
	// * [InputContactMessageContent](https://core.telegram.org/bots/api/#inputcontactmessagecontent)
	// * [InputInvoiceMessageContent](https://core.telegram.org/bots/api/#inputinvoicemessagecontent)
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`

	// *Optional*. Video duration in seconds
	Mpeg4Duration *int `json:"mpeg4_duration,omitempty"`

	// *Optional*. Video height
	Mpeg4Height *int `json:"mpeg4_height,omitempty"`

	// A valid URL for the MPEG4 file. File size must not exceed 1MB
	Mpeg4Url string `json:"mpeg4_url"`

	// *Optional*. Video width
	Mpeg4Width *int `json:"mpeg4_width,omitempty"`

	// *Optional*. Mode for parsing entities in the caption. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
	ParseMode *string `json:"parse_mode,omitempty"`

	// This object represents an [inline keyboard](https://core.telegram.org/bots#inline-keyboards-and-on-the-fly-updating) that appears right next to the message it belongs to.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`

	// *Optional*. MIME type of the thumbnail, must be one of ‚Äúimage/jpeg‚Äù, ‚Äúimage/gif‚Äù, or ‚Äúvideo/mp4‚Äù. Defaults to ‚Äúimage/jpeg‚Äù
	ThumbMimeType *InlineQueryResultMpeg4GifThumbMimeType `json:"thumb_mime_type,omitempty"`

	// URL of the static (JPEG or GIF) or animated (MPEG4) thumbnail for the result
	ThumbUrl string `json:"thumb_url"`

	// *Optional*. Title for the result
	Title *string `json:"title,omitempty"`

	// Type of the result, must be *mpeg4\_gif*
	Type string `json:"type"`
}

// *Optional*. MIME type of the thumbnail, must be one of ‚Äúimage/jpeg‚Äù, ‚Äúimage/gif‚Äù, or ‚Äúvideo/mp4‚Äù. Defaults to ‚Äúimage/jpeg‚Äù
type InlineQueryResultMpeg4GifThumbMimeType string

// Represents a link to a photo. By default, this photo will be sent by the user with optional caption. Alternatively, you can use *input\_message\_content* to send a message with the specified content instead of the photo.
type InlineQueryResultPhoto struct {
	// *Optional*. Caption of the photo to be sent, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`

	// *Optional*. List of special entities that appear in the caption, which can be specified instead of *parse\_mode*
	CaptionEntities *[]MessageEntity `json:"caption_entities,omitempty"`

	// *Optional*. Short description of the result
	Description *string `json:"description,omitempty"`

	// Unique identifier for this result, 1-64 bytes
	Id string `json:"id"`

	// This object represents the content of a message to be sent as a result of an inline query. Telegram clients currently support the following 5 types:
	//
	// * [InputTextMessageContent](https://core.telegram.org/bots/api/#inputtextmessagecontent)
	// * [InputLocationMessageContent](https://core.telegram.org/bots/api/#inputlocationmessagecontent)
	// * [InputVenueMessageContent](https://core.telegram.org/bots/api/#inputvenuemessagecontent)
	// * [InputContactMessageContent](https://core.telegram.org/bots/api/#inputcontactmessagecontent)
	// * [InputInvoiceMessageContent](https://core.telegram.org/bots/api/#inputinvoicemessagecontent)
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`

	// *Optional*. Mode for parsing entities in the photo caption. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
	ParseMode *string `json:"parse_mode,omitempty"`

	// *Optional*. Height of the photo
	PhotoHeight *int `json:"photo_height,omitempty"`

	// A valid URL of the photo. Photo must be in **JPEG** format. Photo size must not exceed 5MB
	PhotoUrl string `json:"photo_url"`

	// *Optional*. Width of the photo
	PhotoWidth *int `json:"photo_width,omitempty"`

	// This object represents an [inline keyboard](https://core.telegram.org/bots#inline-keyboards-and-on-the-fly-updating) that appears right next to the message it belongs to.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`

	// URL of the thumbnail for the photo
	ThumbUrl string `json:"thumb_url"`

	// *Optional*. Title for the result
	Title *string `json:"title,omitempty"`

	// Type of the result, must be *photo*
	Type string `json:"type"`
}

// Represents a venue. By default, the venue will be sent by the user. Alternatively, you can use *input\_message\_content* to send a message with the specified content instead of the venue.
type InlineQueryResultVenue struct {
	// Address of the venue
	Address string `json:"address"`

	// *Optional*. Foursquare identifier of the venue if known
	FoursquareId *string `json:"foursquare_id,omitempty"`

	// *Optional*. Foursquare type of the venue, if known. (For example, ‚Äúarts\_entertainment/default‚Äù, ‚Äúarts\_entertainment/aquarium‚Äù or ‚Äúfood/icecream‚Äù.)
	FoursquareType *string `json:"foursquare_type,omitempty"`

	// *Optional*. Google Places identifier of the venue
	GooglePlaceId *string `json:"google_place_id,omitempty"`

	// *Optional*. Google Places type of the venue. (See [supported types](https://developers.google.com/places/web-service/supported_types).)
	GooglePlaceType *string `json:"google_place_type,omitempty"`

	// Unique identifier for this result, 1-64 Bytes
	Id string `json:"id"`

	// This object represents the content of a message to be sent as a result of an inline query. Telegram clients currently support the following 5 types:
	//
	// * [InputTextMessageContent](https://core.telegram.org/bots/api/#inputtextmessagecontent)
	// * [InputLocationMessageContent](https://core.telegram.org/bots/api/#inputlocationmessagecontent)
	// * [InputVenueMessageContent](https://core.telegram.org/bots/api/#inputvenuemessagecontent)
	// * [InputContactMessageContent](https://core.telegram.org/bots/api/#inputcontactmessagecontent)
	// * [InputInvoiceMessageContent](https://core.telegram.org/bots/api/#inputinvoicemessagecontent)
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`

	// Latitude of the venue location in degrees
	Latitude float32 `json:"latitude"`

	// Longitude of the venue location in degrees
	Longitude float32 `json:"longitude"`

	// This object represents an [inline keyboard](https://core.telegram.org/bots#inline-keyboards-and-on-the-fly-updating) that appears right next to the message it belongs to.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`

	// *Optional*. Thumbnail height
	ThumbHeight *int `json:"thumb_height,omitempty"`

	// *Optional*. Url of the thumbnail for the result
	ThumbUrl *string `json:"thumb_url,omitempty"`

	// *Optional*. Thumbnail width
	ThumbWidth *int `json:"thumb_width,omitempty"`

	// Title of the venue
	Title string `json:"title"`

	// Type of the result, must be *venue*
	Type string `json:"type"`
}

// Represents a link to a page containing an embedded video player or a video file. By default, this video file will be sent by the user with an optional caption. Alternatively, you can use *input\_message\_content* to send a message with the specified content instead of the video.
//
// If an InlineQueryResultVideo message contains an embedded video (e.g., YouTube), you **must** replace its content using *input\_message\_content*.
type InlineQueryResultVideo struct {
	// *Optional*. Caption of the video to be sent, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`

	// *Optional*. List of special entities that appear in the caption, which can be specified instead of *parse\_mode*
	CaptionEntities *[]MessageEntity `json:"caption_entities,omitempty"`

	// *Optional*. Short description of the result
	Description *string `json:"description,omitempty"`

	// Unique identifier for this result, 1-64 bytes
	Id string `json:"id"`

	// This object represents the content of a message to be sent as a result of an inline query. Telegram clients currently support the following 5 types:
	//
	// * [InputTextMessageContent](https://core.telegram.org/bots/api/#inputtextmessagecontent)
	// * [InputLocationMessageContent](https://core.telegram.org/bots/api/#inputlocationmessagecontent)
	// * [InputVenueMessageContent](https://core.telegram.org/bots/api/#inputvenuemessagecontent)
	// * [InputContactMessageContent](https://core.telegram.org/bots/api/#inputcontactmessagecontent)
	// * [InputInvoiceMessageContent](https://core.telegram.org/bots/api/#inputinvoicemessagecontent)
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`

	// MIME type of the content of the video URL, ‚Äútext/html‚Äù or ‚Äúvideo/mp4‚Äù
	MimeType InlineQueryResultVideoMimeType `json:"mime_type"`

	// *Optional*. Mode for parsing entities in the video caption. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
	ParseMode *string `json:"parse_mode,omitempty"`

	// This object represents an [inline keyboard](https://core.telegram.org/bots#inline-keyboards-and-on-the-fly-updating) that appears right next to the message it belongs to.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`

	// URL of the thumbnail (JPEG only) for the video
	ThumbUrl string `json:"thumb_url"`

	// Title for the result
	Title string `json:"title"`

	// Type of the result, must be *video*
	Type string `json:"type"`

	// *Optional*. Video duration in seconds
	VideoDuration *int `json:"video_duration,omitempty"`

	// *Optional*. Video height
	VideoHeight *int `json:"video_height,omitempty"`

	// A valid URL for the embedded video player or video file
	VideoUrl string `json:"video_url"`

	// *Optional*. Video width
	VideoWidth *int `json:"video_width,omitempty"`
}

// MIME type of the content of the video URL, ‚Äútext/html‚Äù or ‚Äúvideo/mp4‚Äù
type InlineQueryResultVideoMimeType string

// Represents a link to a voice recording in an .OGG container encoded with OPUS. By default, this voice recording will be sent by the user. Alternatively, you can use *input\_message\_content* to send a message with the specified content instead of the the voice message.
type InlineQueryResultVoice struct {
	// *Optional*. Caption, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`

	// *Optional*. List of special entities that appear in the caption, which can be specified instead of *parse\_mode*
	CaptionEntities *[]MessageEntity `json:"caption_entities,omitempty"`

	// Unique identifier for this result, 1-64 bytes
	Id string `json:"id"`

	// This object represents the content of a message to be sent as a result of an inline query. Telegram clients currently support the following 5 types:
	//
	// * [InputTextMessageContent](https://core.telegram.org/bots/api/#inputtextmessagecontent)
	// * [InputLocationMessageContent](https://core.telegram.org/bots/api/#inputlocationmessagecontent)
	// * [InputVenueMessageContent](https://core.telegram.org/bots/api/#inputvenuemessagecontent)
	// * [InputContactMessageContent](https://core.telegram.org/bots/api/#inputcontactmessagecontent)
	// * [InputInvoiceMessageContent](https://core.telegram.org/bots/api/#inputinvoicemessagecontent)
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`

	// *Optional*. Mode for parsing entities in the voice message caption. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
	ParseMode *string `json:"parse_mode,omitempty"`

	// This object represents an [inline keyboard](https://core.telegram.org/bots#inline-keyboards-and-on-the-fly-updating) that appears right next to the message it belongs to.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`

	// Recording title
	Title string `json:"title"`

	// Type of the result, must be *voice*
	Type string `json:"type"`

	// *Optional*. Recording duration in seconds
	VoiceDuration *int `json:"voice_duration,omitempty"`

	// A valid URL for the voice recording
	VoiceUrl string `json:"voice_url"`
}

// Represents the [content](https://core.telegram.org/bots/api/#inputmessagecontent) of a contact message to be sent as the result of an inline query.
type InputContactMessageContent struct {
	// Contact's first name
	FirstName string `json:"first_name"`

	// *Optional*. Contact's last name
	LastName *string `json:"last_name,omitempty"`

	// Contact's phone number
	PhoneNumber string `json:"phone_number"`

	// *Optional*. Additional data about the contact in the form of a [vCard](https://en.wikipedia.org/wiki/VCard), 0-2048 bytes
	Vcard *string `json:"vcard,omitempty"`
}

// This object represents the contents of a file to be uploaded. Must be posted using multipart/form-data in the usual way that files are uploaded via the browser.
type InputFile = interface{}

// Represents the [content](https://core.telegram.org/bots/api/#inputmessagecontent) of an invoice message to be sent as the result of an inline query.
type InputInvoiceMessageContent struct {
	// Three-letter ISO 4217 currency code, see [more on currencies](https://core.telegram.org/bots/payments#supported-currencies)
	Currency string `json:"currency"`

	// Product description, 1-255 characters
	Description string `json:"description"`

	// *Optional*. Pass *True*, if the final price depends on the shipping method
	IsFlexible *bool `json:"is_flexible,omitempty"`

	// *Optional*. The maximum accepted amount for tips in the *smallest units* of the currency (integer, **not** float/double). For example, for a maximum tip of `US$ 1.45` pass `max_tip_amount = 145`. See the *exp* parameter in [currencies.json](https://core.telegram.org/bots/payments/currencies.json), it shows the number of digits past the decimal point for each currency (2 for the majority of currencies). Defaults to 0
	MaxTipAmount *int `json:"max_tip_amount,omitempty"`

	// *Optional*. Pass *True*, if you require the user's email address to complete the order
	NeedEmail *bool `json:"need_email,omitempty"`

	// *Optional*. Pass *True*, if you require the user's full name to complete the order
	NeedName *bool `json:"need_name,omitempty"`

	// *Optional*. Pass *True*, if you require the user's phone number to complete the order
	NeedPhoneNumber *bool `json:"need_phone_number,omitempty"`

	// *Optional*. Pass *True*, if you require the user's shipping address to complete the order
	NeedShippingAddress *bool `json:"need_shipping_address,omitempty"`

	// Bot-defined invoice payload, 1-128 bytes. This will not be displayed to the user, use for your internal processes.
	Payload string `json:"payload"`

	// *Optional*. Photo height
	PhotoHeight *int `json:"photo_height,omitempty"`

	// *Optional*. Photo size in bytes
	PhotoSize *int `json:"photo_size,omitempty"`

	// *Optional*. URL of the product photo for the invoice. Can be a photo of the goods or a marketing image for a service.
	PhotoUrl *string `json:"photo_url,omitempty"`

	// *Optional*. Photo width
	PhotoWidth *int `json:"photo_width,omitempty"`

	// Price breakdown, a JSON-serialized list of components (e.g. product price, tax, discount, delivery cost, delivery tax, bonus, etc.)
	Prices []LabeledPrice `json:"prices"`

	// *Optional*. A JSON-serialized object for data about the invoice, which will be shared with the payment provider. A detailed description of the required fields should be provided by the payment provider.
	ProviderData *string `json:"provider_data,omitempty"`

	// Payment provider token, obtained via [@BotFather](https://t.me/botfather)
	ProviderToken string `json:"provider_token"`

	// *Optional*. Pass *True*, if the user's email address should be sent to provider
	SendEmailToProvider *bool `json:"send_email_to_provider,omitempty"`

	// *Optional*. Pass *True*, if the user's phone number should be sent to provider
	SendPhoneNumberToProvider *bool `json:"send_phone_number_to_provider,omitempty"`

	// *Optional*. A JSON-serialized array of suggested amounts of tip in the *smallest units* of the currency (integer, **not** float/double). At most 4 suggested tip amounts can be specified. The suggested tip amounts must be positive, passed in a strictly increased order and must not exceed *max\_tip\_amount*.
	SuggestedTipAmounts *[]int `json:"suggested_tip_amounts,omitempty"`

	// Product name, 1-32 characters
	Title string `json:"title"`
}

// Represents the [content](https://core.telegram.org/bots/api/#inputmessagecontent) of a location message to be sent as the result of an inline query.
type InputLocationMessageContent struct {
	// *Optional*. For live locations, a direction in which the user is moving, in degrees. Must be between 1 and 360 if specified.
	Heading *int `json:"heading,omitempty"`

	// *Optional*. The radius of uncertainty for the location, measured in meters; 0-1500
	HorizontalAccuracy *float32 `json:"horizontal_accuracy,omitempty"`

	// Latitude of the location in degrees
	Latitude float32 `json:"latitude"`

	// *Optional*. Period in seconds for which the location can be updated, should be between 60 and 86400.
	LivePeriod *int `json:"live_period,omitempty"`

	// Longitude of the location in degrees
	Longitude float32 `json:"longitude"`

	// *Optional*. For live locations, a maximum distance for proximity alerts about approaching another chat member, in meters. Must be between 1 and 100000 if specified.
	ProximityAlertRadius *int `json:"proximity_alert_radius,omitempty"`
}

// This object represents the content of a media message to be sent. It should be one of
//
// * [InputMediaAnimation](https://core.telegram.org/bots/api/#inputmediaanimation)
// * [InputMediaDocument](https://core.telegram.org/bots/api/#inputmediadocument)
// * [InputMediaAudio](https://core.telegram.org/bots/api/#inputmediaaudio)
// * [InputMediaPhoto](https://core.telegram.org/bots/api/#inputmediaphoto)
// * [InputMediaVideo](https://core.telegram.org/bots/api/#inputmediavideo)
type InputMedia interface{}

// Represents an animation file (GIF or H.264/MPEG-4 AVC video without sound) to be sent.
type InputMediaAnimation struct {
	// *Optional*. Caption of the animation to be sent, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`

	// *Optional*. List of special entities that appear in the caption, which can be specified instead of *parse\_mode*
	CaptionEntities *[]MessageEntity `json:"caption_entities,omitempty"`

	// *Optional*. Animation duration in seconds
	Duration *int `json:"duration,omitempty"`

	// *Optional*. Animation height
	Height *int `json:"height,omitempty"`

	// File to send. Pass a file\_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass ‚Äúattach://<file\_attach\_name>‚Äù to upload a new one using multipart/form-data under <file\_attach\_name> name. [More information on Sending Files ¬ª](https://core.telegram.org/bots/api/#sending-files)
	Media string `json:"media"`

	// *Optional*. Mode for parsing entities in the animation caption. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
	ParseMode *string `json:"parse_mode,omitempty"`

	// *Optional*. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass ‚Äúattach://<file\_attach\_name>‚Äù if the thumbnail was uploaded using multipart/form-data under <file\_attach\_name>. [More information on Sending Files ¬ª](https://core.telegram.org/bots/api/#sending-files)
	Thumb *interface{} `json:"thumb,omitempty"`

	// Type of the result, must be *animation*
	Type string `json:"type"`

	// *Optional*. Animation width
	Width *int `json:"width,omitempty"`
}

// Represents an audio file to be treated as music to be sent.
type InputMediaAudio struct {
	// *Optional*. Caption of the audio to be sent, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`

	// *Optional*. List of special entities that appear in the caption, which can be specified instead of *parse\_mode*
	CaptionEntities *[]MessageEntity `json:"caption_entities,omitempty"`

	// *Optional*. Duration of the audio in seconds
	Duration *int `json:"duration,omitempty"`

	// File to send. Pass a file\_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass ‚Äúattach://<file\_attach\_name>‚Äù to upload a new one using multipart/form-data under <file\_attach\_name> name. [More information on Sending Files ¬ª](https://core.telegram.org/bots/api/#sending-files)
	Media string `json:"media"`

	// *Optional*. Mode for parsing entities in the audio caption. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
	ParseMode *string `json:"parse_mode,omitempty"`

	// *Optional*. Performer of the audio
	Performer *string `json:"performer,omitempty"`

	// *Optional*. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass ‚Äúattach://<file\_attach\_name>‚Äù if the thumbnail was uploaded using multipart/form-data under <file\_attach\_name>. [More information on Sending Files ¬ª](https://core.telegram.org/bots/api/#sending-files)
	Thumb *interface{} `json:"thumb,omitempty"`

	// *Optional*. Title of the audio
	Title *string `json:"title,omitempty"`

	// Type of the result, must be *audio*
	Type string `json:"type"`
}

// Represents a general file to be sent.
type InputMediaDocument struct {
	// *Optional*. Caption of the document to be sent, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`

	// *Optional*. List of special entities that appear in the caption, which can be specified instead of *parse\_mode*
	CaptionEntities *[]MessageEntity `json:"caption_entities,omitempty"`

	// *Optional*. Disables automatic server-side content type detection for files uploaded using multipart/form-data. Always *True*, if the document is sent as part of an album.
	DisableContentTypeDetection *bool `json:"disable_content_type_detection,omitempty"`

	// File to send. Pass a file\_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass ‚Äúattach://<file\_attach\_name>‚Äù to upload a new one using multipart/form-data under <file\_attach\_name> name. [More information on Sending Files ¬ª](https://core.telegram.org/bots/api/#sending-files)
	Media string `json:"media"`

	// *Optional*. Mode for parsing entities in the document caption. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
	ParseMode *string `json:"parse_mode,omitempty"`

	// *Optional*. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass ‚Äúattach://<file\_attach\_name>‚Äù if the thumbnail was uploaded using multipart/form-data under <file\_attach\_name>. [More information on Sending Files ¬ª](https://core.telegram.org/bots/api/#sending-files)
	Thumb *interface{} `json:"thumb,omitempty"`

	// Type of the result, must be *document*
	Type string `json:"type"`
}

// Represents a photo to be sent.
type InputMediaPhoto struct {
	// *Optional*. Caption of the photo to be sent, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`

	// *Optional*. List of special entities that appear in the caption, which can be specified instead of *parse\_mode*
	CaptionEntities *[]MessageEntity `json:"caption_entities,omitempty"`

	// File to send. Pass a file\_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass ‚Äúattach://<file\_attach\_name>‚Äù to upload a new one using multipart/form-data under <file\_attach\_name> name. [More information on Sending Files ¬ª](https://core.telegram.org/bots/api/#sending-files)
	Media string `json:"media"`

	// *Optional*. Mode for parsing entities in the photo caption. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
	ParseMode *string `json:"parse_mode,omitempty"`

	// Type of the result, must be *photo*
	Type string `json:"type"`
}

// Represents a video to be sent.
type InputMediaVideo struct {
	// *Optional*. Caption of the video to be sent, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`

	// *Optional*. List of special entities that appear in the caption, which can be specified instead of *parse\_mode*
	CaptionEntities *[]MessageEntity `json:"caption_entities,omitempty"`

	// *Optional*. Video duration in seconds
	Duration *int `json:"duration,omitempty"`

	// *Optional*. Video height
	Height *int `json:"height,omitempty"`

	// File to send. Pass a file\_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass ‚Äúattach://<file\_attach\_name>‚Äù to upload a new one using multipart/form-data under <file\_attach\_name> name. [More information on Sending Files ¬ª](https://core.telegram.org/bots/api/#sending-files)
	Media string `json:"media"`

	// *Optional*. Mode for parsing entities in the video caption. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
	ParseMode *string `json:"parse_mode,omitempty"`

	// *Optional*. Pass *True*, if the uploaded video is suitable for streaming
	SupportsStreaming *bool `json:"supports_streaming,omitempty"`

	// *Optional*. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass ‚Äúattach://<file\_attach\_name>‚Äù if the thumbnail was uploaded using multipart/form-data under <file\_attach\_name>. [More information on Sending Files ¬ª](https://core.telegram.org/bots/api/#sending-files)
	Thumb *interface{} `json:"thumb,omitempty"`

	// Type of the result, must be *video*
	Type string `json:"type"`

	// *Optional*. Video width
	Width *int `json:"width,omitempty"`
}

// This object represents the content of a message to be sent as a result of an inline query. Telegram clients currently support the following 5 types:
//
// * [InputTextMessageContent](https://core.telegram.org/bots/api/#inputtextmessagecontent)
// * [InputLocationMessageContent](https://core.telegram.org/bots/api/#inputlocationmessagecontent)
// * [InputVenueMessageContent](https://core.telegram.org/bots/api/#inputvenuemessagecontent)
// * [InputContactMessageContent](https://core.telegram.org/bots/api/#inputcontactmessagecontent)
// * [InputInvoiceMessageContent](https://core.telegram.org/bots/api/#inputinvoicemessagecontent)
type InputMessageContent interface{}

// Represents the [content](https://core.telegram.org/bots/api/#inputmessagecontent) of a text message to be sent as the result of an inline query.
type InputTextMessageContent struct {
	// *Optional*. Disables link previews for links in the sent message
	DisableWebPagePreview *bool `json:"disable_web_page_preview,omitempty"`

	// *Optional*. List of special entities that appear in message text, which can be specified instead of *parse\_mode*
	Entities *[]MessageEntity `json:"entities,omitempty"`

	// Text of the message to be sent, 1-4096 characters
	MessageText string `json:"message_text"`

	// *Optional*. Mode for parsing entities in the message text. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
	ParseMode *string `json:"parse_mode,omitempty"`
}

// Represents the [content](https://core.telegram.org/bots/api/#inputmessagecontent) of a venue message to be sent as the result of an inline query.
type InputVenueMessageContent struct {
	// Address of the venue
	Address string `json:"address"`

	// *Optional*. Foursquare identifier of the venue, if known
	FoursquareId *string `json:"foursquare_id,omitempty"`

	// *Optional*. Foursquare type of the venue, if known. (For example, ‚Äúarts\_entertainment/default‚Äù, ‚Äúarts\_entertainment/aquarium‚Äù or ‚Äúfood/icecream‚Äù.)
	FoursquareType *string `json:"foursquare_type,omitempty"`

	// *Optional*. Google Places identifier of the venue
	GooglePlaceId *string `json:"google_place_id,omitempty"`

	// *Optional*. Google Places type of the venue. (See [supported types](https://developers.google.com/places/web-service/supported_types).)
	GooglePlaceType *string `json:"google_place_type,omitempty"`

	// Latitude of the venue in degrees
	Latitude float32 `json:"latitude"`

	// Longitude of the venue in degrees
	Longitude float32 `json:"longitude"`

	// Name of the venue
	Title string `json:"title"`
}

// This object contains basic information about an invoice.
type Invoice struct {
	// Three-letter ISO 4217 [currency](https://core.telegram.org/bots/payments#supported-currencies) code
	Currency string `json:"currency"`

	// Product description
	Description string `json:"description"`

	// Unique bot deep-linking parameter that can be used to generate this invoice
	StartParameter string `json:"start_parameter"`

	// Product name
	Title string `json:"title"`

	// Total price in the *smallest units* of the currency (integer, **not** float/double). For example, for a price of `US$ 1.45` pass `amount = 145`. See the *exp* parameter in [currencies.json](https://core.telegram.org/bots/payments/currencies.json), it shows the number of digits past the decimal point for each currency (2 for the majority of currencies).
	TotalAmount int `json:"total_amount"`
}

// This object represents one button of the reply keyboard. For simple text buttons *String* can be used instead of this object to specify text of the button. Optional fields *web\_app*, *request\_contact*, *request\_location*, and *request\_poll* are mutually exclusive.
type KeyboardButton struct {
	// *Optional*. If *True*, the user's phone number will be sent as a contact when the button is pressed. Available in private chats only.
	RequestContact *bool `json:"request_contact,omitempty"`

	// *Optional*. If *True*, the user's current location will be sent when the button is pressed. Available in private chats only.
	RequestLocation *bool `json:"request_location,omitempty"`

	// This object represents type of a poll, which is allowed to be created and sent when the corresponding button is pressed.
	RequestPoll *KeyboardButtonPollType `json:"request_poll,omitempty"`

	// Text of the button. If none of the optional fields are used, it will be sent as a message when the button is pressed
	Text string `json:"text"`

	// Describes a [Web App](https://core.telegram.org/bots/webapps).
	WebApp *WebAppInfo `json:"web_app,omitempty"`
}

// This object represents type of a poll, which is allowed to be created and sent when the corresponding button is pressed.
type KeyboardButtonPollType struct {
	// *Optional*. If *quiz* is passed, the user will be allowed to create only polls in the quiz mode. If *regular* is passed, only regular polls will be allowed. Otherwise, the user will be allowed to create a poll of any type.
	Type *string `json:"type,omitempty"`
}

// This object represents a portion of the price for goods or services.
type LabeledPrice struct {
	// Price of the product in the *smallest units* of the [currency](https://core.telegram.org/bots/payments#supported-currencies) (integer, **not** float/double). For example, for a price of `US$ 1.45` pass `amount = 145`. See the *exp* parameter in [currencies.json](https://core.telegram.org/bots/payments/currencies.json), it shows the number of digits past the decimal point for each currency (2 for the majority of currencies).
	Amount int `json:"amount"`

	// Portion label
	Label string `json:"label"`
}

// This object represents a point on the map.
type Location struct {
	// *Optional*. The direction in which user is moving, in degrees; 1-360. For active live locations only.
	Heading *int `json:"heading,omitempty"`

	// *Optional*. The radius of uncertainty for the location, measured in meters; 0-1500
	HorizontalAccuracy *float32 `json:"horizontal_accuracy,omitempty"`

	// Latitude as defined by sender
	Latitude float32 `json:"latitude"`

	// *Optional*. Time relative to the message sending date, during which the location can be updated; in seconds. For active live locations only.
	LivePeriod *int `json:"live_period,omitempty"`

	// Longitude as defined by sender
	Longitude float32 `json:"longitude"`

	// *Optional*. The maximum distance for proximity alerts about approaching another chat member, in meters. For sent live locations only.
	ProximityAlertRadius *int `json:"proximity_alert_radius,omitempty"`
}

// This object represents a parameter of the inline keyboard button used to automatically authorize a user. Serves as a great replacement for the [Telegram Login Widget](https://core.telegram.org/widgets/login) when the user is coming from Telegram. All the user needs to do is tap/click a button and confirm that they want to log in:
//
// Telegram apps support these buttons as of [version 5.7](https://telegram.org/blog/privacy-discussions-web-bots#meet-seamless-web-bots).
//
// Sample bot: [@discussbot](https://t.me/discussbot)
type LoginUrl struct {
	// *Optional*. Username of a bot, which will be used for user authorization. See [Setting up a bot](https://core.telegram.org/widgets/login#setting-up-a-bot) for more details. If not specified, the current bot's username will be assumed. The *url*'s domain must be the same as the domain linked with the bot. See [Linking your domain to the bot](https://core.telegram.org/widgets/login#linking-your-domain-to-the-bot) for more details.
	BotUsername *string `json:"bot_username,omitempty"`

	// *Optional*. New text of the button in forwarded messages.
	ForwardText *string `json:"forward_text,omitempty"`

	// *Optional*. Pass *True* to request the permission for your bot to send messages to the user.
	RequestWriteAccess *bool `json:"request_write_access,omitempty"`

	// An HTTPS URL to be opened with user authorization data added to the query string when the button is pressed. If the user refuses to provide authorization data, the original URL without information about the user will be opened. The data added is the same as described in [Receiving authorization data](https://core.telegram.org/widgets/login#receiving-authorization-data).
	//
	// **NOTE:** You **must** always check the hash of the received data to verify the authentication and the integrity of the data as described in [Checking authorization](https://core.telegram.org/widgets/login#checking-authorization).
	Url string `json:"url"`
}

// This object describes the position on faces where a mask should be placed by default.
type MaskPosition struct {
	// The part of the face relative to which the mask should be placed. One of ‚Äúforehead‚Äù, ‚Äúeyes‚Äù, ‚Äúmouth‚Äù, or ‚Äúchin‚Äù.
	Point MaskPositionPoint `json:"point"`

	// Mask scaling coefficient. For example, 2.0 means double size.
	Scale float32 `json:"scale"`

	// Shift by X-axis measured in widths of the mask scaled to the face size, from left to right. For example, choosing -1.0 will place mask just to the left of the default mask position.
	XShift float32 `json:"x_shift"`

	// Shift by Y-axis measured in heights of the mask scaled to the face size, from top to bottom. For example, 1.0 will place the mask just below the default mask position.
	YShift float32 `json:"y_shift"`
}

// The part of the face relative to which the mask should be placed. One of ‚Äúforehead‚Äù, ‚Äúeyes‚Äù, ‚Äúmouth‚Äù, or ‚Äúchin‚Äù.
type MaskPositionPoint string

// This object describes the bot's menu button in a private chat. It should be one of
//
// * [MenuButtonCommands](https://core.telegram.org/bots/api/#menubuttoncommands)
// * [MenuButtonWebApp](https://core.telegram.org/bots/api/#menubuttonwebapp)
// * [MenuButtonDefault](https://core.telegram.org/bots/api/#menubuttondefault)
type MenuButton interface{}

// Represents a menu button, which opens the bot's list of commands.
type MenuButtonCommands struct {
	// Type of the button, must be *commands*
	Type string `json:"type"`
}

// Describes that no specific value for the menu button was set.
type MenuButtonDefault struct {
	// Type of the button, must be *default*
	Type string `json:"type"`
}

// Represents a menu button, which launches a [Web App](https://core.telegram.org/bots/webapps).
type MenuButtonWebApp struct {
	// Text on the button
	Text string `json:"text"`

	// Type of the button, must be *web\_app*
	Type string `json:"type"`

	// Describes a [Web App](https://core.telegram.org/bots/webapps).
	WebApp WebAppInfo `json:"web_app"`
}

// This object represents a message.
type Message struct {
	// This object represents an animation file (GIF or H.264/MPEG-4 AVC video without sound).
	Animation *Animation `json:"animation,omitempty"`

	// This object represents an audio file to be treated as music by the Telegram clients.
	Audio *Audio `json:"audio,omitempty"`

	// *Optional*. Signature of the post author for messages in channels, or the custom title of an anonymous group administrator
	AuthorSignature *string `json:"author_signature,omitempty"`

	// *Optional*. Caption for the animation, audio, document, photo, video or voice
	Caption *string `json:"caption,omitempty"`

	// *Optional*. For messages with a caption, special entities like usernames, URLs, bot commands, etc. that appear in the caption
	CaptionEntities *[]MessageEntity `json:"caption_entities,omitempty"`

	// *Optional*. Service message: the channel has been created. This field can't be received in a message coming through updates, because bot can't be a member of a channel when it is created. It can only be found in reply\_to\_message if someone replies to a very first message in a channel.
	ChannelChatCreated *bool `json:"channel_chat_created,omitempty"`

	// This object represents a chat.
	Chat Chat `json:"chat"`

	// *Optional*. The domain name of the website on which the user has logged in. [More about Telegram Login ¬ª](https://core.telegram.org/widgets/login)
	ConnectedWebsite *string `json:"connected_website,omitempty"`

	// This object represents a phone contact.
	Contact *Contact `json:"contact,omitempty"`

	// Date the message was sent in Unix time
	Date int `json:"date"`

	// *Optional*. Service message: the chat photo was deleted
	DeleteChatPhoto *bool `json:"delete_chat_photo,omitempty"`

	// This object represents an animated emoji that displays a random value.
	Dice *Dice `json:"dice,omitempty"`

	// This object represents a general file (as opposed to [photos](https://core.telegram.org/bots/api/#photosize), [voice messages](https://core.telegram.org/bots/api/#voice) and [audio files](https://core.telegram.org/bots/api/#audio)).
	Document *Document `json:"document,omitempty"`

	// *Optional*. Date the message was last edited in Unix time
	EditDate *int `json:"edit_date,omitempty"`

	// *Optional*. For text messages, special entities like usernames, URLs, bot commands, etc. that appear in the text
	Entities *[]MessageEntity `json:"entities,omitempty"`

	// *Optional*. For forwarded messages, date the original message was sent in Unix time
	ForwardDate *int `json:"forward_date,omitempty"`

	// This object represents a Telegram user or bot.
	ForwardFrom *User `json:"forward_from,omitempty"`

	// This object represents a chat.
	ForwardFromChat *Chat `json:"forward_from_chat,omitempty"`

	// *Optional*. For messages forwarded from channels, identifier of the original message in the channel
	ForwardFromMessageId *int `json:"forward_from_message_id,omitempty"`

	// *Optional*. Sender's name for messages forwarded from users who disallow adding a link to their account in forwarded messages
	ForwardSenderName *string `json:"forward_sender_name,omitempty"`

	// *Optional*. For forwarded messages that were originally sent in channels or by an anonymous chat administrator, signature of the message sender if present
	ForwardSignature *string `json:"forward_signature,omitempty"`

	// This object represents a Telegram user or bot.
	From *User `json:"from,omitempty"`

	// This object represents a game. Use BotFather to create and edit games, their short names will act as unique identifiers.
	Game *Game `json:"game,omitempty"`

	// *Optional*. Service message: the group has been created
	GroupChatCreated *bool `json:"group_chat_created,omitempty"`

	// *Optional*. *True*, if the message can't be forwarded
	HasProtectedContent *bool `json:"has_protected_content,omitempty"`

	// This object contains basic information about an invoice.
	Invoice *Invoice `json:"invoice,omitempty"`

	// *Optional*. *True*, if the message is a channel post that was automatically forwarded to the connected discussion group
	IsAutomaticForward *bool `json:"is_automatic_forward,omitempty"`

	// This object represents a Telegram user or bot.
	LeftChatMember *User `json:"left_chat_member,omitempty"`

	// This object represents a point on the map.
	Location *Location `json:"location,omitempty"`

	// *Optional*. The unique identifier of a media message group this message belongs to
	MediaGroupId *string `json:"media_group_id,omitempty"`

	// This object represents a service message about a change in auto-delete timer settings.
	MessageAutoDeleteTimerChanged *MessageAutoDeleteTimerChanged `json:"message_auto_delete_timer_changed,omitempty"`

	// Unique message identifier inside this chat
	MessageId int `json:"message_id"`

	// *Optional*. The supergroup has been migrated from a group with the specified identifier. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier.
	MigrateFromChatId *int `json:"migrate_from_chat_id,omitempty"`

	// *Optional*. The group has been migrated to a supergroup with the specified identifier. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier.
	MigrateToChatId *int `json:"migrate_to_chat_id,omitempty"`

	// *Optional*. New members that were added to the group or supergroup and information about them (the bot itself may be one of these members)
	NewChatMembers *[]User `json:"new_chat_members,omitempty"`

	// *Optional*. A chat photo was change to this value
	NewChatPhoto *[]PhotoSize `json:"new_chat_photo,omitempty"`

	// *Optional*. A chat title was changed to this value
	NewChatTitle *string `json:"new_chat_title,omitempty"`

	// Describes Telegram Passport data shared with the bot by the user.
	PassportData *PassportData `json:"passport_data,omitempty"`

	// *Optional*. Message is a photo, available sizes of the photo
	Photo *[]PhotoSize `json:"photo,omitempty"`

	// This object represents a message.
	PinnedMessage *Message `json:"pinned_message,omitempty"`

	// This object contains information about a poll.
	Poll *Poll `json:"poll,omitempty"`

	// This object represents the content of a service message, sent whenever a user in the chat triggers a proximity alert set by another user.
	ProximityAlertTriggered *ProximityAlertTriggered `json:"proximity_alert_triggered,omitempty"`

	// This object represents an [inline keyboard](https://core.telegram.org/bots#inline-keyboards-and-on-the-fly-updating) that appears right next to the message it belongs to.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`

	// This object represents a message.
	ReplyToMessage *Message `json:"reply_to_message,omitempty"`

	// This object represents a chat.
	SenderChat *Chat `json:"sender_chat,omitempty"`

	// This object represents a sticker.
	Sticker *Sticker `json:"sticker,omitempty"`

	// This object contains basic information about a successful payment.
	SuccessfulPayment *SuccessfulPayment `json:"successful_payment,omitempty"`

	// *Optional*. Service message: the supergroup has been created. This field can't be received in a message coming through updates, because bot can't be a member of a supergroup when it is created. It can only be found in reply\_to\_message if someone replies to a very first message in a directly created supergroup.
	SupergroupChatCreated *bool `json:"supergroup_chat_created,omitempty"`

	// *Optional*. For text messages, the actual UTF-8 text of the message
	Text *string `json:"text,omitempty"`

	// This object represents a venue.
	Venue *Venue `json:"venue,omitempty"`

	// This object represents a Telegram user or bot.
	ViaBot *User `json:"via_bot,omitempty"`

	// This object represents a video file.
	Video *Video `json:"video,omitempty"`

	// This object represents a service message about a video chat ended in the chat.
	VideoChatEnded *VideoChatEnded `json:"video_chat_ended,omitempty"`

	// This object represents a service message about new members invited to a video chat.
	VideoChatParticipantsInvited *VideoChatParticipantsInvited `json:"video_chat_participants_invited,omitempty"`

	// This object represents a service message about a video chat scheduled in the chat.
	VideoChatScheduled *VideoChatScheduled `json:"video_chat_scheduled,omitempty"`

	// This object represents a service message about a video chat started in the chat. Currently holds no information.
	VideoChatStarted *VideoChatStarted `json:"video_chat_started,omitempty"`

	// This object represents a [video message](https://telegram.org/blog/video-messages-and-telescope) (available in Telegram apps as of [v.4.0](https://telegram.org/blog/video-messages-and-telescope)).
	VideoNote *VideoNote `json:"video_note,omitempty"`

	// This object represents a voice note.
	Voice *Voice `json:"voice,omitempty"`

	// Describes data sent from a [Web App](https://core.telegram.org/bots/webapps) to the bot.
	WebAppData *WebAppData `json:"web_app_data,omitempty"`
}

// This object represents a service message about a change in auto-delete timer settings.
type MessageAutoDeleteTimerChanged struct {
	// New auto-delete time for messages in the chat; in seconds
	MessageAutoDeleteTime int `json:"message_auto_delete_time"`
}

// This object represents one special entity in a text message. For example, hashtags, usernames, URLs, etc.
type MessageEntity struct {
	// *Optional*. For ‚Äúpre‚Äù only, the programming language of the entity text
	Language *string `json:"language,omitempty"`

	// Length of the entity in UTF-16 code units
	Length int `json:"length"`

	// Offset in UTF-16 code units to the start of the entity
	Offset int `json:"offset"`

	// Type of the entity. Currently, can be ‚Äúmention‚Äù (`@username`), ‚Äúhashtag‚Äù (`#hashtag`), ‚Äúcashtag‚Äù (`$USD`), ‚Äúbot\_command‚Äù (`/start@jobs_bot`), ‚Äúurl‚Äù (`https://telegram.org`), ‚Äúemail‚Äù (`do-not-reply@telegram.org`), ‚Äúphone\_number‚Äù (`+1-212-555-0123`), ‚Äúbold‚Äù (**bold text**), ‚Äúitalic‚Äù (*italic text*), ‚Äúunderline‚Äù (underlined text), ‚Äústrikethrough‚Äù (strikethrough text), ‚Äúspoiler‚Äù (spoiler message), ‚Äúcode‚Äù (monowidth string), ‚Äúpre‚Äù (monowidth block), ‚Äútext\_link‚Äù (for clickable text URLs), ‚Äútext\_mention‚Äù (for users [without usernames](https://telegram.org/blog/edit#new-mentions))
	Type MessageEntityType `json:"type"`

	// *Optional*. For ‚Äútext\_link‚Äù only, URL that will be opened after user taps on the text
	Url *string `json:"url,omitempty"`

	// This object represents a Telegram user or bot.
	User *User `json:"user,omitempty"`
}

// Type of the entity. Currently, can be ‚Äúmention‚Äù (`@username`), ‚Äúhashtag‚Äù (`#hashtag`), ‚Äúcashtag‚Äù (`$USD`), ‚Äúbot\_command‚Äù (`/start@jobs_bot`), ‚Äúurl‚Äù (`https://telegram.org`), ‚Äúemail‚Äù (`do-not-reply@telegram.org`), ‚Äúphone\_number‚Äù (`+1-212-555-0123`), ‚Äúbold‚Äù (**bold text**), ‚Äúitalic‚Äù (*italic text*), ‚Äúunderline‚Äù (underlined text), ‚Äústrikethrough‚Äù (strikethrough text), ‚Äúspoiler‚Äù (spoiler message), ‚Äúcode‚Äù (monowidth string), ‚Äúpre‚Äù (monowidth block), ‚Äútext\_link‚Äù (for clickable text URLs), ‚Äútext\_mention‚Äù (for users [without usernames](https://telegram.org/blog/edit#new-mentions))
type MessageEntityType string

// This object represents a unique message identifier.
type MessageId struct {
	// Unique message identifier
	MessageId int `json:"message_id"`
}

// This object represents information about an order.
type OrderInfo struct {
	// *Optional*. User email
	Email *string `json:"email,omitempty"`

	// *Optional*. User name
	Name *string `json:"name,omitempty"`

	// *Optional*. User's phone number
	PhoneNumber *string `json:"phone_number,omitempty"`

	// This object represents a shipping address.
	ShippingAddress *ShippingAddress `json:"shipping_address,omitempty"`
}

// Describes Telegram Passport data shared with the bot by the user.
type PassportData struct {
	// Describes data required for decrypting and authenticating [EncryptedPassportElement](https://core.telegram.org/bots/api/#encryptedpassportelement). See the [Telegram Passport Documentation](https://core.telegram.org/passport#receiving-information) for a complete description of the data decryption and authentication processes.
	Credentials EncryptedCredentials `json:"credentials"`

	// Array with information about documents and other Telegram Passport elements that was shared with the bot
	Data []EncryptedPassportElement `json:"data"`
}

// This object represents an error in the Telegram Passport element which was submitted that should be resolved by the user. It should be one of:
//
// * [PassportElementErrorDataField](https://core.telegram.org/bots/api/#passportelementerrordatafield)
// * [PassportElementErrorFrontSide](https://core.telegram.org/bots/api/#passportelementerrorfrontside)
// * [PassportElementErrorReverseSide](https://core.telegram.org/bots/api/#passportelementerrorreverseside)
// * [PassportElementErrorSelfie](https://core.telegram.org/bots/api/#passportelementerrorselfie)
// * [PassportElementErrorFile](https://core.telegram.org/bots/api/#passportelementerrorfile)
// * [PassportElementErrorFiles](https://core.telegram.org/bots/api/#passportelementerrorfiles)
// * [PassportElementErrorTranslationFile](https://core.telegram.org/bots/api/#passportelementerrortranslationfile)
// * [PassportElementErrorTranslationFiles](https://core.telegram.org/bots/api/#passportelementerrortranslationfiles)
// * [PassportElementErrorUnspecified](https://core.telegram.org/bots/api/#passportelementerrorunspecified)
type PassportElementError interface{}

// Represents an issue in one of the data fields that was provided by the user. The error is considered resolved when the field's value changes.
type PassportElementErrorDataField struct {
	// Base64-encoded data hash
	DataHash string `json:"data_hash"`

	// Name of the data field which has the error
	FieldName string `json:"field_name"`

	// Error message
	Message string `json:"message"`

	// Error source, must be *data*
	Source string `json:"source"`

	// The section of the user's Telegram Passport which has the error, one of ‚Äúpersonal\_details‚Äù, ‚Äúpassport‚Äù, ‚Äúdriver\_license‚Äù, ‚Äúidentity\_card‚Äù, ‚Äúinternal\_passport‚Äù, ‚Äúaddress‚Äù
	Type PassportElementErrorDataFieldType `json:"type"`
}

// The section of the user's Telegram Passport which has the error, one of ‚Äúpersonal\_details‚Äù, ‚Äúpassport‚Äù, ‚Äúdriver\_license‚Äù, ‚Äúidentity\_card‚Äù, ‚Äúinternal\_passport‚Äù, ‚Äúaddress‚Äù
type PassportElementErrorDataFieldType string

// Represents an issue with a document scan. The error is considered resolved when the file with the document scan changes.
type PassportElementErrorFile struct {
	// Base64-encoded file hash
	FileHash string `json:"file_hash"`

	// Error message
	Message string `json:"message"`

	// Error source, must be *file*
	Source string `json:"source"`

	// The section of the user's Telegram Passport which has the issue, one of ‚Äúutility\_bill‚Äù, ‚Äúbank\_statement‚Äù, ‚Äúrental\_agreement‚Äù, ‚Äúpassport\_registration‚Äù, ‚Äútemporary\_registration‚Äù
	Type PassportElementErrorFileType `json:"type"`
}

// The section of the user's Telegram Passport which has the issue, one of ‚Äúutility\_bill‚Äù, ‚Äúbank\_statement‚Äù, ‚Äúrental\_agreement‚Äù, ‚Äúpassport\_registration‚Äù, ‚Äútemporary\_registration‚Äù
type PassportElementErrorFileType string

// Represents an issue with a list of scans. The error is considered resolved when the list of files containing the scans changes.
type PassportElementErrorFiles struct {
	// List of base64-encoded file hashes
	FileHashes []string `json:"file_hashes"`

	// Error message
	Message string `json:"message"`

	// Error source, must be *files*
	Source string `json:"source"`

	// The section of the user's Telegram Passport which has the issue, one of ‚Äúutility\_bill‚Äù, ‚Äúbank\_statement‚Äù, ‚Äúrental\_agreement‚Äù, ‚Äúpassport\_registration‚Äù, ‚Äútemporary\_registration‚Äù
	Type PassportElementErrorFilesType `json:"type"`
}

// The section of the user's Telegram Passport which has the issue, one of ‚Äúutility\_bill‚Äù, ‚Äúbank\_statement‚Äù, ‚Äúrental\_agreement‚Äù, ‚Äúpassport\_registration‚Äù, ‚Äútemporary\_registration‚Äù
type PassportElementErrorFilesType string

// Represents an issue with the front side of a document. The error is considered resolved when the file with the front side of the document changes.
type PassportElementErrorFrontSide struct {
	// Base64-encoded hash of the file with the front side of the document
	FileHash string `json:"file_hash"`

	// Error message
	Message string `json:"message"`

	// Error source, must be *front\_side*
	Source string `json:"source"`

	// The section of the user's Telegram Passport which has the issue, one of ‚Äúpassport‚Äù, ‚Äúdriver\_license‚Äù, ‚Äúidentity\_card‚Äù, ‚Äúinternal\_passport‚Äù
	Type PassportElementErrorFrontSideType `json:"type"`
}

// The section of the user's Telegram Passport which has the issue, one of ‚Äúpassport‚Äù, ‚Äúdriver\_license‚Äù, ‚Äúidentity\_card‚Äù, ‚Äúinternal\_passport‚Äù
type PassportElementErrorFrontSideType string

// Represents an issue with the reverse side of a document. The error is considered resolved when the file with reverse side of the document changes.
type PassportElementErrorReverseSide struct {
	// Base64-encoded hash of the file with the reverse side of the document
	FileHash string `json:"file_hash"`

	// Error message
	Message string `json:"message"`

	// Error source, must be *reverse\_side*
	Source string `json:"source"`

	// The section of the user's Telegram Passport which has the issue, one of ‚Äúdriver\_license‚Äù, ‚Äúidentity\_card‚Äù
	Type PassportElementErrorReverseSideType `json:"type"`
}

// The section of the user's Telegram Passport which has the issue, one of ‚Äúdriver\_license‚Äù, ‚Äúidentity\_card‚Äù
type PassportElementErrorReverseSideType string

// Represents an issue with the selfie with a document. The error is considered resolved when the file with the selfie changes.
type PassportElementErrorSelfie struct {
	// Base64-encoded hash of the file with the selfie
	FileHash string `json:"file_hash"`

	// Error message
	Message string `json:"message"`

	// Error source, must be *selfie*
	Source string `json:"source"`

	// The section of the user's Telegram Passport which has the issue, one of ‚Äúpassport‚Äù, ‚Äúdriver\_license‚Äù, ‚Äúidentity\_card‚Äù, ‚Äúinternal\_passport‚Äù
	Type PassportElementErrorSelfieType `json:"type"`
}

// The section of the user's Telegram Passport which has the issue, one of ‚Äúpassport‚Äù, ‚Äúdriver\_license‚Äù, ‚Äúidentity\_card‚Äù, ‚Äúinternal\_passport‚Äù
type PassportElementErrorSelfieType string

// Represents an issue with one of the files that constitute the translation of a document. The error is considered resolved when the file changes.
type PassportElementErrorTranslationFile struct {
	// Base64-encoded file hash
	FileHash string `json:"file_hash"`

	// Error message
	Message string `json:"message"`

	// Error source, must be *translation\_file*
	Source string `json:"source"`

	// Type of element of the user's Telegram Passport which has the issue, one of ‚Äúpassport‚Äù, ‚Äúdriver\_license‚Äù, ‚Äúidentity\_card‚Äù, ‚Äúinternal\_passport‚Äù, ‚Äúutility\_bill‚Äù, ‚Äúbank\_statement‚Äù, ‚Äúrental\_agreement‚Äù, ‚Äúpassport\_registration‚Äù, ‚Äútemporary\_registration‚Äù
	Type PassportElementErrorTranslationFileType `json:"type"`
}

// Type of element of the user's Telegram Passport which has the issue, one of ‚Äúpassport‚Äù, ‚Äúdriver\_license‚Äù, ‚Äúidentity\_card‚Äù, ‚Äúinternal\_passport‚Äù, ‚Äúutility\_bill‚Äù, ‚Äúbank\_statement‚Äù, ‚Äúrental\_agreement‚Äù, ‚Äúpassport\_registration‚Äù, ‚Äútemporary\_registration‚Äù
type PassportElementErrorTranslationFileType string

// Represents an issue with the translated version of a document. The error is considered resolved when a file with the document translation change.
type PassportElementErrorTranslationFiles struct {
	// List of base64-encoded file hashes
	FileHashes []string `json:"file_hashes"`

	// Error message
	Message string `json:"message"`

	// Error source, must be *translation\_files*
	Source string `json:"source"`

	// Type of element of the user's Telegram Passport which has the issue, one of ‚Äúpassport‚Äù, ‚Äúdriver\_license‚Äù, ‚Äúidentity\_card‚Äù, ‚Äúinternal\_passport‚Äù, ‚Äúutility\_bill‚Äù, ‚Äúbank\_statement‚Äù, ‚Äúrental\_agreement‚Äù, ‚Äúpassport\_registration‚Äù, ‚Äútemporary\_registration‚Äù
	Type PassportElementErrorTranslationFilesType `json:"type"`
}

// Type of element of the user's Telegram Passport which has the issue, one of ‚Äúpassport‚Äù, ‚Äúdriver\_license‚Äù, ‚Äúidentity\_card‚Äù, ‚Äúinternal\_passport‚Äù, ‚Äúutility\_bill‚Äù, ‚Äúbank\_statement‚Äù, ‚Äúrental\_agreement‚Äù, ‚Äúpassport\_registration‚Äù, ‚Äútemporary\_registration‚Äù
type PassportElementErrorTranslationFilesType string

// Represents an issue in an unspecified place. The error is considered resolved when new data is added.
type PassportElementErrorUnspecified struct {
	// Base64-encoded element hash
	ElementHash string `json:"element_hash"`

	// Error message
	Message string `json:"message"`

	// Error source, must be *unspecified*
	Source string `json:"source"`

	// Type of element of the user's Telegram Passport which has the issue
	Type string `json:"type"`
}

// This object represents a file uploaded to Telegram Passport. Currently all Telegram Passport files are in JPEG format when decrypted and don't exceed 10MB.
type PassportFile struct {
	// Unix time when the file was uploaded
	FileDate int `json:"file_date"`

	// Identifier for this file, which can be used to download or reuse the file
	FileId string `json:"file_id"`

	// File size in bytes
	FileSize int `json:"file_size"`

	// Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file.
	FileUniqueId string `json:"file_unique_id"`
}

// This object represents one size of a photo or a [file](https://core.telegram.org/bots/api/#document) / [sticker](https://core.telegram.org/bots/api/#sticker) thumbnail.
type PhotoSize struct {
	// Identifier for this file, which can be used to download or reuse the file
	FileId string `json:"file_id"`

	// *Optional*. File size in bytes
	FileSize *int `json:"file_size,omitempty"`

	// Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file.
	FileUniqueId string `json:"file_unique_id"`

	// Photo height
	Height int `json:"height"`

	// Photo width
	Width int `json:"width"`
}

// This object contains information about a poll.
type Poll struct {
	// *True*, if the poll allows multiple answers
	AllowsMultipleAnswers bool `json:"allows_multiple_answers"`

	// *Optional*. Point in time (Unix timestamp) when the poll will be automatically closed
	CloseDate *int `json:"close_date,omitempty"`

	// *Optional*. 0-based identifier of the correct answer option. Available only for polls in the quiz mode, which are closed, or was sent (not forwarded) by the bot or to the private chat with the bot.
	CorrectOptionId *int `json:"correct_option_id,omitempty"`

	// *Optional*. Text that is shown when a user chooses an incorrect answer or taps on the lamp icon in a quiz-style poll, 0-200 characters
	Explanation *string `json:"explanation,omitempty"`

	// *Optional*. Special entities like usernames, URLs, bot commands, etc. that appear in the *explanation*
	ExplanationEntities *[]MessageEntity `json:"explanation_entities,omitempty"`

	// Unique poll identifier
	Id string `json:"id"`

	// *True*, if the poll is anonymous
	IsAnonymous bool `json:"is_anonymous"`

	// *True*, if the poll is closed
	IsClosed bool `json:"is_closed"`

	// *Optional*. Amount of time in seconds the poll will be active after creation
	OpenPeriod *int `json:"open_period,omitempty"`

	// List of poll options
	Options []PollOption `json:"options"`

	// Poll question, 1-300 characters
	Question string `json:"question"`

	// Total number of users that voted in the poll
	TotalVoterCount int `json:"total_voter_count"`

	// Poll type, currently can be ‚Äúregular‚Äù or ‚Äúquiz‚Äù
	Type PollType `json:"type"`
}

// Poll type, currently can be ‚Äúregular‚Äù or ‚Äúquiz‚Äù
type PollType string

// This object represents an answer of a user in a non-anonymous poll.
type PollAnswer struct {
	// 0-based identifiers of answer options, chosen by the user. May be empty if the user retracted their vote.
	OptionIds []int `json:"option_ids"`

	// Unique poll identifier
	PollId string `json:"poll_id"`

	// This object represents a Telegram user or bot.
	User User `json:"user"`
}

// This object contains information about one answer option in a poll.
type PollOption struct {
	// Option text, 1-100 characters
	Text string `json:"text"`

	// Number of users that voted for this option
	VoterCount int `json:"voter_count"`
}

// This object contains information about an incoming pre-checkout query.
type PreCheckoutQuery struct {
	// Three-letter ISO 4217 [currency](https://core.telegram.org/bots/payments#supported-currencies) code
	Currency string `json:"currency"`

	// This object represents a Telegram user or bot.
	From User `json:"from"`

	// Unique query identifier
	Id string `json:"id"`

	// Bot specified invoice payload
	InvoicePayload string `json:"invoice_payload"`

	// This object represents information about an order.
	OrderInfo *OrderInfo `json:"order_info,omitempty"`

	// *Optional*. Identifier of the shipping option chosen by the user
	ShippingOptionId *string `json:"shipping_option_id,omitempty"`

	// Total price in the *smallest units* of the currency (integer, **not** float/double). For example, for a price of `US$ 1.45` pass `amount = 145`. See the *exp* parameter in [currencies.json](https://core.telegram.org/bots/payments/currencies.json), it shows the number of digits past the decimal point for each currency (2 for the majority of currencies).
	TotalAmount int `json:"total_amount"`
}

// This object represents the content of a service message, sent whenever a user in the chat triggers a proximity alert set by another user.
type ProximityAlertTriggered struct {
	// The distance between the users
	Distance int `json:"distance"`

	// This object represents a Telegram user or bot.
	Traveler User `json:"traveler"`

	// This object represents a Telegram user or bot.
	Watcher User `json:"watcher"`
}

// This object represents a [custom keyboard](https://core.telegram.org/bots#keyboards) with reply options (see [Introduction to bots](https://core.telegram.org/bots#keyboards) for details and examples).
type ReplyKeyboardMarkup struct {
	// *Optional*. The placeholder to be shown in the input field when the keyboard is active; 1-64 characters
	InputFieldPlaceholder *string `json:"input_field_placeholder,omitempty"`

	// Array of button rows, each represented by an Array of [KeyboardButton](https://core.telegram.org/bots/api/#keyboardbutton) objects
	Keyboard [][]KeyboardButton `json:"keyboard"`

	// *Optional*. Requests clients to hide the keyboard as soon as it's been used. The keyboard will still be available, but clients will automatically display the usual letter-keyboard in the chat - the user can press a special button in the input field to see the custom keyboard again. Defaults to *false*.
	OneTimeKeyboard *bool `json:"one_time_keyboard,omitempty"`

	// *Optional*. Requests clients to resize the keyboard vertically for optimal fit (e.g., make the keyboard smaller if there are just two rows of buttons). Defaults to *false*, in which case the custom keyboard is always of the same height as the app's standard keyboard.
	ResizeKeyboard *bool `json:"resize_keyboard,omitempty"`

	// *Optional*. Use this parameter if you want to show the keyboard to specific users only. Targets: 1) users that are @mentioned in the *text* of the [Message](https://core.telegram.org/bots/api/#message) object; 2) if the bot's message is a reply (has *reply\_to\_message\_id*), sender of the original message.
	//
	// *Example:* A user requests to change the bot's language, bot replies to the request with a keyboard to select the new language. Other users in the group don't see the keyboard.
	Selective *bool `json:"selective,omitempty"`
}

// Upon receiving a message with this object, Telegram clients will remove the current custom keyboard and display the default letter-keyboard. By default, custom keyboards are displayed until a new keyboard is sent by a bot. An exception is made for one-time keyboards that are hidden immediately after the user presses a button (see [ReplyKeyboardMarkup](https://core.telegram.org/bots/api/#replykeyboardmarkup)).
type ReplyKeyboardRemove struct {
	// Requests clients to remove the custom keyboard (user will not be able to summon this keyboard; if you want to hide the keyboard from sight but keep it accessible, use *one\_time\_keyboard* in [ReplyKeyboardMarkup](https://core.telegram.org/bots/api/#replykeyboardmarkup))
	RemoveKeyboard bool `json:"remove_keyboard"`

	// *Optional*. Use this parameter if you want to remove the keyboard for specific users only. Targets: 1) users that are @mentioned in the *text* of the [Message](https://core.telegram.org/bots/api/#message) object; 2) if the bot's message is a reply (has *reply\_to\_message\_id*), sender of the original message.
	//
	// *Example:* A user votes in a poll, bot returns confirmation message in reply to the vote and removes the keyboard for that user, while still showing the keyboard with poll options to users who haven't voted yet.
	Selective *bool `json:"selective,omitempty"`
}

// Describes why a request was unsuccessful.
type ResponseParameters struct {
	// *Optional*. The group has been migrated to a supergroup with the specified identifier. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier.
	MigrateToChatId *int `json:"migrate_to_chat_id,omitempty"`

	// *Optional*. In case of exceeding flood control, the number of seconds left to wait before the request can be repeated
	RetryAfter *int `json:"retry_after,omitempty"`
}

// Describes an inline message sent by a [Web App](https://core.telegram.org/bots/webapps) on behalf of a user.
type SentWebAppMessage struct {
	// *Optional*. Identifier of the sent inline message. Available only if there is an [inline keyboard](https://core.telegram.org/bots/api/#inlinekeyboardmarkup) attached to the message.
	InlineMessageId *string `json:"inline_message_id,omitempty"`
}

// This object represents a shipping address.
type ShippingAddress struct {
	// City
	City string `json:"city"`

	// Two-letter ISO 3166-1 alpha-2 country code
	CountryCode string `json:"country_code"`

	// Address post code
	PostCode string `json:"post_code"`

	// State, if applicable
	State string `json:"state"`

	// First line for the address
	StreetLine1 string `json:"street_line1"`

	// Second line for the address
	StreetLine2 string `json:"street_line2"`
}

// This object represents one shipping option.
type ShippingOption struct {
	// Shipping option identifier
	Id string `json:"id"`

	// List of price portions
	Prices []LabeledPrice `json:"prices"`

	// Option title
	Title string `json:"title"`
}

// This object contains information about an incoming shipping query.
type ShippingQuery struct {
	// This object represents a Telegram user or bot.
	From User `json:"from"`

	// Unique query identifier
	Id string `json:"id"`

	// Bot specified invoice payload
	InvoicePayload string `json:"invoice_payload"`

	// This object represents a shipping address.
	ShippingAddress ShippingAddress `json:"shipping_address"`
}

// This object represents a sticker.
type Sticker struct {
	// *Optional*. Emoji associated with the sticker
	Emoji *string `json:"emoji,omitempty"`

	// Identifier for this file, which can be used to download or reuse the file
	FileId string `json:"file_id"`

	// *Optional*. File size in bytes
	FileSize *int `json:"file_size,omitempty"`

	// Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file.
	FileUniqueId string `json:"file_unique_id"`

	// Sticker height
	Height int `json:"height"`

	// *True*, if the sticker is [animated](https://telegram.org/blog/animated-stickers)
	IsAnimated bool `json:"is_animated"`

	// *True*, if the sticker is a [video sticker](https://telegram.org/blog/video-stickers-better-reactions)
	IsVideo bool `json:"is_video"`

	// This object describes the position on faces where a mask should be placed by default.
	MaskPosition *MaskPosition `json:"mask_position,omitempty"`

	// This object represents a file ready to be downloaded. The file can be downloaded via the link `https://api.telegram.org/file/bot<token>/<file_path>`. It is guaranteed that the link will be valid for at least 1 hour. When the link expires, a new one can be requested by calling [getFile](https://core.telegram.org/bots/api/#getfile).
	//
	// The maximum file size to download is 20 MB
	PremiumAnimation *File `json:"premium_animation,omitempty"`

	// *Optional*. Name of the sticker set to which the sticker belongs
	SetName *string `json:"set_name,omitempty"`

	// This object represents one size of a photo or a [file](https://core.telegram.org/bots/api/#document) / [sticker](https://core.telegram.org/bots/api/#sticker) thumbnail.
	Thumb *PhotoSize `json:"thumb,omitempty"`

	// Sticker width
	Width int `json:"width"`
}

// This object represents a sticker set.
type StickerSet struct {
	// *True*, if the sticker set contains masks
	ContainsMasks bool `json:"contains_masks"`

	// *True*, if the sticker set contains [animated stickers](https://telegram.org/blog/animated-stickers)
	IsAnimated bool `json:"is_animated"`

	// *True*, if the sticker set contains [video stickers](https://telegram.org/blog/video-stickers-better-reactions)
	IsVideo bool `json:"is_video"`

	// Sticker set name
	Name string `json:"name"`

	// List of all set stickers
	Stickers []Sticker `json:"stickers"`

	// This object represents one size of a photo or a [file](https://core.telegram.org/bots/api/#document) / [sticker](https://core.telegram.org/bots/api/#sticker) thumbnail.
	Thumb *PhotoSize `json:"thumb,omitempty"`

	// Sticker set title
	Title string `json:"title"`
}

// This object contains basic information about a successful payment.
type SuccessfulPayment struct {
	// Three-letter ISO 4217 [currency](https://core.telegram.org/bots/payments#supported-currencies) code
	Currency string `json:"currency"`

	// Bot specified invoice payload
	InvoicePayload string `json:"invoice_payload"`

	// This object represents information about an order.
	OrderInfo *OrderInfo `json:"order_info,omitempty"`

	// Provider payment identifier
	ProviderPaymentChargeId string `json:"provider_payment_charge_id"`

	// *Optional*. Identifier of the shipping option chosen by the user
	ShippingOptionId *string `json:"shipping_option_id,omitempty"`

	// Telegram payment identifier
	TelegramPaymentChargeId string `json:"telegram_payment_charge_id"`

	// Total price in the *smallest units* of the currency (integer, **not** float/double). For example, for a price of `US$ 1.45` pass `amount = 145`. See the *exp* parameter in [currencies.json](https://core.telegram.org/bots/payments/currencies.json), it shows the number of digits past the decimal point for each currency (2 for the majority of currencies).
	TotalAmount int `json:"total_amount"`
}

// This [object](https://core.telegram.org/bots/api/#available-types) represents an incoming update.
// At most **one** of the optional parameters can be present in any given update.
type Update struct {
	// This object represents an incoming callback query from a callback button in an [inline keyboard](https://core.telegram.org/bots#inline-keyboards-and-on-the-fly-updating). If the button that originated the query was attached to a message sent by the bot, the field *message* will be present. If the button was attached to a message sent via the bot (in [inline mode](https://core.telegram.org/bots/api/#inline-mode)), the field *inline\_message\_id* will be present. Exactly one of the fields *data* or *game\_short\_name* will be present.
	CallbackQuery *CallbackQuery `json:"callback_query,omitempty"`

	// This object represents a message.
	ChannelPost *Message `json:"channel_post,omitempty"`

	// Represents a join request sent to a chat.
	ChatJoinRequest *ChatJoinRequest `json:"chat_join_request,omitempty"`

	// This object represents changes in the status of a chat member.
	ChatMember *ChatMemberUpdated `json:"chat_member,omitempty"`

	// Represents a [result](https://core.telegram.org/bots/api/#inlinequeryresult) of an inline query that was chosen by the user and sent to their chat partner.
	ChosenInlineResult *ChosenInlineResult `json:"chosen_inline_result,omitempty"`

	// This object represents a message.
	EditedChannelPost *Message `json:"edited_channel_post,omitempty"`

	// This object represents a message.
	EditedMessage *Message `json:"edited_message,omitempty"`

	// This object represents an incoming inline query. When the user sends an empty query, your bot could return some default or trending results.
	InlineQuery *InlineQuery `json:"inline_query,omitempty"`

	// This object represents a message.
	Message *Message `json:"message,omitempty"`

	// This object represents changes in the status of a chat member.
	MyChatMember *ChatMemberUpdated `json:"my_chat_member,omitempty"`

	// This object contains information about a poll.
	Poll *Poll `json:"poll,omitempty"`

	// This object represents an answer of a user in a non-anonymous poll.
	PollAnswer *PollAnswer `json:"poll_answer,omitempty"`

	// This object contains information about an incoming pre-checkout query.
	PreCheckoutQuery *PreCheckoutQuery `json:"pre_checkout_query,omitempty"`

	// This object contains information about an incoming shipping query.
	ShippingQuery *ShippingQuery `json:"shipping_query,omitempty"`

	// The update's unique identifier. Update identifiers start from a certain positive number and increase sequentially. This ID becomes especially handy if you're using [webhooks](https://core.telegram.org/bots/api/#setwebhook), since it allows you to ignore repeated updates or to restore the correct update sequence, should they get out of order. If there are no new updates for at least a week, then identifier of the next update will be chosen randomly instead of sequentially.
	UpdateId int `json:"update_id"`
}

// This object represents a Telegram user or bot.
type User struct {
	// *Optional*. *True*, if this user added the bot to the attachment menu
	AddedToAttachmentMenu *bool `json:"added_to_attachment_menu,omitempty"`

	// *Optional*. *True*, if the bot can be invited to groups. Returned only in [getMe](https://core.telegram.org/bots/api/#getme).
	CanJoinGroups *bool `json:"can_join_groups,omitempty"`

	// *Optional*. *True*, if [privacy mode](https://core.telegram.org/bots#privacy-mode) is disabled for the bot. Returned only in [getMe](https://core.telegram.org/bots/api/#getme).
	CanReadAllGroupMessages *bool `json:"can_read_all_group_messages,omitempty"`

	// User's or bot's first name
	FirstName string `json:"first_name"`

	// Unique identifier for this user or bot. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier.
	Id int `json:"id"`

	// *True*, if this user is a bot
	IsBot bool `json:"is_bot"`

	// *Optional*. *True*, if this user is a Telegram Premium user
	IsPremium *bool `json:"is_premium,omitempty"`

	// *Optional*. [IETF language tag](https://en.wikipedia.org/wiki/IETF_language_tag) of the user's language
	LanguageCode *string `json:"language_code,omitempty"`

	// *Optional*. User's or bot's last name
	LastName *string `json:"last_name,omitempty"`

	// *Optional*. *True*, if the bot supports inline queries. Returned only in [getMe](https://core.telegram.org/bots/api/#getme).
	SupportsInlineQueries *bool `json:"supports_inline_queries,omitempty"`

	// *Optional*. User's or bot's username
	Username *string `json:"username,omitempty"`
}

// This object represent a user's profile pictures.
type UserProfilePhotos struct {
	// Requested profile pictures (in up to 4 sizes each)
	Photos [][]PhotoSize `json:"photos"`

	// Total number of profile pictures the target user has
	TotalCount int `json:"total_count"`
}

// This object represents a venue.
type Venue struct {
	// Address of the venue
	Address string `json:"address"`

	// *Optional*. Foursquare identifier of the venue
	FoursquareId *string `json:"foursquare_id,omitempty"`

	// *Optional*. Foursquare type of the venue. (For example, ‚Äúarts\_entertainment/default‚Äù, ‚Äúarts\_entertainment/aquarium‚Äù or ‚Äúfood/icecream‚Äù.)
	FoursquareType *string `json:"foursquare_type,omitempty"`

	// *Optional*. Google Places identifier of the venue
	GooglePlaceId *string `json:"google_place_id,omitempty"`

	// *Optional*. Google Places type of the venue. (See [supported types](https://developers.google.com/places/web-service/supported_types).)
	GooglePlaceType *string `json:"google_place_type,omitempty"`

	// This object represents a point on the map.
	Location Location `json:"location"`

	// Name of the venue
	Title string `json:"title"`
}

// This object represents a video file.
type Video struct {
	// Duration of the video in seconds as defined by sender
	Duration int `json:"duration"`

	// Identifier for this file, which can be used to download or reuse the file
	FileId string `json:"file_id"`

	// *Optional*. Original filename as defined by sender
	FileName *string `json:"file_name,omitempty"`

	// *Optional*. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value.
	FileSize *int `json:"file_size,omitempty"`

	// Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file.
	FileUniqueId string `json:"file_unique_id"`

	// Video height as defined by sender
	Height int `json:"height"`

	// *Optional*. MIME type of the file as defined by sender
	MimeType *string `json:"mime_type,omitempty"`

	// This object represents one size of a photo or a [file](https://core.telegram.org/bots/api/#document) / [sticker](https://core.telegram.org/bots/api/#sticker) thumbnail.
	Thumb *PhotoSize `json:"thumb,omitempty"`

	// Video width as defined by sender
	Width int `json:"width"`
}

// This object represents a service message about a video chat ended in the chat.
type VideoChatEnded struct {
	// Video chat duration in seconds
	Duration int `json:"duration"`
}

// This object represents a service message about new members invited to a video chat.
type VideoChatParticipantsInvited struct {
	// New members that were invited to the video chat
	Users []User `json:"users"`
}

// This object represents a service message about a video chat scheduled in the chat.
type VideoChatScheduled struct {
	// Point in time (Unix timestamp) when the video chat is supposed to be started by a chat administrator
	StartDate int `json:"start_date"`
}

// This object represents a service message about a video chat started in the chat. Currently holds no information.
type VideoChatStarted = interface{}

// This object represents a [video message](https://telegram.org/blog/video-messages-and-telescope) (available in Telegram apps as of [v.4.0](https://telegram.org/blog/video-messages-and-telescope)).
type VideoNote struct {
	// Duration of the video in seconds as defined by sender
	Duration int `json:"duration"`

	// Identifier for this file, which can be used to download or reuse the file
	FileId string `json:"file_id"`

	// *Optional*. File size in bytes
	FileSize *int `json:"file_size,omitempty"`

	// Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file.
	FileUniqueId string `json:"file_unique_id"`

	// Video width and height (diameter of the video message) as defined by sender
	Length int `json:"length"`

	// This object represents one size of a photo or a [file](https://core.telegram.org/bots/api/#document) / [sticker](https://core.telegram.org/bots/api/#sticker) thumbnail.
	Thumb *PhotoSize `json:"thumb,omitempty"`
}

// This object represents a voice note.
type Voice struct {
	// Duration of the audio in seconds as defined by sender
	Duration int `json:"duration"`

	// Identifier for this file, which can be used to download or reuse the file
	FileId string `json:"file_id"`

	// *Optional*. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value.
	FileSize *int `json:"file_size,omitempty"`

	// Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file.
	FileUniqueId string `json:"file_unique_id"`

	// *Optional*. MIME type of the file as defined by sender
	MimeType *string `json:"mime_type,omitempty"`
}

// Describes data sent from a [Web App](https://core.telegram.org/bots/webapps) to the bot.
type WebAppData struct {
	// Text of the *web\_app* keyboard button from which the Web App was opened. Be aware that a bad client can send arbitrary data in this field.
	ButtonText string `json:"button_text"`

	// The data. Be aware that a bad client can send arbitrary data in this field.
	Data string `json:"data"`
}

// Describes a [Web App](https://core.telegram.org/bots/webapps).
type WebAppInfo struct {
	// An HTTPS URL of a Web App to be opened with additional data as specified in [Initializing Web Apps](https://core.telegram.org/bots/webapps#initializing-web-apps)
	Url string `json:"url"`
}

// Describes the current status of a webhook.
type WebhookInfo struct {
	// *Optional*. A list of update types the bot is subscribed to. Defaults to all update types except *chat\_member*
	AllowedUpdates *[]string `json:"allowed_updates,omitempty"`

	// *True*, if a custom certificate was provided for webhook certificate checks
	HasCustomCertificate bool `json:"has_custom_certificate"`

	// *Optional*. Currently used webhook IP address
	IpAddress *string `json:"ip_address,omitempty"`

	// *Optional*. Unix time for the most recent error that happened when trying to deliver an update via webhook
	LastErrorDate *int `json:"last_error_date,omitempty"`

	// *Optional*. Error message in human-readable format for the most recent error that happened when trying to deliver an update via webhook
	LastErrorMessage *string `json:"last_error_message,omitempty"`

	// *Optional*. Unix time of the most recent error that happened when trying to synchronize available updates with Telegram datacenters
	LastSynchronizationErrorDate *int `json:"last_synchronization_error_date,omitempty"`

	// *Optional*. The maximum allowed number of simultaneous HTTPS connections to the webhook for update delivery
	MaxConnections *int `json:"max_connections,omitempty"`

	// Number of updates awaiting delivery
	PendingUpdateCount int `json:"pending_update_count"`

	// Webhook URL, may be empty if webhook is not set up
	Url string `json:"url"`
}

// PostAnswerCallbackQueryJSONBody defines parameters for PostAnswerCallbackQuery.
type PostAnswerCallbackQueryJSONBody struct {
	// The maximum amount of time in seconds that the result of the callback query may be cached client-side. Telegram apps will support caching starting in version 3.14. Defaults to 0.
	CacheTime *int `json:"cache_time,omitempty"`

	// Unique identifier for the query to be answered
	CallbackQueryId string `json:"callback_query_id"`

	// If *True*, an alert will be shown by the client instead of a notification at the top of the chat screen. Defaults to *false*.
	ShowAlert *bool `json:"show_alert,omitempty"`

	// Text of the notification. If not specified, nothing will be shown to the user, 0-200 characters
	Text *string `json:"text,omitempty"`

	// URL that will be opened by the user's client. If you have created a [Game](https://core.telegram.org/bots/api/#game) and accepted the conditions via [@BotFather](https://t.me/botfather), specify the URL that opens your game - note that this will only work if the query comes from a [*callback\_game*](https://core.telegram.org/bots/api/#inlinekeyboardbutton) button.
	//
	// Otherwise, you may use links like `t.me/your_bot?start=XXXX` that open your bot with a parameter.
	Url *string `json:"url,omitempty"`
}

// PostAnswerInlineQueryJSONBody defines parameters for PostAnswerInlineQuery.
type PostAnswerInlineQueryJSONBody struct {
	// The maximum amount of time in seconds that the result of the inline query may be cached on the server. Defaults to 300.
	CacheTime *int `json:"cache_time,omitempty"`

	// Unique identifier for the answered query
	InlineQueryId string `json:"inline_query_id"`

	// Pass *True*, if results may be cached on the server side only for the user that sent the query. By default, results may be returned to any user who sends the same query
	IsPersonal *bool `json:"is_personal,omitempty"`

	// Pass the offset that a client should send in the next query with the same text to receive more results. Pass an empty string if there are no more results or if you don't support pagination. Offset length can't exceed 64 bytes.
	NextOffset *string `json:"next_offset,omitempty"`

	// A JSON-serialized array of results for the inline query
	Results []InlineQueryResult `json:"results"`

	// [Deep-linking](https://core.telegram.org/bots#deep-linking) parameter for the /start message sent to the bot when user presses the switch button. 1-64 characters, only `A-Z`, `a-z`, `0-9`, `_` and `-` are allowed.
	//
	// *Example:* An inline bot that sends YouTube videos can ask the user to connect the bot to their YouTube account to adapt search results accordingly. To do this, it displays a 'Connect your YouTube account' button above the results, or even before showing any. The user presses the button, switches to a private chat with the bot and, in doing so, passes a start parameter that instructs the bot to return an OAuth link. Once done, the bot can offer a [*switch\_inline*](https://core.telegram.org/bots/api/#inlinekeyboardmarkup) button so that the user can easily return to the chat where they wanted to use the bot's inline capabilities.
	SwitchPmParameter *string `json:"switch_pm_parameter,omitempty"`

	// If passed, clients will display a button with specified text that switches the user to a private chat with the bot and sends the bot a start message with the parameter *switch\_pm\_parameter*
	SwitchPmText *string `json:"switch_pm_text,omitempty"`
}

// PostAnswerPreCheckoutQueryJSONBody defines parameters for PostAnswerPreCheckoutQuery.
type PostAnswerPreCheckoutQueryJSONBody struct {
	// Required if *ok* is *False*. Error message in human readable form that explains the reason for failure to proceed with the checkout (e.g. "Sorry, somebody just bought the last of our amazing black T-shirts while you were busy filling out your payment details. Please choose a different color or garment!"). Telegram will display this message to the user.
	ErrorMessage *string `json:"error_message,omitempty"`

	// Specify *True* if everything is alright (goods are available, etc.) and the bot is ready to proceed with the order. Use *False* if there are any problems.
	Ok bool `json:"ok"`

	// Unique identifier for the query to be answered
	PreCheckoutQueryId string `json:"pre_checkout_query_id"`
}

// PostAnswerShippingQueryJSONBody defines parameters for PostAnswerShippingQuery.
type PostAnswerShippingQueryJSONBody struct {
	// Required if *ok* is False. Error message in human readable form that explains why it is impossible to complete the order (e.g. "Sorry, delivery to your desired address is unavailable'). Telegram will display this message to the user.
	ErrorMessage *string `json:"error_message,omitempty"`

	// Specify *True* if delivery to the specified address is possible and False if there are any problems (for example, if delivery to the specified address is not possible)
	Ok bool `json:"ok"`

	// Required if *ok* is *True*. A JSON-serialized array of available shipping options.
	ShippingOptions *[]ShippingOption `json:"shipping_options,omitempty"`

	// Unique identifier for the query to be answered
	ShippingQueryId string `json:"shipping_query_id"`
}

// PostAnswerWebAppQueryJSONBody defines parameters for PostAnswerWebAppQuery.
type PostAnswerWebAppQueryJSONBody struct {
	// This object represents one result of an inline query. Telegram clients currently support results of the following 20 types:
	//
	// * [InlineQueryResultCachedAudio](https://core.telegram.org/bots/api/#inlinequeryresultcachedaudio)
	// * [InlineQueryResultCachedDocument](https://core.telegram.org/bots/api/#inlinequeryresultcacheddocument)
	// * [InlineQueryResultCachedGif](https://core.telegram.org/bots/api/#inlinequeryresultcachedgif)
	// * [InlineQueryResultCachedMpeg4Gif](https://core.telegram.org/bots/api/#inlinequeryresultcachedmpeg4gif)
	// * [InlineQueryResultCachedPhoto](https://core.telegram.org/bots/api/#inlinequeryresultcachedphoto)
	// * [InlineQueryResultCachedSticker](https://core.telegram.org/bots/api/#inlinequeryresultcachedsticker)
	// * [InlineQueryResultCachedVideo](https://core.telegram.org/bots/api/#inlinequeryresultcachedvideo)
	// * [InlineQueryResultCachedVoice](https://core.telegram.org/bots/api/#inlinequeryresultcachedvoice)
	// * [InlineQueryResultArticle](https://core.telegram.org/bots/api/#inlinequeryresultarticle)
	// * [InlineQueryResultAudio](https://core.telegram.org/bots/api/#inlinequeryresultaudio)
	// * [InlineQueryResultContact](https://core.telegram.org/bots/api/#inlinequeryresultcontact)
	// * [InlineQueryResultGame](https://core.telegram.org/bots/api/#inlinequeryresultgame)
	// * [InlineQueryResultDocument](https://core.telegram.org/bots/api/#inlinequeryresultdocument)
	// * [InlineQueryResultGif](https://core.telegram.org/bots/api/#inlinequeryresultgif)
	// * [InlineQueryResultLocation](https://core.telegram.org/bots/api/#inlinequeryresultlocation)
	// * [InlineQueryResultMpeg4Gif](https://core.telegram.org/bots/api/#inlinequeryresultmpeg4gif)
	// * [InlineQueryResultPhoto](https://core.telegram.org/bots/api/#inlinequeryresultphoto)
	// * [InlineQueryResultVenue](https://core.telegram.org/bots/api/#inlinequeryresultvenue)
	// * [InlineQueryResultVideo](https://core.telegram.org/bots/api/#inlinequeryresultvideo)
	// * [InlineQueryResultVoice](https://core.telegram.org/bots/api/#inlinequeryresultvoice)
	Result InlineQueryResult `json:"result"`

	// Unique identifier for the query to be answered
	WebAppQueryId string `json:"web_app_query_id"`
}

// PostApproveChatJoinRequestJSONBody defines parameters for PostApproveChatJoinRequest.
type PostApproveChatJoinRequestJSONBody struct {
	// Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)
	ChatId interface{} `json:"chat_id"`

	// Unique identifier of the target user
	UserId int `json:"user_id"`
}

// PostBanChatMemberJSONBody defines parameters for PostBanChatMember.
type PostBanChatMemberJSONBody struct {
	// Unique identifier for the target group or username of the target supergroup or channel (in the format `@channelusername`)
	ChatId interface{} `json:"chat_id"`

	// Pass *True* to delete all messages from the chat for the user that is being removed. If *False*, the user will be able to see messages in the group that were sent before the user was removed. Always *True* for supergroups and channels.
	RevokeMessages *bool `json:"revoke_messages,omitempty"`

	// Date when the user will be unbanned, unix time. If user is banned for more than 366 days or less than 30 seconds from the current time they are considered to be banned forever. Applied for supergroups and channels only.
	UntilDate *int `json:"until_date,omitempty"`

	// Unique identifier of the target user
	UserId int `json:"user_id"`
}

// PostBanChatSenderChatJSONBody defines parameters for PostBanChatSenderChat.
type PostBanChatSenderChatJSONBody struct {
	// Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)
	ChatId interface{} `json:"chat_id"`

	// Unique identifier of the target sender chat
	SenderChatId int `json:"sender_chat_id"`
}

// PostCopyMessageJSONBody defines parameters for PostCopyMessage.
type PostCopyMessageJSONBody struct {
	// Pass *True*, if the message should be sent even if the specified replied-to message is not found
	AllowSendingWithoutReply *bool `json:"allow_sending_without_reply,omitempty"`

	// New caption for media, 0-1024 characters after entities parsing. If not specified, the original caption is kept
	Caption *string `json:"caption,omitempty"`

	// A JSON-serialized list of special entities that appear in the new caption, which can be specified instead of *parse\_mode*
	CaptionEntities *[]MessageEntity `json:"caption_entities,omitempty"`

	// Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)
	ChatId interface{} `json:"chat_id"`

	// Sends the message [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
	DisableNotification *bool `json:"disable_notification,omitempty"`

	// Unique identifier for the chat where the original message was sent (or channel username in the format `@channelusername`)
	FromChatId interface{} `json:"from_chat_id"`

	// Message identifier in the chat specified in *from\_chat\_id*
	MessageId int `json:"message_id"`

	// Mode for parsing entities in the new caption. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
	ParseMode *string `json:"parse_mode,omitempty"`

	// Protects the contents of the sent message from forwarding and saving
	ProtectContent *bool `json:"protect_content,omitempty"`

	// Additional interface options. A JSON-serialized object for an [inline keyboard](https://core.telegram.org/bots#inline-keyboards-and-on-the-fly-updating), [custom reply keyboard](https://core.telegram.org/bots#keyboards), instructions to remove reply keyboard or to force a reply from the user.
	ReplyMarkup *interface{} `json:"reply_markup,omitempty"`

	// If the message is a reply, ID of the original message
	ReplyToMessageId *int `json:"reply_to_message_id,omitempty"`
}

// PostCreateChatInviteLinkJSONBody defines parameters for PostCreateChatInviteLink.
type PostCreateChatInviteLinkJSONBody struct {
	// Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)
	ChatId interface{} `json:"chat_id"`

	// *True*, if users joining the chat via the link need to be approved by chat administrators. If *True*, *member\_limit* can't be specified
	CreatesJoinRequest *bool `json:"creates_join_request,omitempty"`

	// Point in time (Unix timestamp) when the link will expire
	ExpireDate *int `json:"expire_date,omitempty"`

	// The maximum number of users that can be members of the chat simultaneously after joining the chat via this invite link; 1-99999
	MemberLimit *int `json:"member_limit,omitempty"`

	// Invite link name; 0-32 characters
	Name *string `json:"name,omitempty"`
}

// PostCreateInvoiceLinkJSONBody defines parameters for PostCreateInvoiceLink.
type PostCreateInvoiceLinkJSONBody struct {
	// Three-letter ISO 4217 currency code, see [more on currencies](https://core.telegram.org/bots/payments#supported-currencies)
	Currency string `json:"currency"`

	// Product description, 1-255 characters
	Description string `json:"description"`

	// Pass *True*, if the final price depends on the shipping method
	IsFlexible *bool `json:"is_flexible,omitempty"`

	// The maximum accepted amount for tips in the *smallest units* of the currency (integer, **not** float/double). For example, for a maximum tip of `US$ 1.45` pass `max_tip_amount = 145`. See the *exp* parameter in [currencies.json](https://core.telegram.org/bots/payments/currencies.json), it shows the number of digits past the decimal point for each currency (2 for the majority of currencies). Defaults to 0
	MaxTipAmount *int `json:"max_tip_amount,omitempty"`

	// Pass *True*, if you require the user's email address to complete the order
	NeedEmail *bool `json:"need_email,omitempty"`

	// Pass *True*, if you require the user's full name to complete the order
	NeedName *bool `json:"need_name,omitempty"`

	// Pass *True*, if you require the user's phone number to complete the order
	NeedPhoneNumber *bool `json:"need_phone_number,omitempty"`

	// Pass *True*, if you require the user's shipping address to complete the order
	NeedShippingAddress *bool `json:"need_shipping_address,omitempty"`

	// Bot-defined invoice payload, 1-128 bytes. This will not be displayed to the user, use for your internal processes.
	Payload string `json:"payload"`

	// Photo height
	PhotoHeight *int `json:"photo_height,omitempty"`

	// Photo size in bytes
	PhotoSize *int `json:"photo_size,omitempty"`

	// URL of the product photo for the invoice. Can be a photo of the goods or a marketing image for a service.
	PhotoUrl *string `json:"photo_url,omitempty"`

	// Photo width
	PhotoWidth *int `json:"photo_width,omitempty"`

	// Price breakdown, a JSON-serialized list of components (e.g. product price, tax, discount, delivery cost, delivery tax, bonus, etc.)
	Prices []LabeledPrice `json:"prices"`

	// JSON-serialized data about the invoice, which will be shared with the payment provider. A detailed description of required fields should be provided by the payment provider.
	ProviderData *string `json:"provider_data,omitempty"`

	// Payment provider token, obtained via [BotFather](https://t.me/botfather)
	ProviderToken string `json:"provider_token"`

	// Pass *True*, if the user's email address should be sent to the provider
	SendEmailToProvider *bool `json:"send_email_to_provider,omitempty"`

	// Pass *True*, if the user's phone number should be sent to the provider
	SendPhoneNumberToProvider *bool `json:"send_phone_number_to_provider,omitempty"`

	// A JSON-serialized array of suggested amounts of tips in the *smallest units* of the currency (integer, **not** float/double). At most 4 suggested tip amounts can be specified. The suggested tip amounts must be positive, passed in a strictly increased order and must not exceed *max\_tip\_amount*.
	SuggestedTipAmounts *[]int `json:"suggested_tip_amounts,omitempty"`

	// Product name, 1-32 characters
	Title string `json:"title"`
}

// PostDeclineChatJoinRequestJSONBody defines parameters for PostDeclineChatJoinRequest.
type PostDeclineChatJoinRequestJSONBody struct {
	// Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)
	ChatId interface{} `json:"chat_id"`

	// Unique identifier of the target user
	UserId int `json:"user_id"`
}

// PostDeleteChatPhotoJSONBody defines parameters for PostDeleteChatPhoto.
type PostDeleteChatPhotoJSONBody struct {
	// Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)
	ChatId interface{} `json:"chat_id"`
}

// PostDeleteChatStickerSetJSONBody defines parameters for PostDeleteChatStickerSet.
type PostDeleteChatStickerSetJSONBody struct {
	// Unique identifier for the target chat or username of the target supergroup (in the format `@supergroupusername`)
	ChatId interface{} `json:"chat_id"`
}

// PostDeleteMessageJSONBody defines parameters for PostDeleteMessage.
type PostDeleteMessageJSONBody struct {
	// Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)
	ChatId interface{} `json:"chat_id"`

	// Identifier of the message to delete
	MessageId int `json:"message_id"`
}

// PostDeleteMyCommandsJSONBody defines parameters for PostDeleteMyCommands.
type PostDeleteMyCommandsJSONBody struct {
	// A two-letter ISO 639-1 language code. If empty, commands will be applied to all users from the given scope, for whose language there are no dedicated commands
	LanguageCode *string `json:"language_code,omitempty"`

	// This object represents the scope to which bot commands are applied. Currently, the following 7 scopes are supported:
	//
	// * [BotCommandScopeDefault](https://core.telegram.org/bots/api/#botcommandscopedefault)
	// * [BotCommandScopeAllPrivateChats](https://core.telegram.org/bots/api/#botcommandscopeallprivatechats)
	// * [BotCommandScopeAllGroupChats](https://core.telegram.org/bots/api/#botcommandscopeallgroupchats)
	// * [BotCommandScopeAllChatAdministrators](https://core.telegram.org/bots/api/#botcommandscopeallchatadministrators)
	// * [BotCommandScopeChat](https://core.telegram.org/bots/api/#botcommandscopechat)
	// * [BotCommandScopeChatAdministrators](https://core.telegram.org/bots/api/#botcommandscopechatadministrators)
	// * [BotCommandScopeChatMember](https://core.telegram.org/bots/api/#botcommandscopechatmember)
	Scope *BotCommandScope `json:"scope,omitempty"`
}

// PostDeleteStickerFromSetJSONBody defines parameters for PostDeleteStickerFromSet.
type PostDeleteStickerFromSetJSONBody struct {
	// File identifier of the sticker
	Sticker string `json:"sticker"`
}

// PostDeleteWebhookJSONBody defines parameters for PostDeleteWebhook.
type PostDeleteWebhookJSONBody struct {
	// Pass *True* to drop all pending updates
	DropPendingUpdates *bool `json:"drop_pending_updates,omitempty"`
}

// PostEditChatInviteLinkJSONBody defines parameters for PostEditChatInviteLink.
type PostEditChatInviteLinkJSONBody struct {
	// Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)
	ChatId interface{} `json:"chat_id"`

	// *True*, if users joining the chat via the link need to be approved by chat administrators. If *True*, *member\_limit* can't be specified
	CreatesJoinRequest *bool `json:"creates_join_request,omitempty"`

	// Point in time (Unix timestamp) when the link will expire
	ExpireDate *int `json:"expire_date,omitempty"`

	// The invite link to edit
	InviteLink string `json:"invite_link"`

	// The maximum number of users that can be members of the chat simultaneously after joining the chat via this invite link; 1-99999
	MemberLimit *int `json:"member_limit,omitempty"`

	// Invite link name; 0-32 characters
	Name *string `json:"name,omitempty"`
}

// PostEditMessageCaptionJSONBody defines parameters for PostEditMessageCaption.
type PostEditMessageCaptionJSONBody struct {
	// New caption of the message, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`

	// A JSON-serialized list of special entities that appear in the caption, which can be specified instead of *parse\_mode*
	CaptionEntities *[]MessageEntity `json:"caption_entities,omitempty"`

	// Required if *inline\_message\_id* is not specified. Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)
	ChatId *interface{} `json:"chat_id,omitempty"`

	// Required if *chat\_id* and *message\_id* are not specified. Identifier of the inline message
	InlineMessageId *string `json:"inline_message_id,omitempty"`

	// Required if *inline\_message\_id* is not specified. Identifier of the message to edit
	MessageId *int `json:"message_id,omitempty"`

	// Mode for parsing entities in the message caption. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
	ParseMode *string `json:"parse_mode,omitempty"`

	// This object represents an [inline keyboard](https://core.telegram.org/bots#inline-keyboards-and-on-the-fly-updating) that appears right next to the message it belongs to.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

// PostEditMessageLiveLocationJSONBody defines parameters for PostEditMessageLiveLocation.
type PostEditMessageLiveLocationJSONBody struct {
	// Required if *inline\_message\_id* is not specified. Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)
	ChatId *interface{} `json:"chat_id,omitempty"`

	// Direction in which the user is moving, in degrees. Must be between 1 and 360 if specified.
	Heading *int `json:"heading,omitempty"`

	// The radius of uncertainty for the location, measured in meters; 0-1500
	HorizontalAccuracy *float32 `json:"horizontal_accuracy,omitempty"`

	// Required if *chat\_id* and *message\_id* are not specified. Identifier of the inline message
	InlineMessageId *string `json:"inline_message_id,omitempty"`

	// Latitude of new location
	Latitude float32 `json:"latitude"`

	// Longitude of new location
	Longitude float32 `json:"longitude"`

	// Required if *inline\_message\_id* is not specified. Identifier of the message to edit
	MessageId *int `json:"message_id,omitempty"`

	// The maximum distance for proximity alerts about approaching another chat member, in meters. Must be between 1 and 100000 if specified.
	ProximityAlertRadius *int `json:"proximity_alert_radius,omitempty"`

	// This object represents an [inline keyboard](https://core.telegram.org/bots#inline-keyboards-and-on-the-fly-updating) that appears right next to the message it belongs to.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

// PostEditMessageReplyMarkupJSONBody defines parameters for PostEditMessageReplyMarkup.
type PostEditMessageReplyMarkupJSONBody struct {
	// Required if *inline\_message\_id* is not specified. Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)
	ChatId *interface{} `json:"chat_id,omitempty"`

	// Required if *chat\_id* and *message\_id* are not specified. Identifier of the inline message
	InlineMessageId *string `json:"inline_message_id,omitempty"`

	// Required if *inline\_message\_id* is not specified. Identifier of the message to edit
	MessageId *int `json:"message_id,omitempty"`

	// This object represents an [inline keyboard](https://core.telegram.org/bots#inline-keyboards-and-on-the-fly-updating) that appears right next to the message it belongs to.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

// PostEditMessageTextJSONBody defines parameters for PostEditMessageText.
type PostEditMessageTextJSONBody struct {
	// Required if *inline\_message\_id* is not specified. Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)
	ChatId *interface{} `json:"chat_id,omitempty"`

	// Disables link previews for links in this message
	DisableWebPagePreview *bool `json:"disable_web_page_preview,omitempty"`

	// A JSON-serialized list of special entities that appear in message text, which can be specified instead of *parse\_mode*
	Entities *[]MessageEntity `json:"entities,omitempty"`

	// Required if *chat\_id* and *message\_id* are not specified. Identifier of the inline message
	InlineMessageId *string `json:"inline_message_id,omitempty"`

	// Required if *inline\_message\_id* is not specified. Identifier of the message to edit
	MessageId *int `json:"message_id,omitempty"`

	// Mode for parsing entities in the message text. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
	ParseMode *string `json:"parse_mode,omitempty"`

	// This object represents an [inline keyboard](https://core.telegram.org/bots#inline-keyboards-and-on-the-fly-updating) that appears right next to the message it belongs to.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`

	// New text of the message, 1-4096 characters after entities parsing
	Text string `json:"text"`
}

// PostExportChatInviteLinkJSONBody defines parameters for PostExportChatInviteLink.
type PostExportChatInviteLinkJSONBody struct {
	// Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)
	ChatId interface{} `json:"chat_id"`
}

// PostForwardMessageJSONBody defines parameters for PostForwardMessage.
type PostForwardMessageJSONBody struct {
	// Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)
	ChatId interface{} `json:"chat_id"`

	// Sends the message [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
	DisableNotification *bool `json:"disable_notification,omitempty"`

	// Unique identifier for the chat where the original message was sent (or channel username in the format `@channelusername`)
	FromChatId interface{} `json:"from_chat_id"`

	// Message identifier in the chat specified in *from\_chat\_id*
	MessageId int `json:"message_id"`

	// Protects the contents of the forwarded message from forwarding and saving
	ProtectContent *bool `json:"protect_content,omitempty"`
}

// PostGetChatJSONBody defines parameters for PostGetChat.
type PostGetChatJSONBody struct {
	// Unique identifier for the target chat or username of the target supergroup or channel (in the format `@channelusername`)
	ChatId interface{} `json:"chat_id"`
}

// PostGetChatAdministratorsJSONBody defines parameters for PostGetChatAdministrators.
type PostGetChatAdministratorsJSONBody struct {
	// Unique identifier for the target chat or username of the target supergroup or channel (in the format `@channelusername`)
	ChatId interface{} `json:"chat_id"`
}

// PostGetChatMemberJSONBody defines parameters for PostGetChatMember.
type PostGetChatMemberJSONBody struct {
	// Unique identifier for the target chat or username of the target supergroup or channel (in the format `@channelusername`)
	ChatId interface{} `json:"chat_id"`

	// Unique identifier of the target user
	UserId int `json:"user_id"`
}

// PostGetChatMemberCountJSONBody defines parameters for PostGetChatMemberCount.
type PostGetChatMemberCountJSONBody struct {
	// Unique identifier for the target chat or username of the target supergroup or channel (in the format `@channelusername`)
	ChatId interface{} `json:"chat_id"`
}

// PostGetChatMenuButtonJSONBody defines parameters for PostGetChatMenuButton.
type PostGetChatMenuButtonJSONBody struct {
	// Unique identifier for the target private chat. If not specified, default bot's menu button will be returned
	ChatId *int `json:"chat_id,omitempty"`
}

// PostGetFileJSONBody defines parameters for PostGetFile.
type PostGetFileJSONBody struct {
	// File identifier to get information about
	FileId string `json:"file_id"`
}

// PostGetGameHighScoresJSONBody defines parameters for PostGetGameHighScores.
type PostGetGameHighScoresJSONBody struct {
	// Required if *inline\_message\_id* is not specified. Unique identifier for the target chat
	ChatId *int `json:"chat_id,omitempty"`

	// Required if *chat\_id* and *message\_id* are not specified. Identifier of the inline message
	InlineMessageId *string `json:"inline_message_id,omitempty"`

	// Required if *inline\_message\_id* is not specified. Identifier of the sent message
	MessageId *int `json:"message_id,omitempty"`

	// Target user id
	UserId int `json:"user_id"`
}

// PostGetMyCommandsJSONBody defines parameters for PostGetMyCommands.
type PostGetMyCommandsJSONBody struct {
	// A two-letter ISO 639-1 language code or an empty string
	LanguageCode *string `json:"language_code,omitempty"`

	// This object represents the scope to which bot commands are applied. Currently, the following 7 scopes are supported:
	//
	// * [BotCommandScopeDefault](https://core.telegram.org/bots/api/#botcommandscopedefault)
	// * [BotCommandScopeAllPrivateChats](https://core.telegram.org/bots/api/#botcommandscopeallprivatechats)
	// * [BotCommandScopeAllGroupChats](https://core.telegram.org/bots/api/#botcommandscopeallgroupchats)
	// * [BotCommandScopeAllChatAdministrators](https://core.telegram.org/bots/api/#botcommandscopeallchatadministrators)
	// * [BotCommandScopeChat](https://core.telegram.org/bots/api/#botcommandscopechat)
	// * [BotCommandScopeChatAdministrators](https://core.telegram.org/bots/api/#botcommandscopechatadministrators)
	// * [BotCommandScopeChatMember](https://core.telegram.org/bots/api/#botcommandscopechatmember)
	Scope *BotCommandScope `json:"scope,omitempty"`
}

// PostGetMyDefaultAdministratorRightsJSONBody defines parameters for PostGetMyDefaultAdministratorRights.
type PostGetMyDefaultAdministratorRightsJSONBody struct {
	// Pass *True* to get default administrator rights of the bot in channels. Otherwise, default administrator rights of the bot for groups and supergroups will be returned.
	ForChannels *bool `json:"for_channels,omitempty"`
}

// PostGetStickerSetJSONBody defines parameters for PostGetStickerSet.
type PostGetStickerSetJSONBody struct {
	// Name of the sticker set
	Name string `json:"name"`
}

// PostGetUpdatesJSONBody defines parameters for PostGetUpdates.
type PostGetUpdatesJSONBody struct {
	// A JSON-serialized list of the update types you want your bot to receive. For example, specify [‚Äúmessage‚Äù, ‚Äúedited\_channel\_post‚Äù, ‚Äúcallback\_query‚Äù] to only receive updates of these types. See [Update](https://core.telegram.org/bots/api/#update) for a complete list of available update types. Specify an empty list to receive all update types except *chat\_member* (default). If not specified, the previous setting will be used.
	//
	// Please note that this parameter doesn't affect updates created before the call to the getUpdates, so unwanted updates may be received for a short period of time.
	AllowedUpdates *[]string `json:"allowed_updates,omitempty"`

	// Limits the number of updates to be retrieved. Values between 1-100 are accepted. Defaults to 100.
	Limit *int `json:"limit,omitempty"`

	// Identifier of the first update to be returned. Must be greater by one than the highest among the identifiers of previously received updates. By default, updates starting with the earliest unconfirmed update are returned. An update is considered confirmed as soon as [getUpdates](https://core.telegram.org/bots/api/#getupdates) is called with an *offset* higher than its *update\_id*. The negative offset can be specified to retrieve updates starting from *-offset* update from the end of the updates queue. All previous updates will forgotten.
	Offset *int `json:"offset,omitempty"`

	// Timeout in seconds for long polling. Defaults to 0, i.e. usual short polling. Should be positive, short polling should be used for testing purposes only.
	Timeout *int `json:"timeout,omitempty"`
}

// PostGetUserProfilePhotosJSONBody defines parameters for PostGetUserProfilePhotos.
type PostGetUserProfilePhotosJSONBody struct {
	// Limits the number of photos to be retrieved. Values between 1-100 are accepted. Defaults to 100.
	Limit *int `json:"limit,omitempty"`

	// Sequential number of the first photo to be returned. By default, all photos are returned.
	Offset *int `json:"offset,omitempty"`

	// Unique identifier of the target user
	UserId int `json:"user_id"`
}

// PostLeaveChatJSONBody defines parameters for PostLeaveChat.
type PostLeaveChatJSONBody struct {
	// Unique identifier for the target chat or username of the target supergroup or channel (in the format `@channelusername`)
	ChatId interface{} `json:"chat_id"`
}

// PostPinChatMessageJSONBody defines parameters for PostPinChatMessage.
type PostPinChatMessageJSONBody struct {
	// Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)
	ChatId interface{} `json:"chat_id"`

	// Pass *True*, if it is not necessary to send a notification to all chat members about the new pinned message. Notifications are always disabled in channels and private chats.
	DisableNotification *bool `json:"disable_notification,omitempty"`

	// Identifier of a message to pin
	MessageId int `json:"message_id"`
}

// PostPromoteChatMemberJSONBody defines parameters for PostPromoteChatMember.
type PostPromoteChatMemberJSONBody struct {
	// Pass *True*, if the administrator can change chat title, photo and other settings
	CanChangeInfo *bool `json:"can_change_info,omitempty"`

	// Pass *True*, if the administrator can delete messages of other users
	CanDeleteMessages *bool `json:"can_delete_messages,omitempty"`

	// Pass *True*, if the administrator can edit messages of other users and can pin messages, channels only
	CanEditMessages *bool `json:"can_edit_messages,omitempty"`

	// Pass *True*, if the administrator can invite new users to the chat
	CanInviteUsers *bool `json:"can_invite_users,omitempty"`

	// Pass *True*, if the administrator can access the chat event log, chat statistics, message statistics in channels, see channel members, see anonymous administrators in supergroups and ignore slow mode. Implied by any other administrator privilege
	CanManageChat *bool `json:"can_manage_chat,omitempty"`

	// Pass *True*, if the administrator can manage video chats
	CanManageVideoChats *bool `json:"can_manage_video_chats,omitempty"`

	// Pass *True*, if the administrator can pin messages, supergroups only
	CanPinMessages *bool `json:"can_pin_messages,omitempty"`

	// Pass *True*, if the administrator can create channel posts, channels only
	CanPostMessages *bool `json:"can_post_messages,omitempty"`

	// Pass *True*, if the administrator can add new administrators with a subset of their own privileges or demote administrators that he has promoted, directly or indirectly (promoted by administrators that were appointed by him)
	CanPromoteMembers *bool `json:"can_promote_members,omitempty"`

	// Pass *True*, if the administrator can restrict, ban or unban chat members
	CanRestrictMembers *bool `json:"can_restrict_members,omitempty"`

	// Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)
	ChatId interface{} `json:"chat_id"`

	// Pass *True*, if the administrator's presence in the chat is hidden
	IsAnonymous *bool `json:"is_anonymous,omitempty"`

	// Unique identifier of the target user
	UserId int `json:"user_id"`
}

// PostRestrictChatMemberJSONBody defines parameters for PostRestrictChatMember.
type PostRestrictChatMemberJSONBody struct {
	// Unique identifier for the target chat or username of the target supergroup (in the format `@supergroupusername`)
	ChatId interface{} `json:"chat_id"`

	// Describes actions that a non-administrator user is allowed to take in a chat.
	Permissions ChatPermissions `json:"permissions"`

	// Date when restrictions will be lifted for the user, unix time. If user is restricted for more than 366 days or less than 30 seconds from the current time, they are considered to be restricted forever
	UntilDate *int `json:"until_date,omitempty"`

	// Unique identifier of the target user
	UserId int `json:"user_id"`
}

// PostRevokeChatInviteLinkJSONBody defines parameters for PostRevokeChatInviteLink.
type PostRevokeChatInviteLinkJSONBody struct {
	// Unique identifier of the target chat or username of the target channel (in the format `@channelusername`)
	ChatId interface{} `json:"chat_id"`

	// The invite link to revoke
	InviteLink string `json:"invite_link"`
}

// PostSendChatActionJSONBody defines parameters for PostSendChatAction.
type PostSendChatActionJSONBody struct {
	// Type of action to broadcast. Choose one, depending on what the user is about to receive: *typing* for [text messages](https://core.telegram.org/bots/api/#sendmessage), *upload\_photo* for [photos](https://core.telegram.org/bots/api/#sendphoto), *record\_video* or *upload\_video* for [videos](https://core.telegram.org/bots/api/#sendvideo), *record\_voice* or *upload\_voice* for [voice notes](https://core.telegram.org/bots/api/#sendvoice), *upload\_document* for [general files](https://core.telegram.org/bots/api/#senddocument), *choose\_sticker* for [stickers](https://core.telegram.org/bots/api/#sendsticker), *find\_location* for [location data](https://core.telegram.org/bots/api/#sendlocation), *record\_video\_note* or *upload\_video\_note* for [video notes](https://core.telegram.org/bots/api/#sendvideonote).
	Action PostSendChatActionJSONBodyAction `json:"action"`

	// Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)
	ChatId interface{} `json:"chat_id"`
}

// PostSendChatActionJSONBodyAction defines parameters for PostSendChatAction.
type PostSendChatActionJSONBodyAction string

// PostSendContactJSONBody defines parameters for PostSendContact.
type PostSendContactJSONBody struct {
	// Pass *True*, if the message should be sent even if the specified replied-to message is not found
	AllowSendingWithoutReply *bool `json:"allow_sending_without_reply,omitempty"`

	// Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)
	ChatId interface{} `json:"chat_id"`

	// Sends the message [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
	DisableNotification *bool `json:"disable_notification,omitempty"`

	// Contact's first name
	FirstName string `json:"first_name"`

	// Contact's last name
	LastName *string `json:"last_name,omitempty"`

	// Contact's phone number
	PhoneNumber string `json:"phone_number"`

	// Protects the contents of the sent message from forwarding and saving
	ProtectContent *bool `json:"protect_content,omitempty"`

	// Additional interface options. A JSON-serialized object for an [inline keyboard](https://core.telegram.org/bots#inline-keyboards-and-on-the-fly-updating), [custom reply keyboard](https://core.telegram.org/bots#keyboards), instructions to remove keyboard or to force a reply from the user.
	ReplyMarkup *interface{} `json:"reply_markup,omitempty"`

	// If the message is a reply, ID of the original message
	ReplyToMessageId *int `json:"reply_to_message_id,omitempty"`

	// Additional data about the contact in the form of a [vCard](https://en.wikipedia.org/wiki/VCard), 0-2048 bytes
	Vcard *string `json:"vcard,omitempty"`
}

// PostSendDiceJSONBody defines parameters for PostSendDice.
type PostSendDiceJSONBody struct {
	// Pass *True*, if the message should be sent even if the specified replied-to message is not found
	AllowSendingWithoutReply *bool `json:"allow_sending_without_reply,omitempty"`

	// Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)
	ChatId interface{} `json:"chat_id"`

	// Sends the message [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
	DisableNotification *bool `json:"disable_notification,omitempty"`

	// Emoji on which the dice throw animation is based. Currently, must be one of ‚Äúüé≤‚Äù, ‚ÄúüéØ‚Äù, ‚ÄúüèÄ‚Äù, ‚Äú‚öΩ‚Äù, ‚Äúüé≥‚Äù, or ‚Äúüé∞‚Äù. Dice can have values 1-6 for ‚Äúüé≤‚Äù, ‚ÄúüéØ‚Äù and ‚Äúüé≥‚Äù, values 1-5 for ‚ÄúüèÄ‚Äù and ‚Äú‚öΩ‚Äù, and values 1-64 for ‚Äúüé∞‚Äù. Defaults to ‚Äúüé≤‚Äù
	Emoji *PostSendDiceJSONBodyEmoji `json:"emoji,omitempty"`

	// Protects the contents of the sent message from forwarding
	ProtectContent *bool `json:"protect_content,omitempty"`

	// Additional interface options. A JSON-serialized object for an [inline keyboard](https://core.telegram.org/bots#inline-keyboards-and-on-the-fly-updating), [custom reply keyboard](https://core.telegram.org/bots#keyboards), instructions to remove reply keyboard or to force a reply from the user.
	ReplyMarkup *interface{} `json:"reply_markup,omitempty"`

	// If the message is a reply, ID of the original message
	ReplyToMessageId *int `json:"reply_to_message_id,omitempty"`
}

// PostSendDiceJSONBodyEmoji defines parameters for PostSendDice.
type PostSendDiceJSONBodyEmoji string

// PostSendGameJSONBody defines parameters for PostSendGame.
type PostSendGameJSONBody struct {
	// Pass *True*, if the message should be sent even if the specified replied-to message is not found
	AllowSendingWithoutReply *bool `json:"allow_sending_without_reply,omitempty"`

	// Unique identifier for the target chat
	ChatId int `json:"chat_id"`

	// Sends the message [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
	DisableNotification *bool `json:"disable_notification,omitempty"`

	// Short name of the game, serves as the unique identifier for the game. Set up your games via [@BotFather](https://t.me/botfather).
	GameShortName string `json:"game_short_name"`

	// Protects the contents of the sent message from forwarding and saving
	ProtectContent *bool `json:"protect_content,omitempty"`

	// This object represents an [inline keyboard](https://core.telegram.org/bots#inline-keyboards-and-on-the-fly-updating) that appears right next to the message it belongs to.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`

	// If the message is a reply, ID of the original message
	ReplyToMessageId *int `json:"reply_to_message_id,omitempty"`
}

// PostSendInvoiceJSONBody defines parameters for PostSendInvoice.
type PostSendInvoiceJSONBody struct {
	// Pass *True*, if the message should be sent even if the specified replied-to message is not found
	AllowSendingWithoutReply *bool `json:"allow_sending_without_reply,omitempty"`

	// Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)
	ChatId interface{} `json:"chat_id"`

	// Three-letter ISO 4217 currency code, see [more on currencies](https://core.telegram.org/bots/payments#supported-currencies)
	Currency string `json:"currency"`

	// Product description, 1-255 characters
	Description string `json:"description"`

	// Sends the message [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
	DisableNotification *bool `json:"disable_notification,omitempty"`

	// Pass *True*, if the final price depends on the shipping method
	IsFlexible *bool `json:"is_flexible,omitempty"`

	// The maximum accepted amount for tips in the *smallest units* of the currency (integer, **not** float/double). For example, for a maximum tip of `US$ 1.45` pass `max_tip_amount = 145`. See the *exp* parameter in [currencies.json](https://core.telegram.org/bots/payments/currencies.json), it shows the number of digits past the decimal point for each currency (2 for the majority of currencies). Defaults to 0
	MaxTipAmount *int `json:"max_tip_amount,omitempty"`

	// Pass *True*, if you require the user's email address to complete the order
	NeedEmail *bool `json:"need_email,omitempty"`

	// Pass *True*, if you require the user's full name to complete the order
	NeedName *bool `json:"need_name,omitempty"`

	// Pass *True*, if you require the user's phone number to complete the order
	NeedPhoneNumber *bool `json:"need_phone_number,omitempty"`

	// Pass *True*, if you require the user's shipping address to complete the order
	NeedShippingAddress *bool `json:"need_shipping_address,omitempty"`

	// Bot-defined invoice payload, 1-128 bytes. This will not be displayed to the user, use for your internal processes.
	Payload string `json:"payload"`

	// Photo height
	PhotoHeight *int `json:"photo_height,omitempty"`

	// Photo size in bytes
	PhotoSize *int `json:"photo_size,omitempty"`

	// URL of the product photo for the invoice. Can be a photo of the goods or a marketing image for a service. People like it better when they see what they are paying for.
	PhotoUrl *string `json:"photo_url,omitempty"`

	// Photo width
	PhotoWidth *int `json:"photo_width,omitempty"`

	// Price breakdown, a JSON-serialized list of components (e.g. product price, tax, discount, delivery cost, delivery tax, bonus, etc.)
	Prices []LabeledPrice `json:"prices"`

	// Protects the contents of the sent message from forwarding and saving
	ProtectContent *bool `json:"protect_content,omitempty"`

	// JSON-serialized data about the invoice, which will be shared with the payment provider. A detailed description of required fields should be provided by the payment provider.
	ProviderData *string `json:"provider_data,omitempty"`

	// Payment provider token, obtained via [@BotFather](https://t.me/botfather)
	ProviderToken string `json:"provider_token"`

	// This object represents an [inline keyboard](https://core.telegram.org/bots#inline-keyboards-and-on-the-fly-updating) that appears right next to the message it belongs to.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`

	// If the message is a reply, ID of the original message
	ReplyToMessageId *int `json:"reply_to_message_id,omitempty"`

	// Pass *True*, if the user's email address should be sent to provider
	SendEmailToProvider *bool `json:"send_email_to_provider,omitempty"`

	// Pass *True*, if the user's phone number should be sent to provider
	SendPhoneNumberToProvider *bool `json:"send_phone_number_to_provider,omitempty"`

	// Unique deep-linking parameter. If left empty, **forwarded copies** of the sent message will have a *Pay* button, allowing multiple users to pay directly from the forwarded message, using the same invoice. If non-empty, forwarded copies of the sent message will have a *URL* button with a deep link to the bot (instead of a *Pay* button), with the value used as the start parameter
	StartParameter *string `json:"start_parameter,omitempty"`

	// A JSON-serialized array of suggested amounts of tips in the *smallest units* of the currency (integer, **not** float/double). At most 4 suggested tip amounts can be specified. The suggested tip amounts must be positive, passed in a strictly increased order and must not exceed *max\_tip\_amount*.
	SuggestedTipAmounts *[]int `json:"suggested_tip_amounts,omitempty"`

	// Product name, 1-32 characters
	Title string `json:"title"`
}

// PostSendLocationJSONBody defines parameters for PostSendLocation.
type PostSendLocationJSONBody struct {
	// Pass *True*, if the message should be sent even if the specified replied-to message is not found
	AllowSendingWithoutReply *bool `json:"allow_sending_without_reply,omitempty"`

	// Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)
	ChatId interface{} `json:"chat_id"`

	// Sends the message [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
	DisableNotification *bool `json:"disable_notification,omitempty"`

	// For live locations, a direction in which the user is moving, in degrees. Must be between 1 and 360 if specified.
	Heading *int `json:"heading,omitempty"`

	// The radius of uncertainty for the location, measured in meters; 0-1500
	HorizontalAccuracy *float32 `json:"horizontal_accuracy,omitempty"`

	// Latitude of the location
	Latitude float32 `json:"latitude"`

	// Period in seconds for which the location will be updated (see [Live Locations](https://telegram.org/blog/live-locations), should be between 60 and 86400.
	LivePeriod *int `json:"live_period,omitempty"`

	// Longitude of the location
	Longitude float32 `json:"longitude"`

	// Protects the contents of the sent message from forwarding and saving
	ProtectContent *bool `json:"protect_content,omitempty"`

	// For live locations, a maximum distance for proximity alerts about approaching another chat member, in meters. Must be between 1 and 100000 if specified.
	ProximityAlertRadius *int `json:"proximity_alert_radius,omitempty"`

	// Additional interface options. A JSON-serialized object for an [inline keyboard](https://core.telegram.org/bots#inline-keyboards-and-on-the-fly-updating), [custom reply keyboard](https://core.telegram.org/bots#keyboards), instructions to remove reply keyboard or to force a reply from the user.
	ReplyMarkup *interface{} `json:"reply_markup,omitempty"`

	// If the message is a reply, ID of the original message
	ReplyToMessageId *int `json:"reply_to_message_id,omitempty"`
}

// PostSendMessageJSONBody defines parameters for PostSendMessage.
type PostSendMessageJSONBody struct {
	// Pass *True*, if the message should be sent even if the specified replied-to message is not found
	AllowSendingWithoutReply *bool `json:"allow_sending_without_reply,omitempty"`

	// Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)
	ChatId interface{} `json:"chat_id"`

	// Sends the message [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
	DisableNotification *bool `json:"disable_notification,omitempty"`

	// Disables link previews for links in this message
	DisableWebPagePreview *bool `json:"disable_web_page_preview,omitempty"`

	// A JSON-serialized list of special entities that appear in message text, which can be specified instead of *parse\_mode*
	Entities *[]MessageEntity `json:"entities,omitempty"`

	// Mode for parsing entities in the message text. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
	ParseMode *string `json:"parse_mode,omitempty"`

	// Protects the contents of the sent message from forwarding and saving
	ProtectContent *bool `json:"protect_content,omitempty"`

	// Additional interface options. A JSON-serialized object for an [inline keyboard](https://core.telegram.org/bots#inline-keyboards-and-on-the-fly-updating), [custom reply keyboard](https://core.telegram.org/bots#keyboards), instructions to remove reply keyboard or to force a reply from the user.
	ReplyMarkup *interface{} `json:"reply_markup,omitempty"`

	// If the message is a reply, ID of the original message
	ReplyToMessageId *int `json:"reply_to_message_id,omitempty"`

	// Text of the message to be sent, 1-4096 characters after entities parsing
	Text string `json:"text"`
}

// PostSendPollJSONBody defines parameters for PostSendPoll.
type PostSendPollJSONBody struct {
	// Pass *True*, if the message should be sent even if the specified replied-to message is not found
	AllowSendingWithoutReply *bool `json:"allow_sending_without_reply,omitempty"`

	// *True*, if the poll allows multiple answers, ignored for polls in quiz mode, defaults to *False*
	AllowsMultipleAnswers *bool `json:"allows_multiple_answers,omitempty"`

	// Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)
	ChatId interface{} `json:"chat_id"`

	// Point in time (Unix timestamp) when the poll will be automatically closed. Must be at least 5 and no more than 600 seconds in the future. Can't be used together with *open\_period*.
	CloseDate *int `json:"close_date,omitempty"`

	// 0-based identifier of the correct answer option, required for polls in quiz mode
	CorrectOptionId *int `json:"correct_option_id,omitempty"`

	// Sends the message [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
	DisableNotification *bool `json:"disable_notification,omitempty"`

	// Text that is shown when a user chooses an incorrect answer or taps on the lamp icon in a quiz-style poll, 0-200 characters with at most 2 line feeds after entities parsing
	Explanation *string `json:"explanation,omitempty"`

	// A JSON-serialized list of special entities that appear in the poll explanation, which can be specified instead of *parse\_mode*
	ExplanationEntities *[]MessageEntity `json:"explanation_entities,omitempty"`

	// Mode for parsing entities in the explanation. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
	ExplanationParseMode *string `json:"explanation_parse_mode,omitempty"`

	// *True*, if the poll needs to be anonymous, defaults to *True*
	IsAnonymous *bool `json:"is_anonymous,omitempty"`

	// Pass *True*, if the poll needs to be immediately closed. This can be useful for poll preview.
	IsClosed *bool `json:"is_closed,omitempty"`

	// Amount of time in seconds the poll will be active after creation, 5-600. Can't be used together with *close\_date*.
	OpenPeriod *int `json:"open_period,omitempty"`

	// A JSON-serialized list of answer options, 2-10 strings 1-100 characters each
	Options []string `json:"options"`

	// Protects the contents of the sent message from forwarding and saving
	ProtectContent *bool `json:"protect_content,omitempty"`

	// Poll question, 1-300 characters
	Question string `json:"question"`

	// Additional interface options. A JSON-serialized object for an [inline keyboard](https://core.telegram.org/bots#inline-keyboards-and-on-the-fly-updating), [custom reply keyboard](https://core.telegram.org/bots#keyboards), instructions to remove reply keyboard or to force a reply from the user.
	ReplyMarkup *interface{} `json:"reply_markup,omitempty"`

	// If the message is a reply, ID of the original message
	ReplyToMessageId *int `json:"reply_to_message_id,omitempty"`

	// Poll type, ‚Äúquiz‚Äù or ‚Äúregular‚Äù, defaults to ‚Äúregular‚Äù
	Type *PostSendPollJSONBodyType `json:"type,omitempty"`
}

// PostSendPollJSONBodyType defines parameters for PostSendPoll.
type PostSendPollJSONBodyType string

// PostSendVenueJSONBody defines parameters for PostSendVenue.
type PostSendVenueJSONBody struct {
	// Address of the venue
	Address string `json:"address"`

	// Pass *True*, if the message should be sent even if the specified replied-to message is not found
	AllowSendingWithoutReply *bool `json:"allow_sending_without_reply,omitempty"`

	// Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)
	ChatId interface{} `json:"chat_id"`

	// Sends the message [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
	DisableNotification *bool `json:"disable_notification,omitempty"`

	// Foursquare identifier of the venue
	FoursquareId *string `json:"foursquare_id,omitempty"`

	// Foursquare type of the venue, if known. (For example, ‚Äúarts\_entertainment/default‚Äù, ‚Äúarts\_entertainment/aquarium‚Äù or ‚Äúfood/icecream‚Äù.)
	FoursquareType *string `json:"foursquare_type,omitempty"`

	// Google Places identifier of the venue
	GooglePlaceId *string `json:"google_place_id,omitempty"`

	// Google Places type of the venue. (See [supported types](https://developers.google.com/places/web-service/supported_types).)
	GooglePlaceType *string `json:"google_place_type,omitempty"`

	// Latitude of the venue
	Latitude float32 `json:"latitude"`

	// Longitude of the venue
	Longitude float32 `json:"longitude"`

	// Protects the contents of the sent message from forwarding and saving
	ProtectContent *bool `json:"protect_content,omitempty"`

	// Additional interface options. A JSON-serialized object for an [inline keyboard](https://core.telegram.org/bots#inline-keyboards-and-on-the-fly-updating), [custom reply keyboard](https://core.telegram.org/bots#keyboards), instructions to remove reply keyboard or to force a reply from the user.
	ReplyMarkup *interface{} `json:"reply_markup,omitempty"`

	// If the message is a reply, ID of the original message
	ReplyToMessageId *int `json:"reply_to_message_id,omitempty"`

	// Name of the venue
	Title string `json:"title"`
}

// PostSetChatAdministratorCustomTitleJSONBody defines parameters for PostSetChatAdministratorCustomTitle.
type PostSetChatAdministratorCustomTitleJSONBody struct {
	// Unique identifier for the target chat or username of the target supergroup (in the format `@supergroupusername`)
	ChatId interface{} `json:"chat_id"`

	// New custom title for the administrator; 0-16 characters, emoji are not allowed
	CustomTitle string `json:"custom_title"`

	// Unique identifier of the target user
	UserId int `json:"user_id"`
}

// PostSetChatDescriptionJSONBody defines parameters for PostSetChatDescription.
type PostSetChatDescriptionJSONBody struct {
	// Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)
	ChatId interface{} `json:"chat_id"`

	// New chat description, 0-255 characters
	Description *string `json:"description,omitempty"`
}

// PostSetChatMenuButtonJSONBody defines parameters for PostSetChatMenuButton.
type PostSetChatMenuButtonJSONBody struct {
	// Unique identifier for the target private chat. If not specified, default bot's menu button will be changed
	ChatId *int `json:"chat_id,omitempty"`

	// This object describes the bot's menu button in a private chat. It should be one of
	//
	// * [MenuButtonCommands](https://core.telegram.org/bots/api/#menubuttoncommands)
	// * [MenuButtonWebApp](https://core.telegram.org/bots/api/#menubuttonwebapp)
	// * [MenuButtonDefault](https://core.telegram.org/bots/api/#menubuttondefault)
	MenuButton *MenuButton `json:"menu_button,omitempty"`
}

// PostSetChatPermissionsJSONBody defines parameters for PostSetChatPermissions.
type PostSetChatPermissionsJSONBody struct {
	// Unique identifier for the target chat or username of the target supergroup (in the format `@supergroupusername`)
	ChatId interface{} `json:"chat_id"`

	// Describes actions that a non-administrator user is allowed to take in a chat.
	Permissions ChatPermissions `json:"permissions"`
}

// PostSetChatStickerSetJSONBody defines parameters for PostSetChatStickerSet.
type PostSetChatStickerSetJSONBody struct {
	// Unique identifier for the target chat or username of the target supergroup (in the format `@supergroupusername`)
	ChatId interface{} `json:"chat_id"`

	// Name of the sticker set to be set as the group sticker set
	StickerSetName string `json:"sticker_set_name"`
}

// PostSetChatTitleJSONBody defines parameters for PostSetChatTitle.
type PostSetChatTitleJSONBody struct {
	// Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)
	ChatId interface{} `json:"chat_id"`

	// New chat title, 1-255 characters
	Title string `json:"title"`
}

// PostSetGameScoreJSONBody defines parameters for PostSetGameScore.
type PostSetGameScoreJSONBody struct {
	// Required if *inline\_message\_id* is not specified. Unique identifier for the target chat
	ChatId *int `json:"chat_id,omitempty"`

	// Pass *True*, if the game message should not be automatically edited to include the current scoreboard
	DisableEditMessage *bool `json:"disable_edit_message,omitempty"`

	// Pass *True*, if the high score is allowed to decrease. This can be useful when fixing mistakes or banning cheaters
	Force *bool `json:"force,omitempty"`

	// Required if *chat\_id* and *message\_id* are not specified. Identifier of the inline message
	InlineMessageId *string `json:"inline_message_id,omitempty"`

	// Required if *inline\_message\_id* is not specified. Identifier of the sent message
	MessageId *int `json:"message_id,omitempty"`

	// New score, must be non-negative
	Score int `json:"score"`

	// User identifier
	UserId int `json:"user_id"`
}

// PostSetMyCommandsJSONBody defines parameters for PostSetMyCommands.
type PostSetMyCommandsJSONBody struct {
	// A JSON-serialized list of bot commands to be set as the list of the bot's commands. At most 100 commands can be specified.
	Commands []BotCommand `json:"commands"`

	// A two-letter ISO 639-1 language code. If empty, commands will be applied to all users from the given scope, for whose language there are no dedicated commands
	LanguageCode *string `json:"language_code,omitempty"`

	// This object represents the scope to which bot commands are applied. Currently, the following 7 scopes are supported:
	//
	// * [BotCommandScopeDefault](https://core.telegram.org/bots/api/#botcommandscopedefault)
	// * [BotCommandScopeAllPrivateChats](https://core.telegram.org/bots/api/#botcommandscopeallprivatechats)
	// * [BotCommandScopeAllGroupChats](https://core.telegram.org/bots/api/#botcommandscopeallgroupchats)
	// * [BotCommandScopeAllChatAdministrators](https://core.telegram.org/bots/api/#botcommandscopeallchatadministrators)
	// * [BotCommandScopeChat](https://core.telegram.org/bots/api/#botcommandscopechat)
	// * [BotCommandScopeChatAdministrators](https://core.telegram.org/bots/api/#botcommandscopechatadministrators)
	// * [BotCommandScopeChatMember](https://core.telegram.org/bots/api/#botcommandscopechatmember)
	Scope *BotCommandScope `json:"scope,omitempty"`
}

// PostSetMyDefaultAdministratorRightsJSONBody defines parameters for PostSetMyDefaultAdministratorRights.
type PostSetMyDefaultAdministratorRightsJSONBody struct {
	// Pass *True* to change the default administrator rights of the bot in channels. Otherwise, the default administrator rights of the bot for groups and supergroups will be changed.
	ForChannels *bool `json:"for_channels,omitempty"`

	// Represents the rights of an administrator in a chat.
	Rights *ChatAdministratorRights `json:"rights,omitempty"`
}

// PostSetPassportDataErrorsJSONBody defines parameters for PostSetPassportDataErrors.
type PostSetPassportDataErrorsJSONBody struct {
	// A JSON-serialized array describing the errors
	Errors []PassportElementError `json:"errors"`

	// User identifier
	UserId int `json:"user_id"`
}

// PostSetStickerPositionInSetJSONBody defines parameters for PostSetStickerPositionInSet.
type PostSetStickerPositionInSetJSONBody struct {
	// New sticker position in the set, zero-based
	Position int `json:"position"`

	// File identifier of the sticker
	Sticker string `json:"sticker"`
}

// PostStopMessageLiveLocationJSONBody defines parameters for PostStopMessageLiveLocation.
type PostStopMessageLiveLocationJSONBody struct {
	// Required if *inline\_message\_id* is not specified. Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)
	ChatId *interface{} `json:"chat_id,omitempty"`

	// Required if *chat\_id* and *message\_id* are not specified. Identifier of the inline message
	InlineMessageId *string `json:"inline_message_id,omitempty"`

	// Required if *inline\_message\_id* is not specified. Identifier of the message with live location to stop
	MessageId *int `json:"message_id,omitempty"`

	// This object represents an [inline keyboard](https://core.telegram.org/bots#inline-keyboards-and-on-the-fly-updating) that appears right next to the message it belongs to.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

// PostStopPollJSONBody defines parameters for PostStopPoll.
type PostStopPollJSONBody struct {
	// Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)
	ChatId interface{} `json:"chat_id"`

	// Identifier of the original message with the poll
	MessageId int `json:"message_id"`

	// This object represents an [inline keyboard](https://core.telegram.org/bots#inline-keyboards-and-on-the-fly-updating) that appears right next to the message it belongs to.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

// PostUnbanChatMemberJSONBody defines parameters for PostUnbanChatMember.
type PostUnbanChatMemberJSONBody struct {
	// Unique identifier for the target group or username of the target supergroup or channel (in the format `@channelusername`)
	ChatId interface{} `json:"chat_id"`

	// Do nothing if the user is not banned
	OnlyIfBanned *bool `json:"only_if_banned,omitempty"`

	// Unique identifier of the target user
	UserId int `json:"user_id"`
}

// PostUnbanChatSenderChatJSONBody defines parameters for PostUnbanChatSenderChat.
type PostUnbanChatSenderChatJSONBody struct {
	// Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)
	ChatId interface{} `json:"chat_id"`

	// Unique identifier of the target sender chat
	SenderChatId int `json:"sender_chat_id"`
}

// PostUnpinAllChatMessagesJSONBody defines parameters for PostUnpinAllChatMessages.
type PostUnpinAllChatMessagesJSONBody struct {
	// Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)
	ChatId interface{} `json:"chat_id"`
}

// PostUnpinChatMessageJSONBody defines parameters for PostUnpinChatMessage.
type PostUnpinChatMessageJSONBody struct {
	// Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)
	ChatId interface{} `json:"chat_id"`

	// Identifier of a message to unpin. If not specified, the most recent pinned message (by sending date) will be unpinned.
	MessageId *int `json:"message_id,omitempty"`
}

// PostAnswerCallbackQueryJSONRequestBody defines body for PostAnswerCallbackQuery for application/json ContentType.
type PostAnswerCallbackQueryJSONRequestBody PostAnswerCallbackQueryJSONBody

// PostAnswerInlineQueryJSONRequestBody defines body for PostAnswerInlineQuery for application/json ContentType.
type PostAnswerInlineQueryJSONRequestBody PostAnswerInlineQueryJSONBody

// PostAnswerPreCheckoutQueryJSONRequestBody defines body for PostAnswerPreCheckoutQuery for application/json ContentType.
type PostAnswerPreCheckoutQueryJSONRequestBody PostAnswerPreCheckoutQueryJSONBody

// PostAnswerShippingQueryJSONRequestBody defines body for PostAnswerShippingQuery for application/json ContentType.
type PostAnswerShippingQueryJSONRequestBody PostAnswerShippingQueryJSONBody

// PostAnswerWebAppQueryJSONRequestBody defines body for PostAnswerWebAppQuery for application/json ContentType.
type PostAnswerWebAppQueryJSONRequestBody PostAnswerWebAppQueryJSONBody

// PostApproveChatJoinRequestJSONRequestBody defines body for PostApproveChatJoinRequest for application/json ContentType.
type PostApproveChatJoinRequestJSONRequestBody PostApproveChatJoinRequestJSONBody

// PostBanChatMemberJSONRequestBody defines body for PostBanChatMember for application/json ContentType.
type PostBanChatMemberJSONRequestBody PostBanChatMemberJSONBody

// PostBanChatSenderChatJSONRequestBody defines body for PostBanChatSenderChat for application/json ContentType.
type PostBanChatSenderChatJSONRequestBody PostBanChatSenderChatJSONBody

// PostCopyMessageJSONRequestBody defines body for PostCopyMessage for application/json ContentType.
type PostCopyMessageJSONRequestBody PostCopyMessageJSONBody

// PostCreateChatInviteLinkJSONRequestBody defines body for PostCreateChatInviteLink for application/json ContentType.
type PostCreateChatInviteLinkJSONRequestBody PostCreateChatInviteLinkJSONBody

// PostCreateInvoiceLinkJSONRequestBody defines body for PostCreateInvoiceLink for application/json ContentType.
type PostCreateInvoiceLinkJSONRequestBody PostCreateInvoiceLinkJSONBody

// PostDeclineChatJoinRequestJSONRequestBody defines body for PostDeclineChatJoinRequest for application/json ContentType.
type PostDeclineChatJoinRequestJSONRequestBody PostDeclineChatJoinRequestJSONBody

// PostDeleteChatPhotoJSONRequestBody defines body for PostDeleteChatPhoto for application/json ContentType.
type PostDeleteChatPhotoJSONRequestBody PostDeleteChatPhotoJSONBody

// PostDeleteChatStickerSetJSONRequestBody defines body for PostDeleteChatStickerSet for application/json ContentType.
type PostDeleteChatStickerSetJSONRequestBody PostDeleteChatStickerSetJSONBody

// PostDeleteMessageJSONRequestBody defines body for PostDeleteMessage for application/json ContentType.
type PostDeleteMessageJSONRequestBody PostDeleteMessageJSONBody

// PostDeleteMyCommandsJSONRequestBody defines body for PostDeleteMyCommands for application/json ContentType.
type PostDeleteMyCommandsJSONRequestBody PostDeleteMyCommandsJSONBody

// PostDeleteStickerFromSetJSONRequestBody defines body for PostDeleteStickerFromSet for application/json ContentType.
type PostDeleteStickerFromSetJSONRequestBody PostDeleteStickerFromSetJSONBody

// PostDeleteWebhookJSONRequestBody defines body for PostDeleteWebhook for application/json ContentType.
type PostDeleteWebhookJSONRequestBody PostDeleteWebhookJSONBody

// PostEditChatInviteLinkJSONRequestBody defines body for PostEditChatInviteLink for application/json ContentType.
type PostEditChatInviteLinkJSONRequestBody PostEditChatInviteLinkJSONBody

// PostEditMessageCaptionJSONRequestBody defines body for PostEditMessageCaption for application/json ContentType.
type PostEditMessageCaptionJSONRequestBody PostEditMessageCaptionJSONBody

// PostEditMessageLiveLocationJSONRequestBody defines body for PostEditMessageLiveLocation for application/json ContentType.
type PostEditMessageLiveLocationJSONRequestBody PostEditMessageLiveLocationJSONBody

// PostEditMessageReplyMarkupJSONRequestBody defines body for PostEditMessageReplyMarkup for application/json ContentType.
type PostEditMessageReplyMarkupJSONRequestBody PostEditMessageReplyMarkupJSONBody

// PostEditMessageTextJSONRequestBody defines body for PostEditMessageText for application/json ContentType.
type PostEditMessageTextJSONRequestBody PostEditMessageTextJSONBody

// PostExportChatInviteLinkJSONRequestBody defines body for PostExportChatInviteLink for application/json ContentType.
type PostExportChatInviteLinkJSONRequestBody PostExportChatInviteLinkJSONBody

// PostForwardMessageJSONRequestBody defines body for PostForwardMessage for application/json ContentType.
type PostForwardMessageJSONRequestBody PostForwardMessageJSONBody

// PostGetChatJSONRequestBody defines body for PostGetChat for application/json ContentType.
type PostGetChatJSONRequestBody PostGetChatJSONBody

// PostGetChatAdministratorsJSONRequestBody defines body for PostGetChatAdministrators for application/json ContentType.
type PostGetChatAdministratorsJSONRequestBody PostGetChatAdministratorsJSONBody

// PostGetChatMemberJSONRequestBody defines body for PostGetChatMember for application/json ContentType.
type PostGetChatMemberJSONRequestBody PostGetChatMemberJSONBody

// PostGetChatMemberCountJSONRequestBody defines body for PostGetChatMemberCount for application/json ContentType.
type PostGetChatMemberCountJSONRequestBody PostGetChatMemberCountJSONBody

// PostGetChatMenuButtonJSONRequestBody defines body for PostGetChatMenuButton for application/json ContentType.
type PostGetChatMenuButtonJSONRequestBody PostGetChatMenuButtonJSONBody

// PostGetFileJSONRequestBody defines body for PostGetFile for application/json ContentType.
type PostGetFileJSONRequestBody PostGetFileJSONBody

// PostGetGameHighScoresJSONRequestBody defines body for PostGetGameHighScores for application/json ContentType.
type PostGetGameHighScoresJSONRequestBody PostGetGameHighScoresJSONBody

// PostGetMyCommandsJSONRequestBody defines body for PostGetMyCommands for application/json ContentType.
type PostGetMyCommandsJSONRequestBody PostGetMyCommandsJSONBody

// PostGetMyDefaultAdministratorRightsJSONRequestBody defines body for PostGetMyDefaultAdministratorRights for application/json ContentType.
type PostGetMyDefaultAdministratorRightsJSONRequestBody PostGetMyDefaultAdministratorRightsJSONBody

// PostGetStickerSetJSONRequestBody defines body for PostGetStickerSet for application/json ContentType.
type PostGetStickerSetJSONRequestBody PostGetStickerSetJSONBody

// PostGetUpdatesJSONRequestBody defines body for PostGetUpdates for application/json ContentType.
type PostGetUpdatesJSONRequestBody PostGetUpdatesJSONBody

// PostGetUserProfilePhotosJSONRequestBody defines body for PostGetUserProfilePhotos for application/json ContentType.
type PostGetUserProfilePhotosJSONRequestBody PostGetUserProfilePhotosJSONBody

// PostLeaveChatJSONRequestBody defines body for PostLeaveChat for application/json ContentType.
type PostLeaveChatJSONRequestBody PostLeaveChatJSONBody

// PostPinChatMessageJSONRequestBody defines body for PostPinChatMessage for application/json ContentType.
type PostPinChatMessageJSONRequestBody PostPinChatMessageJSONBody

// PostPromoteChatMemberJSONRequestBody defines body for PostPromoteChatMember for application/json ContentType.
type PostPromoteChatMemberJSONRequestBody PostPromoteChatMemberJSONBody

// PostRestrictChatMemberJSONRequestBody defines body for PostRestrictChatMember for application/json ContentType.
type PostRestrictChatMemberJSONRequestBody PostRestrictChatMemberJSONBody

// PostRevokeChatInviteLinkJSONRequestBody defines body for PostRevokeChatInviteLink for application/json ContentType.
type PostRevokeChatInviteLinkJSONRequestBody PostRevokeChatInviteLinkJSONBody

// PostSendChatActionJSONRequestBody defines body for PostSendChatAction for application/json ContentType.
type PostSendChatActionJSONRequestBody PostSendChatActionJSONBody

// PostSendContactJSONRequestBody defines body for PostSendContact for application/json ContentType.
type PostSendContactJSONRequestBody PostSendContactJSONBody

// PostSendDiceJSONRequestBody defines body for PostSendDice for application/json ContentType.
type PostSendDiceJSONRequestBody PostSendDiceJSONBody

// PostSendGameJSONRequestBody defines body for PostSendGame for application/json ContentType.
type PostSendGameJSONRequestBody PostSendGameJSONBody

// PostSendInvoiceJSONRequestBody defines body for PostSendInvoice for application/json ContentType.
type PostSendInvoiceJSONRequestBody PostSendInvoiceJSONBody

// PostSendLocationJSONRequestBody defines body for PostSendLocation for application/json ContentType.
type PostSendLocationJSONRequestBody PostSendLocationJSONBody

// PostSendMessageJSONRequestBody defines body for PostSendMessage for application/json ContentType.
type PostSendMessageJSONRequestBody PostSendMessageJSONBody

// PostSendPollJSONRequestBody defines body for PostSendPoll for application/json ContentType.
type PostSendPollJSONRequestBody PostSendPollJSONBody

// PostSendVenueJSONRequestBody defines body for PostSendVenue for application/json ContentType.
type PostSendVenueJSONRequestBody PostSendVenueJSONBody

// PostSetChatAdministratorCustomTitleJSONRequestBody defines body for PostSetChatAdministratorCustomTitle for application/json ContentType.
type PostSetChatAdministratorCustomTitleJSONRequestBody PostSetChatAdministratorCustomTitleJSONBody

// PostSetChatDescriptionJSONRequestBody defines body for PostSetChatDescription for application/json ContentType.
type PostSetChatDescriptionJSONRequestBody PostSetChatDescriptionJSONBody

// PostSetChatMenuButtonJSONRequestBody defines body for PostSetChatMenuButton for application/json ContentType.
type PostSetChatMenuButtonJSONRequestBody PostSetChatMenuButtonJSONBody

// PostSetChatPermissionsJSONRequestBody defines body for PostSetChatPermissions for application/json ContentType.
type PostSetChatPermissionsJSONRequestBody PostSetChatPermissionsJSONBody

// PostSetChatStickerSetJSONRequestBody defines body for PostSetChatStickerSet for application/json ContentType.
type PostSetChatStickerSetJSONRequestBody PostSetChatStickerSetJSONBody

// PostSetChatTitleJSONRequestBody defines body for PostSetChatTitle for application/json ContentType.
type PostSetChatTitleJSONRequestBody PostSetChatTitleJSONBody

// PostSetGameScoreJSONRequestBody defines body for PostSetGameScore for application/json ContentType.
type PostSetGameScoreJSONRequestBody PostSetGameScoreJSONBody

// PostSetMyCommandsJSONRequestBody defines body for PostSetMyCommands for application/json ContentType.
type PostSetMyCommandsJSONRequestBody PostSetMyCommandsJSONBody

// PostSetMyDefaultAdministratorRightsJSONRequestBody defines body for PostSetMyDefaultAdministratorRights for application/json ContentType.
type PostSetMyDefaultAdministratorRightsJSONRequestBody PostSetMyDefaultAdministratorRightsJSONBody

// PostSetPassportDataErrorsJSONRequestBody defines body for PostSetPassportDataErrors for application/json ContentType.
type PostSetPassportDataErrorsJSONRequestBody PostSetPassportDataErrorsJSONBody

// PostSetStickerPositionInSetJSONRequestBody defines body for PostSetStickerPositionInSet for application/json ContentType.
type PostSetStickerPositionInSetJSONRequestBody PostSetStickerPositionInSetJSONBody

// PostStopMessageLiveLocationJSONRequestBody defines body for PostStopMessageLiveLocation for application/json ContentType.
type PostStopMessageLiveLocationJSONRequestBody PostStopMessageLiveLocationJSONBody

// PostStopPollJSONRequestBody defines body for PostStopPoll for application/json ContentType.
type PostStopPollJSONRequestBody PostStopPollJSONBody

// PostUnbanChatMemberJSONRequestBody defines body for PostUnbanChatMember for application/json ContentType.
type PostUnbanChatMemberJSONRequestBody PostUnbanChatMemberJSONBody

// PostUnbanChatSenderChatJSONRequestBody defines body for PostUnbanChatSenderChat for application/json ContentType.
type PostUnbanChatSenderChatJSONRequestBody PostUnbanChatSenderChatJSONBody

// PostUnpinAllChatMessagesJSONRequestBody defines body for PostUnpinAllChatMessages for application/json ContentType.
type PostUnpinAllChatMessagesJSONRequestBody PostUnpinAllChatMessagesJSONBody

// PostUnpinChatMessageJSONRequestBody defines body for PostUnpinChatMessage for application/json ContentType.
type PostUnpinChatMessageJSONRequestBody PostUnpinChatMessageJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// PostAddStickerToSet request with any body
	PostAddStickerToSetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAnswerCallbackQuery request with any body
	PostAnswerCallbackQueryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAnswerCallbackQuery(ctx context.Context, body PostAnswerCallbackQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAnswerInlineQuery request with any body
	PostAnswerInlineQueryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAnswerInlineQuery(ctx context.Context, body PostAnswerInlineQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAnswerPreCheckoutQuery request with any body
	PostAnswerPreCheckoutQueryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAnswerPreCheckoutQuery(ctx context.Context, body PostAnswerPreCheckoutQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAnswerShippingQuery request with any body
	PostAnswerShippingQueryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAnswerShippingQuery(ctx context.Context, body PostAnswerShippingQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAnswerWebAppQuery request with any body
	PostAnswerWebAppQueryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAnswerWebAppQuery(ctx context.Context, body PostAnswerWebAppQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApproveChatJoinRequest request with any body
	PostApproveChatJoinRequestWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApproveChatJoinRequest(ctx context.Context, body PostApproveChatJoinRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostBanChatMember request with any body
	PostBanChatMemberWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostBanChatMember(ctx context.Context, body PostBanChatMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostBanChatSenderChat request with any body
	PostBanChatSenderChatWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostBanChatSenderChat(ctx context.Context, body PostBanChatSenderChatJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostClose request
	PostClose(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostCopyMessage request with any body
	PostCopyMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCopyMessage(ctx context.Context, body PostCopyMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostCreateChatInviteLink request with any body
	PostCreateChatInviteLinkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCreateChatInviteLink(ctx context.Context, body PostCreateChatInviteLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostCreateInvoiceLink request with any body
	PostCreateInvoiceLinkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCreateInvoiceLink(ctx context.Context, body PostCreateInvoiceLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostCreateNewStickerSet request with any body
	PostCreateNewStickerSetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostDeclineChatJoinRequest request with any body
	PostDeclineChatJoinRequestWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostDeclineChatJoinRequest(ctx context.Context, body PostDeclineChatJoinRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostDeleteChatPhoto request with any body
	PostDeleteChatPhotoWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostDeleteChatPhoto(ctx context.Context, body PostDeleteChatPhotoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostDeleteChatStickerSet request with any body
	PostDeleteChatStickerSetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostDeleteChatStickerSet(ctx context.Context, body PostDeleteChatStickerSetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostDeleteMessage request with any body
	PostDeleteMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostDeleteMessage(ctx context.Context, body PostDeleteMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostDeleteMyCommands request with any body
	PostDeleteMyCommandsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostDeleteMyCommands(ctx context.Context, body PostDeleteMyCommandsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostDeleteStickerFromSet request with any body
	PostDeleteStickerFromSetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostDeleteStickerFromSet(ctx context.Context, body PostDeleteStickerFromSetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostDeleteWebhook request with any body
	PostDeleteWebhookWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostDeleteWebhook(ctx context.Context, body PostDeleteWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostEditChatInviteLink request with any body
	PostEditChatInviteLinkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostEditChatInviteLink(ctx context.Context, body PostEditChatInviteLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostEditMessageCaption request with any body
	PostEditMessageCaptionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostEditMessageCaption(ctx context.Context, body PostEditMessageCaptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostEditMessageLiveLocation request with any body
	PostEditMessageLiveLocationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostEditMessageLiveLocation(ctx context.Context, body PostEditMessageLiveLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostEditMessageMedia request with any body
	PostEditMessageMediaWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostEditMessageReplyMarkup request with any body
	PostEditMessageReplyMarkupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostEditMessageReplyMarkup(ctx context.Context, body PostEditMessageReplyMarkupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostEditMessageText request with any body
	PostEditMessageTextWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostEditMessageText(ctx context.Context, body PostEditMessageTextJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostExportChatInviteLink request with any body
	PostExportChatInviteLinkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostExportChatInviteLink(ctx context.Context, body PostExportChatInviteLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostForwardMessage request with any body
	PostForwardMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostForwardMessage(ctx context.Context, body PostForwardMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostGetChat request with any body
	PostGetChatWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostGetChat(ctx context.Context, body PostGetChatJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostGetChatAdministrators request with any body
	PostGetChatAdministratorsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostGetChatAdministrators(ctx context.Context, body PostGetChatAdministratorsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostGetChatMember request with any body
	PostGetChatMemberWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostGetChatMember(ctx context.Context, body PostGetChatMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostGetChatMemberCount request with any body
	PostGetChatMemberCountWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostGetChatMemberCount(ctx context.Context, body PostGetChatMemberCountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostGetChatMenuButton request with any body
	PostGetChatMenuButtonWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostGetChatMenuButton(ctx context.Context, body PostGetChatMenuButtonJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostGetFile request with any body
	PostGetFileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostGetFile(ctx context.Context, body PostGetFileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostGetGameHighScores request with any body
	PostGetGameHighScoresWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostGetGameHighScores(ctx context.Context, body PostGetGameHighScoresJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostGetMe request
	PostGetMe(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostGetMyCommands request with any body
	PostGetMyCommandsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostGetMyCommands(ctx context.Context, body PostGetMyCommandsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostGetMyDefaultAdministratorRights request with any body
	PostGetMyDefaultAdministratorRightsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostGetMyDefaultAdministratorRights(ctx context.Context, body PostGetMyDefaultAdministratorRightsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostGetStickerSet request with any body
	PostGetStickerSetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostGetStickerSet(ctx context.Context, body PostGetStickerSetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostGetUpdates request with any body
	PostGetUpdatesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostGetUpdates(ctx context.Context, body PostGetUpdatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostGetUserProfilePhotos request with any body
	PostGetUserProfilePhotosWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostGetUserProfilePhotos(ctx context.Context, body PostGetUserProfilePhotosJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostGetWebhookInfo request
	PostGetWebhookInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostLeaveChat request with any body
	PostLeaveChatWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostLeaveChat(ctx context.Context, body PostLeaveChatJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostLogOut request
	PostLogOut(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostPinChatMessage request with any body
	PostPinChatMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostPinChatMessage(ctx context.Context, body PostPinChatMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostPromoteChatMember request with any body
	PostPromoteChatMemberWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostPromoteChatMember(ctx context.Context, body PostPromoteChatMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostRestrictChatMember request with any body
	PostRestrictChatMemberWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostRestrictChatMember(ctx context.Context, body PostRestrictChatMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostRevokeChatInviteLink request with any body
	PostRevokeChatInviteLinkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostRevokeChatInviteLink(ctx context.Context, body PostRevokeChatInviteLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSendAnimation request with any body
	PostSendAnimationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSendAudio request with any body
	PostSendAudioWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSendChatAction request with any body
	PostSendChatActionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSendChatAction(ctx context.Context, body PostSendChatActionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSendContact request with any body
	PostSendContactWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSendContact(ctx context.Context, body PostSendContactJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSendDice request with any body
	PostSendDiceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSendDice(ctx context.Context, body PostSendDiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSendDocument request with any body
	PostSendDocumentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSendGame request with any body
	PostSendGameWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSendGame(ctx context.Context, body PostSendGameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSendInvoice request with any body
	PostSendInvoiceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSendInvoice(ctx context.Context, body PostSendInvoiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSendLocation request with any body
	PostSendLocationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSendLocation(ctx context.Context, body PostSendLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSendMediaGroup request with any body
	PostSendMediaGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSendMessage request with any body
	PostSendMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSendMessage(ctx context.Context, body PostSendMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSendPhoto request with any body
	PostSendPhotoWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSendPoll request with any body
	PostSendPollWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSendPoll(ctx context.Context, body PostSendPollJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSendSticker request with any body
	PostSendStickerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSendVenue request with any body
	PostSendVenueWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSendVenue(ctx context.Context, body PostSendVenueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSendVideo request with any body
	PostSendVideoWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSendVideoNote request with any body
	PostSendVideoNoteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSendVoice request with any body
	PostSendVoiceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSetChatAdministratorCustomTitle request with any body
	PostSetChatAdministratorCustomTitleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSetChatAdministratorCustomTitle(ctx context.Context, body PostSetChatAdministratorCustomTitleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSetChatDescription request with any body
	PostSetChatDescriptionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSetChatDescription(ctx context.Context, body PostSetChatDescriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSetChatMenuButton request with any body
	PostSetChatMenuButtonWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSetChatMenuButton(ctx context.Context, body PostSetChatMenuButtonJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSetChatPermissions request with any body
	PostSetChatPermissionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSetChatPermissions(ctx context.Context, body PostSetChatPermissionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSetChatPhoto request with any body
	PostSetChatPhotoWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSetChatStickerSet request with any body
	PostSetChatStickerSetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSetChatStickerSet(ctx context.Context, body PostSetChatStickerSetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSetChatTitle request with any body
	PostSetChatTitleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSetChatTitle(ctx context.Context, body PostSetChatTitleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSetGameScore request with any body
	PostSetGameScoreWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSetGameScore(ctx context.Context, body PostSetGameScoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSetMyCommands request with any body
	PostSetMyCommandsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSetMyCommands(ctx context.Context, body PostSetMyCommandsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSetMyDefaultAdministratorRights request with any body
	PostSetMyDefaultAdministratorRightsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSetMyDefaultAdministratorRights(ctx context.Context, body PostSetMyDefaultAdministratorRightsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSetPassportDataErrors request with any body
	PostSetPassportDataErrorsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSetPassportDataErrors(ctx context.Context, body PostSetPassportDataErrorsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSetStickerPositionInSet request with any body
	PostSetStickerPositionInSetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSetStickerPositionInSet(ctx context.Context, body PostSetStickerPositionInSetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSetStickerSetThumb request with any body
	PostSetStickerSetThumbWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSetWebhook request with any body
	PostSetWebhookWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostStopMessageLiveLocation request with any body
	PostStopMessageLiveLocationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostStopMessageLiveLocation(ctx context.Context, body PostStopMessageLiveLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostStopPoll request with any body
	PostStopPollWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostStopPoll(ctx context.Context, body PostStopPollJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostUnbanChatMember request with any body
	PostUnbanChatMemberWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostUnbanChatMember(ctx context.Context, body PostUnbanChatMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostUnbanChatSenderChat request with any body
	PostUnbanChatSenderChatWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostUnbanChatSenderChat(ctx context.Context, body PostUnbanChatSenderChatJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostUnpinAllChatMessages request with any body
	PostUnpinAllChatMessagesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostUnpinAllChatMessages(ctx context.Context, body PostUnpinAllChatMessagesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostUnpinChatMessage request with any body
	PostUnpinChatMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostUnpinChatMessage(ctx context.Context, body PostUnpinChatMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostUploadStickerFile request with any body
	PostUploadStickerFileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) PostAddStickerToSetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAddStickerToSetRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAnswerCallbackQueryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAnswerCallbackQueryRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAnswerCallbackQuery(ctx context.Context, body PostAnswerCallbackQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAnswerCallbackQueryRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAnswerInlineQueryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAnswerInlineQueryRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAnswerInlineQuery(ctx context.Context, body PostAnswerInlineQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAnswerInlineQueryRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAnswerPreCheckoutQueryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAnswerPreCheckoutQueryRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAnswerPreCheckoutQuery(ctx context.Context, body PostAnswerPreCheckoutQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAnswerPreCheckoutQueryRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAnswerShippingQueryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAnswerShippingQueryRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAnswerShippingQuery(ctx context.Context, body PostAnswerShippingQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAnswerShippingQueryRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAnswerWebAppQueryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAnswerWebAppQueryRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAnswerWebAppQuery(ctx context.Context, body PostAnswerWebAppQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAnswerWebAppQueryRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApproveChatJoinRequestWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApproveChatJoinRequestRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApproveChatJoinRequest(ctx context.Context, body PostApproveChatJoinRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApproveChatJoinRequestRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostBanChatMemberWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostBanChatMemberRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostBanChatMember(ctx context.Context, body PostBanChatMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostBanChatMemberRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostBanChatSenderChatWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostBanChatSenderChatRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostBanChatSenderChat(ctx context.Context, body PostBanChatSenderChatJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostBanChatSenderChatRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostClose(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCloseRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCopyMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCopyMessageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCopyMessage(ctx context.Context, body PostCopyMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCopyMessageRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCreateChatInviteLinkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCreateChatInviteLinkRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCreateChatInviteLink(ctx context.Context, body PostCreateChatInviteLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCreateChatInviteLinkRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCreateInvoiceLinkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCreateInvoiceLinkRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCreateInvoiceLink(ctx context.Context, body PostCreateInvoiceLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCreateInvoiceLinkRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCreateNewStickerSetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCreateNewStickerSetRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDeclineChatJoinRequestWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDeclineChatJoinRequestRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDeclineChatJoinRequest(ctx context.Context, body PostDeclineChatJoinRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDeclineChatJoinRequestRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDeleteChatPhotoWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDeleteChatPhotoRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDeleteChatPhoto(ctx context.Context, body PostDeleteChatPhotoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDeleteChatPhotoRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDeleteChatStickerSetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDeleteChatStickerSetRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDeleteChatStickerSet(ctx context.Context, body PostDeleteChatStickerSetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDeleteChatStickerSetRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDeleteMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDeleteMessageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDeleteMessage(ctx context.Context, body PostDeleteMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDeleteMessageRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDeleteMyCommandsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDeleteMyCommandsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDeleteMyCommands(ctx context.Context, body PostDeleteMyCommandsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDeleteMyCommandsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDeleteStickerFromSetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDeleteStickerFromSetRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDeleteStickerFromSet(ctx context.Context, body PostDeleteStickerFromSetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDeleteStickerFromSetRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDeleteWebhookWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDeleteWebhookRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDeleteWebhook(ctx context.Context, body PostDeleteWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDeleteWebhookRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostEditChatInviteLinkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostEditChatInviteLinkRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostEditChatInviteLink(ctx context.Context, body PostEditChatInviteLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostEditChatInviteLinkRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostEditMessageCaptionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostEditMessageCaptionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostEditMessageCaption(ctx context.Context, body PostEditMessageCaptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostEditMessageCaptionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostEditMessageLiveLocationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostEditMessageLiveLocationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostEditMessageLiveLocation(ctx context.Context, body PostEditMessageLiveLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostEditMessageLiveLocationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostEditMessageMediaWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostEditMessageMediaRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostEditMessageReplyMarkupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostEditMessageReplyMarkupRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostEditMessageReplyMarkup(ctx context.Context, body PostEditMessageReplyMarkupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostEditMessageReplyMarkupRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostEditMessageTextWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostEditMessageTextRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostEditMessageText(ctx context.Context, body PostEditMessageTextJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostEditMessageTextRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostExportChatInviteLinkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostExportChatInviteLinkRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostExportChatInviteLink(ctx context.Context, body PostExportChatInviteLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostExportChatInviteLinkRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostForwardMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostForwardMessageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostForwardMessage(ctx context.Context, body PostForwardMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostForwardMessageRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostGetChatWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostGetChatRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostGetChat(ctx context.Context, body PostGetChatJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostGetChatRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostGetChatAdministratorsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostGetChatAdministratorsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostGetChatAdministrators(ctx context.Context, body PostGetChatAdministratorsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostGetChatAdministratorsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostGetChatMemberWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostGetChatMemberRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostGetChatMember(ctx context.Context, body PostGetChatMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostGetChatMemberRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostGetChatMemberCountWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostGetChatMemberCountRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostGetChatMemberCount(ctx context.Context, body PostGetChatMemberCountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostGetChatMemberCountRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostGetChatMenuButtonWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostGetChatMenuButtonRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostGetChatMenuButton(ctx context.Context, body PostGetChatMenuButtonJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostGetChatMenuButtonRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostGetFileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostGetFileRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostGetFile(ctx context.Context, body PostGetFileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostGetFileRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostGetGameHighScoresWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostGetGameHighScoresRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostGetGameHighScores(ctx context.Context, body PostGetGameHighScoresJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostGetGameHighScoresRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostGetMe(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostGetMeRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostGetMyCommandsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostGetMyCommandsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostGetMyCommands(ctx context.Context, body PostGetMyCommandsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostGetMyCommandsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostGetMyDefaultAdministratorRightsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostGetMyDefaultAdministratorRightsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostGetMyDefaultAdministratorRights(ctx context.Context, body PostGetMyDefaultAdministratorRightsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostGetMyDefaultAdministratorRightsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostGetStickerSetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostGetStickerSetRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostGetStickerSet(ctx context.Context, body PostGetStickerSetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostGetStickerSetRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostGetUpdatesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostGetUpdatesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostGetUpdates(ctx context.Context, body PostGetUpdatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostGetUpdatesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostGetUserProfilePhotosWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostGetUserProfilePhotosRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostGetUserProfilePhotos(ctx context.Context, body PostGetUserProfilePhotosJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostGetUserProfilePhotosRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostGetWebhookInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostGetWebhookInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostLeaveChatWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostLeaveChatRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostLeaveChat(ctx context.Context, body PostLeaveChatJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostLeaveChatRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostLogOut(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostLogOutRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPinChatMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPinChatMessageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPinChatMessage(ctx context.Context, body PostPinChatMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPinChatMessageRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPromoteChatMemberWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPromoteChatMemberRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPromoteChatMember(ctx context.Context, body PostPromoteChatMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPromoteChatMemberRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRestrictChatMemberWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRestrictChatMemberRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRestrictChatMember(ctx context.Context, body PostRestrictChatMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRestrictChatMemberRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRevokeChatInviteLinkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRevokeChatInviteLinkRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRevokeChatInviteLink(ctx context.Context, body PostRevokeChatInviteLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRevokeChatInviteLinkRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSendAnimationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSendAnimationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSendAudioWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSendAudioRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSendChatActionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSendChatActionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSendChatAction(ctx context.Context, body PostSendChatActionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSendChatActionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSendContactWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSendContactRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSendContact(ctx context.Context, body PostSendContactJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSendContactRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSendDiceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSendDiceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSendDice(ctx context.Context, body PostSendDiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSendDiceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSendDocumentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSendDocumentRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSendGameWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSendGameRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSendGame(ctx context.Context, body PostSendGameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSendGameRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSendInvoiceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSendInvoiceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSendInvoice(ctx context.Context, body PostSendInvoiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSendInvoiceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSendLocationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSendLocationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSendLocation(ctx context.Context, body PostSendLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSendLocationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSendMediaGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSendMediaGroupRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSendMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSendMessageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSendMessage(ctx context.Context, body PostSendMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSendMessageRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSendPhotoWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSendPhotoRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSendPollWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSendPollRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSendPoll(ctx context.Context, body PostSendPollJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSendPollRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSendStickerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSendStickerRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSendVenueWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSendVenueRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSendVenue(ctx context.Context, body PostSendVenueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSendVenueRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSendVideoWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSendVideoRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSendVideoNoteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSendVideoNoteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSendVoiceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSendVoiceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSetChatAdministratorCustomTitleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSetChatAdministratorCustomTitleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSetChatAdministratorCustomTitle(ctx context.Context, body PostSetChatAdministratorCustomTitleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSetChatAdministratorCustomTitleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSetChatDescriptionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSetChatDescriptionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSetChatDescription(ctx context.Context, body PostSetChatDescriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSetChatDescriptionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSetChatMenuButtonWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSetChatMenuButtonRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSetChatMenuButton(ctx context.Context, body PostSetChatMenuButtonJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSetChatMenuButtonRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSetChatPermissionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSetChatPermissionsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSetChatPermissions(ctx context.Context, body PostSetChatPermissionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSetChatPermissionsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSetChatPhotoWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSetChatPhotoRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSetChatStickerSetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSetChatStickerSetRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSetChatStickerSet(ctx context.Context, body PostSetChatStickerSetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSetChatStickerSetRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSetChatTitleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSetChatTitleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSetChatTitle(ctx context.Context, body PostSetChatTitleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSetChatTitleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSetGameScoreWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSetGameScoreRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSetGameScore(ctx context.Context, body PostSetGameScoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSetGameScoreRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSetMyCommandsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSetMyCommandsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSetMyCommands(ctx context.Context, body PostSetMyCommandsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSetMyCommandsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSetMyDefaultAdministratorRightsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSetMyDefaultAdministratorRightsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSetMyDefaultAdministratorRights(ctx context.Context, body PostSetMyDefaultAdministratorRightsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSetMyDefaultAdministratorRightsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSetPassportDataErrorsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSetPassportDataErrorsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSetPassportDataErrors(ctx context.Context, body PostSetPassportDataErrorsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSetPassportDataErrorsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSetStickerPositionInSetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSetStickerPositionInSetRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSetStickerPositionInSet(ctx context.Context, body PostSetStickerPositionInSetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSetStickerPositionInSetRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSetStickerSetThumbWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSetStickerSetThumbRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSetWebhookWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSetWebhookRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostStopMessageLiveLocationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostStopMessageLiveLocationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostStopMessageLiveLocation(ctx context.Context, body PostStopMessageLiveLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostStopMessageLiveLocationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostStopPollWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostStopPollRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostStopPoll(ctx context.Context, body PostStopPollJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostStopPollRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUnbanChatMemberWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUnbanChatMemberRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUnbanChatMember(ctx context.Context, body PostUnbanChatMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUnbanChatMemberRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUnbanChatSenderChatWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUnbanChatSenderChatRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUnbanChatSenderChat(ctx context.Context, body PostUnbanChatSenderChatJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUnbanChatSenderChatRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUnpinAllChatMessagesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUnpinAllChatMessagesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUnpinAllChatMessages(ctx context.Context, body PostUnpinAllChatMessagesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUnpinAllChatMessagesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUnpinChatMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUnpinChatMessageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUnpinChatMessage(ctx context.Context, body PostUnpinChatMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUnpinChatMessageRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUploadStickerFileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUploadStickerFileRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewPostAddStickerToSetRequestWithBody generates requests for PostAddStickerToSet with any type of body
func NewPostAddStickerToSetRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/addStickerToSet")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostAnswerCallbackQueryRequest calls the generic PostAnswerCallbackQuery builder with application/json body
func NewPostAnswerCallbackQueryRequest(server string, body PostAnswerCallbackQueryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAnswerCallbackQueryRequestWithBody(server, "application/json", bodyReader)
}

// NewPostAnswerCallbackQueryRequestWithBody generates requests for PostAnswerCallbackQuery with any type of body
func NewPostAnswerCallbackQueryRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/answerCallbackQuery")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostAnswerInlineQueryRequest calls the generic PostAnswerInlineQuery builder with application/json body
func NewPostAnswerInlineQueryRequest(server string, body PostAnswerInlineQueryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAnswerInlineQueryRequestWithBody(server, "application/json", bodyReader)
}

// NewPostAnswerInlineQueryRequestWithBody generates requests for PostAnswerInlineQuery with any type of body
func NewPostAnswerInlineQueryRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/answerInlineQuery")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostAnswerPreCheckoutQueryRequest calls the generic PostAnswerPreCheckoutQuery builder with application/json body
func NewPostAnswerPreCheckoutQueryRequest(server string, body PostAnswerPreCheckoutQueryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAnswerPreCheckoutQueryRequestWithBody(server, "application/json", bodyReader)
}

// NewPostAnswerPreCheckoutQueryRequestWithBody generates requests for PostAnswerPreCheckoutQuery with any type of body
func NewPostAnswerPreCheckoutQueryRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/answerPreCheckoutQuery")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostAnswerShippingQueryRequest calls the generic PostAnswerShippingQuery builder with application/json body
func NewPostAnswerShippingQueryRequest(server string, body PostAnswerShippingQueryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAnswerShippingQueryRequestWithBody(server, "application/json", bodyReader)
}

// NewPostAnswerShippingQueryRequestWithBody generates requests for PostAnswerShippingQuery with any type of body
func NewPostAnswerShippingQueryRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/answerShippingQuery")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostAnswerWebAppQueryRequest calls the generic PostAnswerWebAppQuery builder with application/json body
func NewPostAnswerWebAppQueryRequest(server string, body PostAnswerWebAppQueryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAnswerWebAppQueryRequestWithBody(server, "application/json", bodyReader)
}

// NewPostAnswerWebAppQueryRequestWithBody generates requests for PostAnswerWebAppQuery with any type of body
func NewPostAnswerWebAppQueryRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/answerWebAppQuery")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostApproveChatJoinRequestRequest calls the generic PostApproveChatJoinRequest builder with application/json body
func NewPostApproveChatJoinRequestRequest(server string, body PostApproveChatJoinRequestJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApproveChatJoinRequestRequestWithBody(server, "application/json", bodyReader)
}

// NewPostApproveChatJoinRequestRequestWithBody generates requests for PostApproveChatJoinRequest with any type of body
func NewPostApproveChatJoinRequestRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/approveChatJoinRequest")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostBanChatMemberRequest calls the generic PostBanChatMember builder with application/json body
func NewPostBanChatMemberRequest(server string, body PostBanChatMemberJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostBanChatMemberRequestWithBody(server, "application/json", bodyReader)
}

// NewPostBanChatMemberRequestWithBody generates requests for PostBanChatMember with any type of body
func NewPostBanChatMemberRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/banChatMember")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostBanChatSenderChatRequest calls the generic PostBanChatSenderChat builder with application/json body
func NewPostBanChatSenderChatRequest(server string, body PostBanChatSenderChatJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostBanChatSenderChatRequestWithBody(server, "application/json", bodyReader)
}

// NewPostBanChatSenderChatRequestWithBody generates requests for PostBanChatSenderChat with any type of body
func NewPostBanChatSenderChatRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/banChatSenderChat")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostCloseRequest generates requests for PostClose
func NewPostCloseRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/close")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostCopyMessageRequest calls the generic PostCopyMessage builder with application/json body
func NewPostCopyMessageRequest(server string, body PostCopyMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCopyMessageRequestWithBody(server, "application/json", bodyReader)
}

// NewPostCopyMessageRequestWithBody generates requests for PostCopyMessage with any type of body
func NewPostCopyMessageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/copyMessage")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostCreateChatInviteLinkRequest calls the generic PostCreateChatInviteLink builder with application/json body
func NewPostCreateChatInviteLinkRequest(server string, body PostCreateChatInviteLinkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCreateChatInviteLinkRequestWithBody(server, "application/json", bodyReader)
}

// NewPostCreateChatInviteLinkRequestWithBody generates requests for PostCreateChatInviteLink with any type of body
func NewPostCreateChatInviteLinkRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/createChatInviteLink")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostCreateInvoiceLinkRequest calls the generic PostCreateInvoiceLink builder with application/json body
func NewPostCreateInvoiceLinkRequest(server string, body PostCreateInvoiceLinkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCreateInvoiceLinkRequestWithBody(server, "application/json", bodyReader)
}

// NewPostCreateInvoiceLinkRequestWithBody generates requests for PostCreateInvoiceLink with any type of body
func NewPostCreateInvoiceLinkRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/createInvoiceLink")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostCreateNewStickerSetRequestWithBody generates requests for PostCreateNewStickerSet with any type of body
func NewPostCreateNewStickerSetRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/createNewStickerSet")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostDeclineChatJoinRequestRequest calls the generic PostDeclineChatJoinRequest builder with application/json body
func NewPostDeclineChatJoinRequestRequest(server string, body PostDeclineChatJoinRequestJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostDeclineChatJoinRequestRequestWithBody(server, "application/json", bodyReader)
}

// NewPostDeclineChatJoinRequestRequestWithBody generates requests for PostDeclineChatJoinRequest with any type of body
func NewPostDeclineChatJoinRequestRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/declineChatJoinRequest")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostDeleteChatPhotoRequest calls the generic PostDeleteChatPhoto builder with application/json body
func NewPostDeleteChatPhotoRequest(server string, body PostDeleteChatPhotoJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostDeleteChatPhotoRequestWithBody(server, "application/json", bodyReader)
}

// NewPostDeleteChatPhotoRequestWithBody generates requests for PostDeleteChatPhoto with any type of body
func NewPostDeleteChatPhotoRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deleteChatPhoto")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostDeleteChatStickerSetRequest calls the generic PostDeleteChatStickerSet builder with application/json body
func NewPostDeleteChatStickerSetRequest(server string, body PostDeleteChatStickerSetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostDeleteChatStickerSetRequestWithBody(server, "application/json", bodyReader)
}

// NewPostDeleteChatStickerSetRequestWithBody generates requests for PostDeleteChatStickerSet with any type of body
func NewPostDeleteChatStickerSetRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deleteChatStickerSet")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostDeleteMessageRequest calls the generic PostDeleteMessage builder with application/json body
func NewPostDeleteMessageRequest(server string, body PostDeleteMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostDeleteMessageRequestWithBody(server, "application/json", bodyReader)
}

// NewPostDeleteMessageRequestWithBody generates requests for PostDeleteMessage with any type of body
func NewPostDeleteMessageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deleteMessage")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostDeleteMyCommandsRequest calls the generic PostDeleteMyCommands builder with application/json body
func NewPostDeleteMyCommandsRequest(server string, body PostDeleteMyCommandsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostDeleteMyCommandsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostDeleteMyCommandsRequestWithBody generates requests for PostDeleteMyCommands with any type of body
func NewPostDeleteMyCommandsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deleteMyCommands")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostDeleteStickerFromSetRequest calls the generic PostDeleteStickerFromSet builder with application/json body
func NewPostDeleteStickerFromSetRequest(server string, body PostDeleteStickerFromSetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostDeleteStickerFromSetRequestWithBody(server, "application/json", bodyReader)
}

// NewPostDeleteStickerFromSetRequestWithBody generates requests for PostDeleteStickerFromSet with any type of body
func NewPostDeleteStickerFromSetRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deleteStickerFromSet")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostDeleteWebhookRequest calls the generic PostDeleteWebhook builder with application/json body
func NewPostDeleteWebhookRequest(server string, body PostDeleteWebhookJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostDeleteWebhookRequestWithBody(server, "application/json", bodyReader)
}

// NewPostDeleteWebhookRequestWithBody generates requests for PostDeleteWebhook with any type of body
func NewPostDeleteWebhookRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deleteWebhook")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostEditChatInviteLinkRequest calls the generic PostEditChatInviteLink builder with application/json body
func NewPostEditChatInviteLinkRequest(server string, body PostEditChatInviteLinkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostEditChatInviteLinkRequestWithBody(server, "application/json", bodyReader)
}

// NewPostEditChatInviteLinkRequestWithBody generates requests for PostEditChatInviteLink with any type of body
func NewPostEditChatInviteLinkRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/editChatInviteLink")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostEditMessageCaptionRequest calls the generic PostEditMessageCaption builder with application/json body
func NewPostEditMessageCaptionRequest(server string, body PostEditMessageCaptionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostEditMessageCaptionRequestWithBody(server, "application/json", bodyReader)
}

// NewPostEditMessageCaptionRequestWithBody generates requests for PostEditMessageCaption with any type of body
func NewPostEditMessageCaptionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/editMessageCaption")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostEditMessageLiveLocationRequest calls the generic PostEditMessageLiveLocation builder with application/json body
func NewPostEditMessageLiveLocationRequest(server string, body PostEditMessageLiveLocationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostEditMessageLiveLocationRequestWithBody(server, "application/json", bodyReader)
}

// NewPostEditMessageLiveLocationRequestWithBody generates requests for PostEditMessageLiveLocation with any type of body
func NewPostEditMessageLiveLocationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/editMessageLiveLocation")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostEditMessageMediaRequestWithBody generates requests for PostEditMessageMedia with any type of body
func NewPostEditMessageMediaRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/editMessageMedia")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostEditMessageReplyMarkupRequest calls the generic PostEditMessageReplyMarkup builder with application/json body
func NewPostEditMessageReplyMarkupRequest(server string, body PostEditMessageReplyMarkupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostEditMessageReplyMarkupRequestWithBody(server, "application/json", bodyReader)
}

// NewPostEditMessageReplyMarkupRequestWithBody generates requests for PostEditMessageReplyMarkup with any type of body
func NewPostEditMessageReplyMarkupRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/editMessageReplyMarkup")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostEditMessageTextRequest calls the generic PostEditMessageText builder with application/json body
func NewPostEditMessageTextRequest(server string, body PostEditMessageTextJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostEditMessageTextRequestWithBody(server, "application/json", bodyReader)
}

// NewPostEditMessageTextRequestWithBody generates requests for PostEditMessageText with any type of body
func NewPostEditMessageTextRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/editMessageText")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostExportChatInviteLinkRequest calls the generic PostExportChatInviteLink builder with application/json body
func NewPostExportChatInviteLinkRequest(server string, body PostExportChatInviteLinkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostExportChatInviteLinkRequestWithBody(server, "application/json", bodyReader)
}

// NewPostExportChatInviteLinkRequestWithBody generates requests for PostExportChatInviteLink with any type of body
func NewPostExportChatInviteLinkRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/exportChatInviteLink")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostForwardMessageRequest calls the generic PostForwardMessage builder with application/json body
func NewPostForwardMessageRequest(server string, body PostForwardMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostForwardMessageRequestWithBody(server, "application/json", bodyReader)
}

// NewPostForwardMessageRequestWithBody generates requests for PostForwardMessage with any type of body
func NewPostForwardMessageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/forwardMessage")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostGetChatRequest calls the generic PostGetChat builder with application/json body
func NewPostGetChatRequest(server string, body PostGetChatJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostGetChatRequestWithBody(server, "application/json", bodyReader)
}

// NewPostGetChatRequestWithBody generates requests for PostGetChat with any type of body
func NewPostGetChatRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getChat")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostGetChatAdministratorsRequest calls the generic PostGetChatAdministrators builder with application/json body
func NewPostGetChatAdministratorsRequest(server string, body PostGetChatAdministratorsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostGetChatAdministratorsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostGetChatAdministratorsRequestWithBody generates requests for PostGetChatAdministrators with any type of body
func NewPostGetChatAdministratorsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getChatAdministrators")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostGetChatMemberRequest calls the generic PostGetChatMember builder with application/json body
func NewPostGetChatMemberRequest(server string, body PostGetChatMemberJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostGetChatMemberRequestWithBody(server, "application/json", bodyReader)
}

// NewPostGetChatMemberRequestWithBody generates requests for PostGetChatMember with any type of body
func NewPostGetChatMemberRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getChatMember")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostGetChatMemberCountRequest calls the generic PostGetChatMemberCount builder with application/json body
func NewPostGetChatMemberCountRequest(server string, body PostGetChatMemberCountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostGetChatMemberCountRequestWithBody(server, "application/json", bodyReader)
}

// NewPostGetChatMemberCountRequestWithBody generates requests for PostGetChatMemberCount with any type of body
func NewPostGetChatMemberCountRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getChatMemberCount")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostGetChatMenuButtonRequest calls the generic PostGetChatMenuButton builder with application/json body
func NewPostGetChatMenuButtonRequest(server string, body PostGetChatMenuButtonJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostGetChatMenuButtonRequestWithBody(server, "application/json", bodyReader)
}

// NewPostGetChatMenuButtonRequestWithBody generates requests for PostGetChatMenuButton with any type of body
func NewPostGetChatMenuButtonRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getChatMenuButton")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostGetFileRequest calls the generic PostGetFile builder with application/json body
func NewPostGetFileRequest(server string, body PostGetFileJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostGetFileRequestWithBody(server, "application/json", bodyReader)
}

// NewPostGetFileRequestWithBody generates requests for PostGetFile with any type of body
func NewPostGetFileRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getFile")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostGetGameHighScoresRequest calls the generic PostGetGameHighScores builder with application/json body
func NewPostGetGameHighScoresRequest(server string, body PostGetGameHighScoresJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostGetGameHighScoresRequestWithBody(server, "application/json", bodyReader)
}

// NewPostGetGameHighScoresRequestWithBody generates requests for PostGetGameHighScores with any type of body
func NewPostGetGameHighScoresRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getGameHighScores")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostGetMeRequest generates requests for PostGetMe
func NewPostGetMeRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getMe")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostGetMyCommandsRequest calls the generic PostGetMyCommands builder with application/json body
func NewPostGetMyCommandsRequest(server string, body PostGetMyCommandsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostGetMyCommandsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostGetMyCommandsRequestWithBody generates requests for PostGetMyCommands with any type of body
func NewPostGetMyCommandsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getMyCommands")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostGetMyDefaultAdministratorRightsRequest calls the generic PostGetMyDefaultAdministratorRights builder with application/json body
func NewPostGetMyDefaultAdministratorRightsRequest(server string, body PostGetMyDefaultAdministratorRightsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostGetMyDefaultAdministratorRightsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostGetMyDefaultAdministratorRightsRequestWithBody generates requests for PostGetMyDefaultAdministratorRights with any type of body
func NewPostGetMyDefaultAdministratorRightsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getMyDefaultAdministratorRights")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostGetStickerSetRequest calls the generic PostGetStickerSet builder with application/json body
func NewPostGetStickerSetRequest(server string, body PostGetStickerSetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostGetStickerSetRequestWithBody(server, "application/json", bodyReader)
}

// NewPostGetStickerSetRequestWithBody generates requests for PostGetStickerSet with any type of body
func NewPostGetStickerSetRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getStickerSet")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostGetUpdatesRequest calls the generic PostGetUpdates builder with application/json body
func NewPostGetUpdatesRequest(server string, body PostGetUpdatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostGetUpdatesRequestWithBody(server, "application/json", bodyReader)
}

// NewPostGetUpdatesRequestWithBody generates requests for PostGetUpdates with any type of body
func NewPostGetUpdatesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getUpdates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostGetUserProfilePhotosRequest calls the generic PostGetUserProfilePhotos builder with application/json body
func NewPostGetUserProfilePhotosRequest(server string, body PostGetUserProfilePhotosJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostGetUserProfilePhotosRequestWithBody(server, "application/json", bodyReader)
}

// NewPostGetUserProfilePhotosRequestWithBody generates requests for PostGetUserProfilePhotos with any type of body
func NewPostGetUserProfilePhotosRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getUserProfilePhotos")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostGetWebhookInfoRequest generates requests for PostGetWebhookInfo
func NewPostGetWebhookInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getWebhookInfo")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostLeaveChatRequest calls the generic PostLeaveChat builder with application/json body
func NewPostLeaveChatRequest(server string, body PostLeaveChatJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostLeaveChatRequestWithBody(server, "application/json", bodyReader)
}

// NewPostLeaveChatRequestWithBody generates requests for PostLeaveChat with any type of body
func NewPostLeaveChatRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/leaveChat")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostLogOutRequest generates requests for PostLogOut
func NewPostLogOutRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/logOut")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostPinChatMessageRequest calls the generic PostPinChatMessage builder with application/json body
func NewPostPinChatMessageRequest(server string, body PostPinChatMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostPinChatMessageRequestWithBody(server, "application/json", bodyReader)
}

// NewPostPinChatMessageRequestWithBody generates requests for PostPinChatMessage with any type of body
func NewPostPinChatMessageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pinChatMessage")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostPromoteChatMemberRequest calls the generic PostPromoteChatMember builder with application/json body
func NewPostPromoteChatMemberRequest(server string, body PostPromoteChatMemberJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostPromoteChatMemberRequestWithBody(server, "application/json", bodyReader)
}

// NewPostPromoteChatMemberRequestWithBody generates requests for PostPromoteChatMember with any type of body
func NewPostPromoteChatMemberRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/promoteChatMember")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostRestrictChatMemberRequest calls the generic PostRestrictChatMember builder with application/json body
func NewPostRestrictChatMemberRequest(server string, body PostRestrictChatMemberJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostRestrictChatMemberRequestWithBody(server, "application/json", bodyReader)
}

// NewPostRestrictChatMemberRequestWithBody generates requests for PostRestrictChatMember with any type of body
func NewPostRestrictChatMemberRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restrictChatMember")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostRevokeChatInviteLinkRequest calls the generic PostRevokeChatInviteLink builder with application/json body
func NewPostRevokeChatInviteLinkRequest(server string, body PostRevokeChatInviteLinkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostRevokeChatInviteLinkRequestWithBody(server, "application/json", bodyReader)
}

// NewPostRevokeChatInviteLinkRequestWithBody generates requests for PostRevokeChatInviteLink with any type of body
func NewPostRevokeChatInviteLinkRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/revokeChatInviteLink")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSendAnimationRequestWithBody generates requests for PostSendAnimation with any type of body
func NewPostSendAnimationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sendAnimation")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSendAudioRequestWithBody generates requests for PostSendAudio with any type of body
func NewPostSendAudioRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sendAudio")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSendChatActionRequest calls the generic PostSendChatAction builder with application/json body
func NewPostSendChatActionRequest(server string, body PostSendChatActionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSendChatActionRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSendChatActionRequestWithBody generates requests for PostSendChatAction with any type of body
func NewPostSendChatActionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sendChatAction")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSendContactRequest calls the generic PostSendContact builder with application/json body
func NewPostSendContactRequest(server string, body PostSendContactJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSendContactRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSendContactRequestWithBody generates requests for PostSendContact with any type of body
func NewPostSendContactRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sendContact")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSendDiceRequest calls the generic PostSendDice builder with application/json body
func NewPostSendDiceRequest(server string, body PostSendDiceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSendDiceRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSendDiceRequestWithBody generates requests for PostSendDice with any type of body
func NewPostSendDiceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sendDice")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSendDocumentRequestWithBody generates requests for PostSendDocument with any type of body
func NewPostSendDocumentRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sendDocument")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSendGameRequest calls the generic PostSendGame builder with application/json body
func NewPostSendGameRequest(server string, body PostSendGameJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSendGameRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSendGameRequestWithBody generates requests for PostSendGame with any type of body
func NewPostSendGameRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sendGame")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSendInvoiceRequest calls the generic PostSendInvoice builder with application/json body
func NewPostSendInvoiceRequest(server string, body PostSendInvoiceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSendInvoiceRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSendInvoiceRequestWithBody generates requests for PostSendInvoice with any type of body
func NewPostSendInvoiceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sendInvoice")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSendLocationRequest calls the generic PostSendLocation builder with application/json body
func NewPostSendLocationRequest(server string, body PostSendLocationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSendLocationRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSendLocationRequestWithBody generates requests for PostSendLocation with any type of body
func NewPostSendLocationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sendLocation")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSendMediaGroupRequestWithBody generates requests for PostSendMediaGroup with any type of body
func NewPostSendMediaGroupRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sendMediaGroup")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSendMessageRequest calls the generic PostSendMessage builder with application/json body
func NewPostSendMessageRequest(server string, body PostSendMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSendMessageRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSendMessageRequestWithBody generates requests for PostSendMessage with any type of body
func NewPostSendMessageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sendMessage")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSendPhotoRequestWithBody generates requests for PostSendPhoto with any type of body
func NewPostSendPhotoRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sendPhoto")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSendPollRequest calls the generic PostSendPoll builder with application/json body
func NewPostSendPollRequest(server string, body PostSendPollJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSendPollRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSendPollRequestWithBody generates requests for PostSendPoll with any type of body
func NewPostSendPollRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sendPoll")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSendStickerRequestWithBody generates requests for PostSendSticker with any type of body
func NewPostSendStickerRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sendSticker")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSendVenueRequest calls the generic PostSendVenue builder with application/json body
func NewPostSendVenueRequest(server string, body PostSendVenueJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSendVenueRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSendVenueRequestWithBody generates requests for PostSendVenue with any type of body
func NewPostSendVenueRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sendVenue")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSendVideoRequestWithBody generates requests for PostSendVideo with any type of body
func NewPostSendVideoRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sendVideo")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSendVideoNoteRequestWithBody generates requests for PostSendVideoNote with any type of body
func NewPostSendVideoNoteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sendVideoNote")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSendVoiceRequestWithBody generates requests for PostSendVoice with any type of body
func NewPostSendVoiceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sendVoice")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSetChatAdministratorCustomTitleRequest calls the generic PostSetChatAdministratorCustomTitle builder with application/json body
func NewPostSetChatAdministratorCustomTitleRequest(server string, body PostSetChatAdministratorCustomTitleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSetChatAdministratorCustomTitleRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSetChatAdministratorCustomTitleRequestWithBody generates requests for PostSetChatAdministratorCustomTitle with any type of body
func NewPostSetChatAdministratorCustomTitleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/setChatAdministratorCustomTitle")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSetChatDescriptionRequest calls the generic PostSetChatDescription builder with application/json body
func NewPostSetChatDescriptionRequest(server string, body PostSetChatDescriptionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSetChatDescriptionRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSetChatDescriptionRequestWithBody generates requests for PostSetChatDescription with any type of body
func NewPostSetChatDescriptionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/setChatDescription")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSetChatMenuButtonRequest calls the generic PostSetChatMenuButton builder with application/json body
func NewPostSetChatMenuButtonRequest(server string, body PostSetChatMenuButtonJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSetChatMenuButtonRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSetChatMenuButtonRequestWithBody generates requests for PostSetChatMenuButton with any type of body
func NewPostSetChatMenuButtonRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/setChatMenuButton")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSetChatPermissionsRequest calls the generic PostSetChatPermissions builder with application/json body
func NewPostSetChatPermissionsRequest(server string, body PostSetChatPermissionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSetChatPermissionsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSetChatPermissionsRequestWithBody generates requests for PostSetChatPermissions with any type of body
func NewPostSetChatPermissionsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/setChatPermissions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSetChatPhotoRequestWithBody generates requests for PostSetChatPhoto with any type of body
func NewPostSetChatPhotoRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/setChatPhoto")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSetChatStickerSetRequest calls the generic PostSetChatStickerSet builder with application/json body
func NewPostSetChatStickerSetRequest(server string, body PostSetChatStickerSetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSetChatStickerSetRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSetChatStickerSetRequestWithBody generates requests for PostSetChatStickerSet with any type of body
func NewPostSetChatStickerSetRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/setChatStickerSet")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSetChatTitleRequest calls the generic PostSetChatTitle builder with application/json body
func NewPostSetChatTitleRequest(server string, body PostSetChatTitleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSetChatTitleRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSetChatTitleRequestWithBody generates requests for PostSetChatTitle with any type of body
func NewPostSetChatTitleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/setChatTitle")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSetGameScoreRequest calls the generic PostSetGameScore builder with application/json body
func NewPostSetGameScoreRequest(server string, body PostSetGameScoreJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSetGameScoreRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSetGameScoreRequestWithBody generates requests for PostSetGameScore with any type of body
func NewPostSetGameScoreRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/setGameScore")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSetMyCommandsRequest calls the generic PostSetMyCommands builder with application/json body
func NewPostSetMyCommandsRequest(server string, body PostSetMyCommandsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSetMyCommandsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSetMyCommandsRequestWithBody generates requests for PostSetMyCommands with any type of body
func NewPostSetMyCommandsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/setMyCommands")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSetMyDefaultAdministratorRightsRequest calls the generic PostSetMyDefaultAdministratorRights builder with application/json body
func NewPostSetMyDefaultAdministratorRightsRequest(server string, body PostSetMyDefaultAdministratorRightsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSetMyDefaultAdministratorRightsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSetMyDefaultAdministratorRightsRequestWithBody generates requests for PostSetMyDefaultAdministratorRights with any type of body
func NewPostSetMyDefaultAdministratorRightsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/setMyDefaultAdministratorRights")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSetPassportDataErrorsRequest calls the generic PostSetPassportDataErrors builder with application/json body
func NewPostSetPassportDataErrorsRequest(server string, body PostSetPassportDataErrorsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSetPassportDataErrorsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSetPassportDataErrorsRequestWithBody generates requests for PostSetPassportDataErrors with any type of body
func NewPostSetPassportDataErrorsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/setPassportDataErrors")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSetStickerPositionInSetRequest calls the generic PostSetStickerPositionInSet builder with application/json body
func NewPostSetStickerPositionInSetRequest(server string, body PostSetStickerPositionInSetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSetStickerPositionInSetRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSetStickerPositionInSetRequestWithBody generates requests for PostSetStickerPositionInSet with any type of body
func NewPostSetStickerPositionInSetRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/setStickerPositionInSet")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSetStickerSetThumbRequestWithBody generates requests for PostSetStickerSetThumb with any type of body
func NewPostSetStickerSetThumbRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/setStickerSetThumb")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSetWebhookRequestWithBody generates requests for PostSetWebhook with any type of body
func NewPostSetWebhookRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/setWebhook")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostStopMessageLiveLocationRequest calls the generic PostStopMessageLiveLocation builder with application/json body
func NewPostStopMessageLiveLocationRequest(server string, body PostStopMessageLiveLocationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostStopMessageLiveLocationRequestWithBody(server, "application/json", bodyReader)
}

// NewPostStopMessageLiveLocationRequestWithBody generates requests for PostStopMessageLiveLocation with any type of body
func NewPostStopMessageLiveLocationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stopMessageLiveLocation")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostStopPollRequest calls the generic PostStopPoll builder with application/json body
func NewPostStopPollRequest(server string, body PostStopPollJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostStopPollRequestWithBody(server, "application/json", bodyReader)
}

// NewPostStopPollRequestWithBody generates requests for PostStopPoll with any type of body
func NewPostStopPollRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stopPoll")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostUnbanChatMemberRequest calls the generic PostUnbanChatMember builder with application/json body
func NewPostUnbanChatMemberRequest(server string, body PostUnbanChatMemberJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostUnbanChatMemberRequestWithBody(server, "application/json", bodyReader)
}

// NewPostUnbanChatMemberRequestWithBody generates requests for PostUnbanChatMember with any type of body
func NewPostUnbanChatMemberRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/unbanChatMember")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostUnbanChatSenderChatRequest calls the generic PostUnbanChatSenderChat builder with application/json body
func NewPostUnbanChatSenderChatRequest(server string, body PostUnbanChatSenderChatJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostUnbanChatSenderChatRequestWithBody(server, "application/json", bodyReader)
}

// NewPostUnbanChatSenderChatRequestWithBody generates requests for PostUnbanChatSenderChat with any type of body
func NewPostUnbanChatSenderChatRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/unbanChatSenderChat")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostUnpinAllChatMessagesRequest calls the generic PostUnpinAllChatMessages builder with application/json body
func NewPostUnpinAllChatMessagesRequest(server string, body PostUnpinAllChatMessagesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostUnpinAllChatMessagesRequestWithBody(server, "application/json", bodyReader)
}

// NewPostUnpinAllChatMessagesRequestWithBody generates requests for PostUnpinAllChatMessages with any type of body
func NewPostUnpinAllChatMessagesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/unpinAllChatMessages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostUnpinChatMessageRequest calls the generic PostUnpinChatMessage builder with application/json body
func NewPostUnpinChatMessageRequest(server string, body PostUnpinChatMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostUnpinChatMessageRequestWithBody(server, "application/json", bodyReader)
}

// NewPostUnpinChatMessageRequestWithBody generates requests for PostUnpinChatMessage with any type of body
func NewPostUnpinChatMessageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/unpinChatMessage")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostUploadStickerFileRequestWithBody generates requests for PostUploadStickerFile with any type of body
func NewPostUploadStickerFileRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/uploadStickerFile")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// PostAddStickerToSet request with any body
	PostAddStickerToSetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAddStickerToSetResponse, error)

	// PostAnswerCallbackQuery request with any body
	PostAnswerCallbackQueryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAnswerCallbackQueryResponse, error)

	PostAnswerCallbackQueryWithResponse(ctx context.Context, body PostAnswerCallbackQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAnswerCallbackQueryResponse, error)

	// PostAnswerInlineQuery request with any body
	PostAnswerInlineQueryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAnswerInlineQueryResponse, error)

	PostAnswerInlineQueryWithResponse(ctx context.Context, body PostAnswerInlineQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAnswerInlineQueryResponse, error)

	// PostAnswerPreCheckoutQuery request with any body
	PostAnswerPreCheckoutQueryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAnswerPreCheckoutQueryResponse, error)

	PostAnswerPreCheckoutQueryWithResponse(ctx context.Context, body PostAnswerPreCheckoutQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAnswerPreCheckoutQueryResponse, error)

	// PostAnswerShippingQuery request with any body
	PostAnswerShippingQueryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAnswerShippingQueryResponse, error)

	PostAnswerShippingQueryWithResponse(ctx context.Context, body PostAnswerShippingQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAnswerShippingQueryResponse, error)

	// PostAnswerWebAppQuery request with any body
	PostAnswerWebAppQueryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAnswerWebAppQueryResponse, error)

	PostAnswerWebAppQueryWithResponse(ctx context.Context, body PostAnswerWebAppQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAnswerWebAppQueryResponse, error)

	// PostApproveChatJoinRequest request with any body
	PostApproveChatJoinRequestWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApproveChatJoinRequestResponse, error)

	PostApproveChatJoinRequestWithResponse(ctx context.Context, body PostApproveChatJoinRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApproveChatJoinRequestResponse, error)

	// PostBanChatMember request with any body
	PostBanChatMemberWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostBanChatMemberResponse, error)

	PostBanChatMemberWithResponse(ctx context.Context, body PostBanChatMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*PostBanChatMemberResponse, error)

	// PostBanChatSenderChat request with any body
	PostBanChatSenderChatWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostBanChatSenderChatResponse, error)

	PostBanChatSenderChatWithResponse(ctx context.Context, body PostBanChatSenderChatJSONRequestBody, reqEditors ...RequestEditorFn) (*PostBanChatSenderChatResponse, error)

	// PostClose request
	PostCloseWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostCloseResponse, error)

	// PostCopyMessage request with any body
	PostCopyMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCopyMessageResponse, error)

	PostCopyMessageWithResponse(ctx context.Context, body PostCopyMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCopyMessageResponse, error)

	// PostCreateChatInviteLink request with any body
	PostCreateChatInviteLinkWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCreateChatInviteLinkResponse, error)

	PostCreateChatInviteLinkWithResponse(ctx context.Context, body PostCreateChatInviteLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCreateChatInviteLinkResponse, error)

	// PostCreateInvoiceLink request with any body
	PostCreateInvoiceLinkWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCreateInvoiceLinkResponse, error)

	PostCreateInvoiceLinkWithResponse(ctx context.Context, body PostCreateInvoiceLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCreateInvoiceLinkResponse, error)

	// PostCreateNewStickerSet request with any body
	PostCreateNewStickerSetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCreateNewStickerSetResponse, error)

	// PostDeclineChatJoinRequest request with any body
	PostDeclineChatJoinRequestWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDeclineChatJoinRequestResponse, error)

	PostDeclineChatJoinRequestWithResponse(ctx context.Context, body PostDeclineChatJoinRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDeclineChatJoinRequestResponse, error)

	// PostDeleteChatPhoto request with any body
	PostDeleteChatPhotoWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDeleteChatPhotoResponse, error)

	PostDeleteChatPhotoWithResponse(ctx context.Context, body PostDeleteChatPhotoJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDeleteChatPhotoResponse, error)

	// PostDeleteChatStickerSet request with any body
	PostDeleteChatStickerSetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDeleteChatStickerSetResponse, error)

	PostDeleteChatStickerSetWithResponse(ctx context.Context, body PostDeleteChatStickerSetJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDeleteChatStickerSetResponse, error)

	// PostDeleteMessage request with any body
	PostDeleteMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDeleteMessageResponse, error)

	PostDeleteMessageWithResponse(ctx context.Context, body PostDeleteMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDeleteMessageResponse, error)

	// PostDeleteMyCommands request with any body
	PostDeleteMyCommandsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDeleteMyCommandsResponse, error)

	PostDeleteMyCommandsWithResponse(ctx context.Context, body PostDeleteMyCommandsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDeleteMyCommandsResponse, error)

	// PostDeleteStickerFromSet request with any body
	PostDeleteStickerFromSetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDeleteStickerFromSetResponse, error)

	PostDeleteStickerFromSetWithResponse(ctx context.Context, body PostDeleteStickerFromSetJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDeleteStickerFromSetResponse, error)

	// PostDeleteWebhook request with any body
	PostDeleteWebhookWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDeleteWebhookResponse, error)

	PostDeleteWebhookWithResponse(ctx context.Context, body PostDeleteWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDeleteWebhookResponse, error)

	// PostEditChatInviteLink request with any body
	PostEditChatInviteLinkWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostEditChatInviteLinkResponse, error)

	PostEditChatInviteLinkWithResponse(ctx context.Context, body PostEditChatInviteLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*PostEditChatInviteLinkResponse, error)

	// PostEditMessageCaption request with any body
	PostEditMessageCaptionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostEditMessageCaptionResponse, error)

	PostEditMessageCaptionWithResponse(ctx context.Context, body PostEditMessageCaptionJSONRequestBody, reqEditors ...RequestEditorFn) (*PostEditMessageCaptionResponse, error)

	// PostEditMessageLiveLocation request with any body
	PostEditMessageLiveLocationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostEditMessageLiveLocationResponse, error)

	PostEditMessageLiveLocationWithResponse(ctx context.Context, body PostEditMessageLiveLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*PostEditMessageLiveLocationResponse, error)

	// PostEditMessageMedia request with any body
	PostEditMessageMediaWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostEditMessageMediaResponse, error)

	// PostEditMessageReplyMarkup request with any body
	PostEditMessageReplyMarkupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostEditMessageReplyMarkupResponse, error)

	PostEditMessageReplyMarkupWithResponse(ctx context.Context, body PostEditMessageReplyMarkupJSONRequestBody, reqEditors ...RequestEditorFn) (*PostEditMessageReplyMarkupResponse, error)

	// PostEditMessageText request with any body
	PostEditMessageTextWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostEditMessageTextResponse, error)

	PostEditMessageTextWithResponse(ctx context.Context, body PostEditMessageTextJSONRequestBody, reqEditors ...RequestEditorFn) (*PostEditMessageTextResponse, error)

	// PostExportChatInviteLink request with any body
	PostExportChatInviteLinkWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostExportChatInviteLinkResponse, error)

	PostExportChatInviteLinkWithResponse(ctx context.Context, body PostExportChatInviteLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*PostExportChatInviteLinkResponse, error)

	// PostForwardMessage request with any body
	PostForwardMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostForwardMessageResponse, error)

	PostForwardMessageWithResponse(ctx context.Context, body PostForwardMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*PostForwardMessageResponse, error)

	// PostGetChat request with any body
	PostGetChatWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostGetChatResponse, error)

	PostGetChatWithResponse(ctx context.Context, body PostGetChatJSONRequestBody, reqEditors ...RequestEditorFn) (*PostGetChatResponse, error)

	// PostGetChatAdministrators request with any body
	PostGetChatAdministratorsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostGetChatAdministratorsResponse, error)

	PostGetChatAdministratorsWithResponse(ctx context.Context, body PostGetChatAdministratorsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostGetChatAdministratorsResponse, error)

	// PostGetChatMember request with any body
	PostGetChatMemberWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostGetChatMemberResponse, error)

	PostGetChatMemberWithResponse(ctx context.Context, body PostGetChatMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*PostGetChatMemberResponse, error)

	// PostGetChatMemberCount request with any body
	PostGetChatMemberCountWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostGetChatMemberCountResponse, error)

	PostGetChatMemberCountWithResponse(ctx context.Context, body PostGetChatMemberCountJSONRequestBody, reqEditors ...RequestEditorFn) (*PostGetChatMemberCountResponse, error)

	// PostGetChatMenuButton request with any body
	PostGetChatMenuButtonWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostGetChatMenuButtonResponse, error)

	PostGetChatMenuButtonWithResponse(ctx context.Context, body PostGetChatMenuButtonJSONRequestBody, reqEditors ...RequestEditorFn) (*PostGetChatMenuButtonResponse, error)

	// PostGetFile request with any body
	PostGetFileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostGetFileResponse, error)

	PostGetFileWithResponse(ctx context.Context, body PostGetFileJSONRequestBody, reqEditors ...RequestEditorFn) (*PostGetFileResponse, error)

	// PostGetGameHighScores request with any body
	PostGetGameHighScoresWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostGetGameHighScoresResponse, error)

	PostGetGameHighScoresWithResponse(ctx context.Context, body PostGetGameHighScoresJSONRequestBody, reqEditors ...RequestEditorFn) (*PostGetGameHighScoresResponse, error)

	// PostGetMe request
	PostGetMeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostGetMeResponse, error)

	// PostGetMyCommands request with any body
	PostGetMyCommandsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostGetMyCommandsResponse, error)

	PostGetMyCommandsWithResponse(ctx context.Context, body PostGetMyCommandsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostGetMyCommandsResponse, error)

	// PostGetMyDefaultAdministratorRights request with any body
	PostGetMyDefaultAdministratorRightsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostGetMyDefaultAdministratorRightsResponse, error)

	PostGetMyDefaultAdministratorRightsWithResponse(ctx context.Context, body PostGetMyDefaultAdministratorRightsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostGetMyDefaultAdministratorRightsResponse, error)

	// PostGetStickerSet request with any body
	PostGetStickerSetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostGetStickerSetResponse, error)

	PostGetStickerSetWithResponse(ctx context.Context, body PostGetStickerSetJSONRequestBody, reqEditors ...RequestEditorFn) (*PostGetStickerSetResponse, error)

	// PostGetUpdates request with any body
	PostGetUpdatesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostGetUpdatesResponse, error)

	PostGetUpdatesWithResponse(ctx context.Context, body PostGetUpdatesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostGetUpdatesResponse, error)

	// PostGetUserProfilePhotos request with any body
	PostGetUserProfilePhotosWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostGetUserProfilePhotosResponse, error)

	PostGetUserProfilePhotosWithResponse(ctx context.Context, body PostGetUserProfilePhotosJSONRequestBody, reqEditors ...RequestEditorFn) (*PostGetUserProfilePhotosResponse, error)

	// PostGetWebhookInfo request
	PostGetWebhookInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostGetWebhookInfoResponse, error)

	// PostLeaveChat request with any body
	PostLeaveChatWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostLeaveChatResponse, error)

	PostLeaveChatWithResponse(ctx context.Context, body PostLeaveChatJSONRequestBody, reqEditors ...RequestEditorFn) (*PostLeaveChatResponse, error)

	// PostLogOut request
	PostLogOutWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostLogOutResponse, error)

	// PostPinChatMessage request with any body
	PostPinChatMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPinChatMessageResponse, error)

	PostPinChatMessageWithResponse(ctx context.Context, body PostPinChatMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPinChatMessageResponse, error)

	// PostPromoteChatMember request with any body
	PostPromoteChatMemberWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPromoteChatMemberResponse, error)

	PostPromoteChatMemberWithResponse(ctx context.Context, body PostPromoteChatMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPromoteChatMemberResponse, error)

	// PostRestrictChatMember request with any body
	PostRestrictChatMemberWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostRestrictChatMemberResponse, error)

	PostRestrictChatMemberWithResponse(ctx context.Context, body PostRestrictChatMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*PostRestrictChatMemberResponse, error)

	// PostRevokeChatInviteLink request with any body
	PostRevokeChatInviteLinkWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostRevokeChatInviteLinkResponse, error)

	PostRevokeChatInviteLinkWithResponse(ctx context.Context, body PostRevokeChatInviteLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*PostRevokeChatInviteLinkResponse, error)

	// PostSendAnimation request with any body
	PostSendAnimationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSendAnimationResponse, error)

	// PostSendAudio request with any body
	PostSendAudioWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSendAudioResponse, error)

	// PostSendChatAction request with any body
	PostSendChatActionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSendChatActionResponse, error)

	PostSendChatActionWithResponse(ctx context.Context, body PostSendChatActionJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSendChatActionResponse, error)

	// PostSendContact request with any body
	PostSendContactWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSendContactResponse, error)

	PostSendContactWithResponse(ctx context.Context, body PostSendContactJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSendContactResponse, error)

	// PostSendDice request with any body
	PostSendDiceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSendDiceResponse, error)

	PostSendDiceWithResponse(ctx context.Context, body PostSendDiceJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSendDiceResponse, error)

	// PostSendDocument request with any body
	PostSendDocumentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSendDocumentResponse, error)

	// PostSendGame request with any body
	PostSendGameWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSendGameResponse, error)

	PostSendGameWithResponse(ctx context.Context, body PostSendGameJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSendGameResponse, error)

	// PostSendInvoice request with any body
	PostSendInvoiceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSendInvoiceResponse, error)

	PostSendInvoiceWithResponse(ctx context.Context, body PostSendInvoiceJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSendInvoiceResponse, error)

	// PostSendLocation request with any body
	PostSendLocationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSendLocationResponse, error)

	PostSendLocationWithResponse(ctx context.Context, body PostSendLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSendLocationResponse, error)

	// PostSendMediaGroup request with any body
	PostSendMediaGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSendMediaGroupResponse, error)

	// PostSendMessage request with any body
	PostSendMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSendMessageResponse, error)

	PostSendMessageWithResponse(ctx context.Context, body PostSendMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSendMessageResponse, error)

	// PostSendPhoto request with any body
	PostSendPhotoWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSendPhotoResponse, error)

	// PostSendPoll request with any body
	PostSendPollWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSendPollResponse, error)

	PostSendPollWithResponse(ctx context.Context, body PostSendPollJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSendPollResponse, error)

	// PostSendSticker request with any body
	PostSendStickerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSendStickerResponse, error)

	// PostSendVenue request with any body
	PostSendVenueWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSendVenueResponse, error)

	PostSendVenueWithResponse(ctx context.Context, body PostSendVenueJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSendVenueResponse, error)

	// PostSendVideo request with any body
	PostSendVideoWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSendVideoResponse, error)

	// PostSendVideoNote request with any body
	PostSendVideoNoteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSendVideoNoteResponse, error)

	// PostSendVoice request with any body
	PostSendVoiceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSendVoiceResponse, error)

	// PostSetChatAdministratorCustomTitle request with any body
	PostSetChatAdministratorCustomTitleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSetChatAdministratorCustomTitleResponse, error)

	PostSetChatAdministratorCustomTitleWithResponse(ctx context.Context, body PostSetChatAdministratorCustomTitleJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSetChatAdministratorCustomTitleResponse, error)

	// PostSetChatDescription request with any body
	PostSetChatDescriptionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSetChatDescriptionResponse, error)

	PostSetChatDescriptionWithResponse(ctx context.Context, body PostSetChatDescriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSetChatDescriptionResponse, error)

	// PostSetChatMenuButton request with any body
	PostSetChatMenuButtonWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSetChatMenuButtonResponse, error)

	PostSetChatMenuButtonWithResponse(ctx context.Context, body PostSetChatMenuButtonJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSetChatMenuButtonResponse, error)

	// PostSetChatPermissions request with any body
	PostSetChatPermissionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSetChatPermissionsResponse, error)

	PostSetChatPermissionsWithResponse(ctx context.Context, body PostSetChatPermissionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSetChatPermissionsResponse, error)

	// PostSetChatPhoto request with any body
	PostSetChatPhotoWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSetChatPhotoResponse, error)

	// PostSetChatStickerSet request with any body
	PostSetChatStickerSetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSetChatStickerSetResponse, error)

	PostSetChatStickerSetWithResponse(ctx context.Context, body PostSetChatStickerSetJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSetChatStickerSetResponse, error)

	// PostSetChatTitle request with any body
	PostSetChatTitleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSetChatTitleResponse, error)

	PostSetChatTitleWithResponse(ctx context.Context, body PostSetChatTitleJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSetChatTitleResponse, error)

	// PostSetGameScore request with any body
	PostSetGameScoreWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSetGameScoreResponse, error)

	PostSetGameScoreWithResponse(ctx context.Context, body PostSetGameScoreJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSetGameScoreResponse, error)

	// PostSetMyCommands request with any body
	PostSetMyCommandsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSetMyCommandsResponse, error)

	PostSetMyCommandsWithResponse(ctx context.Context, body PostSetMyCommandsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSetMyCommandsResponse, error)

	// PostSetMyDefaultAdministratorRights request with any body
	PostSetMyDefaultAdministratorRightsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSetMyDefaultAdministratorRightsResponse, error)

	PostSetMyDefaultAdministratorRightsWithResponse(ctx context.Context, body PostSetMyDefaultAdministratorRightsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSetMyDefaultAdministratorRightsResponse, error)

	// PostSetPassportDataErrors request with any body
	PostSetPassportDataErrorsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSetPassportDataErrorsResponse, error)

	PostSetPassportDataErrorsWithResponse(ctx context.Context, body PostSetPassportDataErrorsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSetPassportDataErrorsResponse, error)

	// PostSetStickerPositionInSet request with any body
	PostSetStickerPositionInSetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSetStickerPositionInSetResponse, error)

	PostSetStickerPositionInSetWithResponse(ctx context.Context, body PostSetStickerPositionInSetJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSetStickerPositionInSetResponse, error)

	// PostSetStickerSetThumb request with any body
	PostSetStickerSetThumbWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSetStickerSetThumbResponse, error)

	// PostSetWebhook request with any body
	PostSetWebhookWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSetWebhookResponse, error)

	// PostStopMessageLiveLocation request with any body
	PostStopMessageLiveLocationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostStopMessageLiveLocationResponse, error)

	PostStopMessageLiveLocationWithResponse(ctx context.Context, body PostStopMessageLiveLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*PostStopMessageLiveLocationResponse, error)

	// PostStopPoll request with any body
	PostStopPollWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostStopPollResponse, error)

	PostStopPollWithResponse(ctx context.Context, body PostStopPollJSONRequestBody, reqEditors ...RequestEditorFn) (*PostStopPollResponse, error)

	// PostUnbanChatMember request with any body
	PostUnbanChatMemberWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUnbanChatMemberResponse, error)

	PostUnbanChatMemberWithResponse(ctx context.Context, body PostUnbanChatMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUnbanChatMemberResponse, error)

	// PostUnbanChatSenderChat request with any body
	PostUnbanChatSenderChatWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUnbanChatSenderChatResponse, error)

	PostUnbanChatSenderChatWithResponse(ctx context.Context, body PostUnbanChatSenderChatJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUnbanChatSenderChatResponse, error)

	// PostUnpinAllChatMessages request with any body
	PostUnpinAllChatMessagesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUnpinAllChatMessagesResponse, error)

	PostUnpinAllChatMessagesWithResponse(ctx context.Context, body PostUnpinAllChatMessagesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUnpinAllChatMessagesResponse, error)

	// PostUnpinChatMessage request with any body
	PostUnpinChatMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUnpinChatMessageResponse, error)

	PostUnpinChatMessageWithResponse(ctx context.Context, body PostUnpinChatMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUnpinChatMessageResponse, error)

	// PostUploadStickerFile request with any body
	PostUploadStickerFileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUploadStickerFileResponse, error)
}

type PostAddStickerToSetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool `json:"ok"`
		Result bool `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostAddStickerToSetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAddStickerToSetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAnswerCallbackQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool `json:"ok"`
		Result bool `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostAnswerCallbackQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAnswerCallbackQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAnswerInlineQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool `json:"ok"`
		Result bool `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostAnswerInlineQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAnswerInlineQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAnswerPreCheckoutQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool `json:"ok"`
		Result bool `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostAnswerPreCheckoutQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAnswerPreCheckoutQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAnswerShippingQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool `json:"ok"`
		Result bool `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostAnswerShippingQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAnswerShippingQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAnswerWebAppQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok bool `json:"ok"`

		// Describes an inline message sent by a [Web App](https://core.telegram.org/bots/webapps) on behalf of a user.
		Result SentWebAppMessage `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostAnswerWebAppQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAnswerWebAppQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApproveChatJoinRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool `json:"ok"`
		Result bool `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostApproveChatJoinRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApproveChatJoinRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostBanChatMemberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool `json:"ok"`
		Result bool `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostBanChatMemberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostBanChatMemberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostBanChatSenderChatResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool `json:"ok"`
		Result bool `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostBanChatSenderChatResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostBanChatSenderChatResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostCloseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool `json:"ok"`
		Result bool `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostCloseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCloseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostCopyMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok bool `json:"ok"`

		// This object represents a unique message identifier.
		Result MessageId `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostCopyMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCopyMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostCreateChatInviteLinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok bool `json:"ok"`

		// Represents an invite link for a chat.
		Result ChatInviteLink `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostCreateChatInviteLinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCreateChatInviteLinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostCreateInvoiceLinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool   `json:"ok"`
		Result string `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostCreateInvoiceLinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCreateInvoiceLinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostCreateNewStickerSetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool `json:"ok"`
		Result bool `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostCreateNewStickerSetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCreateNewStickerSetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostDeclineChatJoinRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool `json:"ok"`
		Result bool `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostDeclineChatJoinRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostDeclineChatJoinRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostDeleteChatPhotoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool `json:"ok"`
		Result bool `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostDeleteChatPhotoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostDeleteChatPhotoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostDeleteChatStickerSetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool `json:"ok"`
		Result bool `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostDeleteChatStickerSetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostDeleteChatStickerSetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostDeleteMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool `json:"ok"`
		Result bool `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostDeleteMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostDeleteMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostDeleteMyCommandsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool `json:"ok"`
		Result bool `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostDeleteMyCommandsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostDeleteMyCommandsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostDeleteStickerFromSetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool `json:"ok"`
		Result bool `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostDeleteStickerFromSetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostDeleteStickerFromSetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostDeleteWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool `json:"ok"`
		Result bool `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostDeleteWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostDeleteWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostEditChatInviteLinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok bool `json:"ok"`

		// Represents an invite link for a chat.
		Result ChatInviteLink `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostEditChatInviteLinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostEditChatInviteLinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostEditMessageCaptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool        `json:"ok"`
		Result interface{} `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostEditMessageCaptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostEditMessageCaptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostEditMessageLiveLocationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool        `json:"ok"`
		Result interface{} `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostEditMessageLiveLocationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostEditMessageLiveLocationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostEditMessageMediaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool        `json:"ok"`
		Result interface{} `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostEditMessageMediaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostEditMessageMediaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostEditMessageReplyMarkupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool        `json:"ok"`
		Result interface{} `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostEditMessageReplyMarkupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostEditMessageReplyMarkupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostEditMessageTextResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool        `json:"ok"`
		Result interface{} `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostEditMessageTextResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostEditMessageTextResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostExportChatInviteLinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool   `json:"ok"`
		Result string `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostExportChatInviteLinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostExportChatInviteLinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostForwardMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok bool `json:"ok"`

		// This object represents a message.
		Result Message `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostForwardMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostForwardMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostGetChatResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok bool `json:"ok"`

		// This object represents a chat.
		Result Chat `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostGetChatResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostGetChatResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostGetChatAdministratorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool         `json:"ok"`
		Result []ChatMember `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostGetChatAdministratorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostGetChatAdministratorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostGetChatMemberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok bool `json:"ok"`

		// This object contains information about one member of a chat. Currently, the following 6 types of chat members are supported:
		//
		// * [ChatMemberOwner](https://core.telegram.org/bots/api/#chatmemberowner)
		// * [ChatMemberAdministrator](https://core.telegram.org/bots/api/#chatmemberadministrator)
		// * [ChatMemberMember](https://core.telegram.org/bots/api/#chatmembermember)
		// * [ChatMemberRestricted](https://core.telegram.org/bots/api/#chatmemberrestricted)
		// * [ChatMemberLeft](https://core.telegram.org/bots/api/#chatmemberleft)
		// * [ChatMemberBanned](https://core.telegram.org/bots/api/#chatmemberbanned)
		Result ChatMember `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostGetChatMemberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostGetChatMemberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostGetChatMemberCountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool `json:"ok"`
		Result int  `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostGetChatMemberCountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostGetChatMemberCountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostGetChatMenuButtonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok bool `json:"ok"`

		// This object describes the bot's menu button in a private chat. It should be one of
		//
		// * [MenuButtonCommands](https://core.telegram.org/bots/api/#menubuttoncommands)
		// * [MenuButtonWebApp](https://core.telegram.org/bots/api/#menubuttonwebapp)
		// * [MenuButtonDefault](https://core.telegram.org/bots/api/#menubuttondefault)
		Result MenuButton `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostGetChatMenuButtonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostGetChatMenuButtonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostGetFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok bool `json:"ok"`

		// This object represents a file ready to be downloaded. The file can be downloaded via the link `https://api.telegram.org/file/bot<token>/<file_path>`. It is guaranteed that the link will be valid for at least 1 hour. When the link expires, a new one can be requested by calling [getFile](https://core.telegram.org/bots/api/#getfile).
		//
		// The maximum file size to download is 20 MB
		Result File `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostGetFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostGetFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostGetGameHighScoresResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool            `json:"ok"`
		Result []GameHighScore `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostGetGameHighScoresResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostGetGameHighScoresResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostGetMeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok bool `json:"ok"`

		// This object represents a Telegram user or bot.
		Result User `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostGetMeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostGetMeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostGetMyCommandsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool         `json:"ok"`
		Result []BotCommand `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostGetMyCommandsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostGetMyCommandsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostGetMyDefaultAdministratorRightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok bool `json:"ok"`

		// Represents the rights of an administrator in a chat.
		Result ChatAdministratorRights `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostGetMyDefaultAdministratorRightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostGetMyDefaultAdministratorRightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostGetStickerSetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok bool `json:"ok"`

		// This object represents a sticker set.
		Result StickerSet `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostGetStickerSetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostGetStickerSetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostGetUpdatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool     `json:"ok"`
		Result []Update `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostGetUpdatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostGetUpdatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostGetUserProfilePhotosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok bool `json:"ok"`

		// This object represent a user's profile pictures.
		Result UserProfilePhotos `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostGetUserProfilePhotosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostGetUserProfilePhotosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostGetWebhookInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok bool `json:"ok"`

		// Describes the current status of a webhook.
		Result WebhookInfo `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostGetWebhookInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostGetWebhookInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostLeaveChatResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool `json:"ok"`
		Result bool `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostLeaveChatResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostLeaveChatResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostLogOutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool `json:"ok"`
		Result bool `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostLogOutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostLogOutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostPinChatMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool `json:"ok"`
		Result bool `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostPinChatMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostPinChatMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostPromoteChatMemberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool `json:"ok"`
		Result bool `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostPromoteChatMemberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostPromoteChatMemberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostRestrictChatMemberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool `json:"ok"`
		Result bool `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostRestrictChatMemberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostRestrictChatMemberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostRevokeChatInviteLinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok bool `json:"ok"`

		// Represents an invite link for a chat.
		Result ChatInviteLink `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostRevokeChatInviteLinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostRevokeChatInviteLinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSendAnimationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok bool `json:"ok"`

		// This object represents a message.
		Result Message `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostSendAnimationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSendAnimationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSendAudioResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok bool `json:"ok"`

		// This object represents a message.
		Result Message `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostSendAudioResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSendAudioResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSendChatActionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool `json:"ok"`
		Result bool `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostSendChatActionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSendChatActionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSendContactResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok bool `json:"ok"`

		// This object represents a message.
		Result Message `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostSendContactResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSendContactResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSendDiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok bool `json:"ok"`

		// This object represents a message.
		Result Message `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostSendDiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSendDiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSendDocumentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok bool `json:"ok"`

		// This object represents a message.
		Result Message `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostSendDocumentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSendDocumentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSendGameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok bool `json:"ok"`

		// This object represents a message.
		Result Message `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostSendGameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSendGameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSendInvoiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok bool `json:"ok"`

		// This object represents a message.
		Result Message `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostSendInvoiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSendInvoiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSendLocationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok bool `json:"ok"`

		// This object represents a message.
		Result Message `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostSendLocationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSendLocationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSendMediaGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool      `json:"ok"`
		Result []Message `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostSendMediaGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSendMediaGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSendMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok bool `json:"ok"`

		// This object represents a message.
		Result Message `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostSendMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSendMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSendPhotoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok bool `json:"ok"`

		// This object represents a message.
		Result Message `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostSendPhotoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSendPhotoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSendPollResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok bool `json:"ok"`

		// This object represents a message.
		Result Message `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostSendPollResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSendPollResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSendStickerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok bool `json:"ok"`

		// This object represents a message.
		Result Message `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostSendStickerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSendStickerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSendVenueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok bool `json:"ok"`

		// This object represents a message.
		Result Message `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostSendVenueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSendVenueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSendVideoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok bool `json:"ok"`

		// This object represents a message.
		Result Message `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostSendVideoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSendVideoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSendVideoNoteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok bool `json:"ok"`

		// This object represents a message.
		Result Message `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostSendVideoNoteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSendVideoNoteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSendVoiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok bool `json:"ok"`

		// This object represents a message.
		Result Message `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostSendVoiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSendVoiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSetChatAdministratorCustomTitleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool `json:"ok"`
		Result bool `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostSetChatAdministratorCustomTitleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSetChatAdministratorCustomTitleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSetChatDescriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool `json:"ok"`
		Result bool `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostSetChatDescriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSetChatDescriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSetChatMenuButtonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool `json:"ok"`
		Result bool `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostSetChatMenuButtonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSetChatMenuButtonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSetChatPermissionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool `json:"ok"`
		Result bool `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostSetChatPermissionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSetChatPermissionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSetChatPhotoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool `json:"ok"`
		Result bool `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostSetChatPhotoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSetChatPhotoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSetChatStickerSetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool `json:"ok"`
		Result bool `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostSetChatStickerSetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSetChatStickerSetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSetChatTitleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool `json:"ok"`
		Result bool `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostSetChatTitleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSetChatTitleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSetGameScoreResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool        `json:"ok"`
		Result interface{} `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostSetGameScoreResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSetGameScoreResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSetMyCommandsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool `json:"ok"`
		Result bool `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostSetMyCommandsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSetMyCommandsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSetMyDefaultAdministratorRightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool `json:"ok"`
		Result bool `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostSetMyDefaultAdministratorRightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSetMyDefaultAdministratorRightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSetPassportDataErrorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool `json:"ok"`
		Result bool `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostSetPassportDataErrorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSetPassportDataErrorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSetStickerPositionInSetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool `json:"ok"`
		Result bool `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostSetStickerPositionInSetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSetStickerPositionInSetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSetStickerSetThumbResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool `json:"ok"`
		Result bool `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostSetStickerSetThumbResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSetStickerSetThumbResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSetWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool `json:"ok"`
		Result bool `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostSetWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSetWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostStopMessageLiveLocationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool        `json:"ok"`
		Result interface{} `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostStopMessageLiveLocationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostStopMessageLiveLocationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostStopPollResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok bool `json:"ok"`

		// This object contains information about a poll.
		Result Poll `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostStopPollResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostStopPollResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostUnbanChatMemberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool `json:"ok"`
		Result bool `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostUnbanChatMemberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostUnbanChatMemberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostUnbanChatSenderChatResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool `json:"ok"`
		Result bool `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostUnbanChatSenderChatResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostUnbanChatSenderChatResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostUnpinAllChatMessagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool `json:"ok"`
		Result bool `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostUnpinAllChatMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostUnpinAllChatMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostUnpinChatMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok     bool `json:"ok"`
		Result bool `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostUnpinChatMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostUnpinChatMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostUploadStickerFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ok bool `json:"ok"`

		// This object represents a file ready to be downloaded. The file can be downloaded via the link `https://api.telegram.org/file/bot<token>/<file_path>`. It is guaranteed that the link will be valid for at least 1 hour. When the link expires, a new one can be requested by calling [getFile](https://core.telegram.org/bots/api/#getfile).
		//
		// The maximum file size to download is 20 MB
		Result File `json:"result"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PostUploadStickerFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostUploadStickerFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// PostAddStickerToSetWithBodyWithResponse request with arbitrary body returning *PostAddStickerToSetResponse
func (c *ClientWithResponses) PostAddStickerToSetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAddStickerToSetResponse, error) {
	rsp, err := c.PostAddStickerToSetWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAddStickerToSetResponse(rsp)
}

// PostAnswerCallbackQueryWithBodyWithResponse request with arbitrary body returning *PostAnswerCallbackQueryResponse
func (c *ClientWithResponses) PostAnswerCallbackQueryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAnswerCallbackQueryResponse, error) {
	rsp, err := c.PostAnswerCallbackQueryWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAnswerCallbackQueryResponse(rsp)
}

func (c *ClientWithResponses) PostAnswerCallbackQueryWithResponse(ctx context.Context, body PostAnswerCallbackQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAnswerCallbackQueryResponse, error) {
	rsp, err := c.PostAnswerCallbackQuery(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAnswerCallbackQueryResponse(rsp)
}

// PostAnswerInlineQueryWithBodyWithResponse request with arbitrary body returning *PostAnswerInlineQueryResponse
func (c *ClientWithResponses) PostAnswerInlineQueryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAnswerInlineQueryResponse, error) {
	rsp, err := c.PostAnswerInlineQueryWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAnswerInlineQueryResponse(rsp)
}

func (c *ClientWithResponses) PostAnswerInlineQueryWithResponse(ctx context.Context, body PostAnswerInlineQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAnswerInlineQueryResponse, error) {
	rsp, err := c.PostAnswerInlineQuery(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAnswerInlineQueryResponse(rsp)
}

// PostAnswerPreCheckoutQueryWithBodyWithResponse request with arbitrary body returning *PostAnswerPreCheckoutQueryResponse
func (c *ClientWithResponses) PostAnswerPreCheckoutQueryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAnswerPreCheckoutQueryResponse, error) {
	rsp, err := c.PostAnswerPreCheckoutQueryWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAnswerPreCheckoutQueryResponse(rsp)
}

func (c *ClientWithResponses) PostAnswerPreCheckoutQueryWithResponse(ctx context.Context, body PostAnswerPreCheckoutQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAnswerPreCheckoutQueryResponse, error) {
	rsp, err := c.PostAnswerPreCheckoutQuery(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAnswerPreCheckoutQueryResponse(rsp)
}

// PostAnswerShippingQueryWithBodyWithResponse request with arbitrary body returning *PostAnswerShippingQueryResponse
func (c *ClientWithResponses) PostAnswerShippingQueryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAnswerShippingQueryResponse, error) {
	rsp, err := c.PostAnswerShippingQueryWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAnswerShippingQueryResponse(rsp)
}

func (c *ClientWithResponses) PostAnswerShippingQueryWithResponse(ctx context.Context, body PostAnswerShippingQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAnswerShippingQueryResponse, error) {
	rsp, err := c.PostAnswerShippingQuery(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAnswerShippingQueryResponse(rsp)
}

// PostAnswerWebAppQueryWithBodyWithResponse request with arbitrary body returning *PostAnswerWebAppQueryResponse
func (c *ClientWithResponses) PostAnswerWebAppQueryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAnswerWebAppQueryResponse, error) {
	rsp, err := c.PostAnswerWebAppQueryWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAnswerWebAppQueryResponse(rsp)
}

func (c *ClientWithResponses) PostAnswerWebAppQueryWithResponse(ctx context.Context, body PostAnswerWebAppQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAnswerWebAppQueryResponse, error) {
	rsp, err := c.PostAnswerWebAppQuery(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAnswerWebAppQueryResponse(rsp)
}

// PostApproveChatJoinRequestWithBodyWithResponse request with arbitrary body returning *PostApproveChatJoinRequestResponse
func (c *ClientWithResponses) PostApproveChatJoinRequestWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApproveChatJoinRequestResponse, error) {
	rsp, err := c.PostApproveChatJoinRequestWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApproveChatJoinRequestResponse(rsp)
}

func (c *ClientWithResponses) PostApproveChatJoinRequestWithResponse(ctx context.Context, body PostApproveChatJoinRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApproveChatJoinRequestResponse, error) {
	rsp, err := c.PostApproveChatJoinRequest(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApproveChatJoinRequestResponse(rsp)
}

// PostBanChatMemberWithBodyWithResponse request with arbitrary body returning *PostBanChatMemberResponse
func (c *ClientWithResponses) PostBanChatMemberWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostBanChatMemberResponse, error) {
	rsp, err := c.PostBanChatMemberWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostBanChatMemberResponse(rsp)
}

func (c *ClientWithResponses) PostBanChatMemberWithResponse(ctx context.Context, body PostBanChatMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*PostBanChatMemberResponse, error) {
	rsp, err := c.PostBanChatMember(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostBanChatMemberResponse(rsp)
}

// PostBanChatSenderChatWithBodyWithResponse request with arbitrary body returning *PostBanChatSenderChatResponse
func (c *ClientWithResponses) PostBanChatSenderChatWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostBanChatSenderChatResponse, error) {
	rsp, err := c.PostBanChatSenderChatWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostBanChatSenderChatResponse(rsp)
}

func (c *ClientWithResponses) PostBanChatSenderChatWithResponse(ctx context.Context, body PostBanChatSenderChatJSONRequestBody, reqEditors ...RequestEditorFn) (*PostBanChatSenderChatResponse, error) {
	rsp, err := c.PostBanChatSenderChat(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostBanChatSenderChatResponse(rsp)
}

// PostCloseWithResponse request returning *PostCloseResponse
func (c *ClientWithResponses) PostCloseWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostCloseResponse, error) {
	rsp, err := c.PostClose(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCloseResponse(rsp)
}

// PostCopyMessageWithBodyWithResponse request with arbitrary body returning *PostCopyMessageResponse
func (c *ClientWithResponses) PostCopyMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCopyMessageResponse, error) {
	rsp, err := c.PostCopyMessageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCopyMessageResponse(rsp)
}

func (c *ClientWithResponses) PostCopyMessageWithResponse(ctx context.Context, body PostCopyMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCopyMessageResponse, error) {
	rsp, err := c.PostCopyMessage(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCopyMessageResponse(rsp)
}

// PostCreateChatInviteLinkWithBodyWithResponse request with arbitrary body returning *PostCreateChatInviteLinkResponse
func (c *ClientWithResponses) PostCreateChatInviteLinkWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCreateChatInviteLinkResponse, error) {
	rsp, err := c.PostCreateChatInviteLinkWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCreateChatInviteLinkResponse(rsp)
}

func (c *ClientWithResponses) PostCreateChatInviteLinkWithResponse(ctx context.Context, body PostCreateChatInviteLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCreateChatInviteLinkResponse, error) {
	rsp, err := c.PostCreateChatInviteLink(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCreateChatInviteLinkResponse(rsp)
}

// PostCreateInvoiceLinkWithBodyWithResponse request with arbitrary body returning *PostCreateInvoiceLinkResponse
func (c *ClientWithResponses) PostCreateInvoiceLinkWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCreateInvoiceLinkResponse, error) {
	rsp, err := c.PostCreateInvoiceLinkWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCreateInvoiceLinkResponse(rsp)
}

func (c *ClientWithResponses) PostCreateInvoiceLinkWithResponse(ctx context.Context, body PostCreateInvoiceLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCreateInvoiceLinkResponse, error) {
	rsp, err := c.PostCreateInvoiceLink(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCreateInvoiceLinkResponse(rsp)
}

// PostCreateNewStickerSetWithBodyWithResponse request with arbitrary body returning *PostCreateNewStickerSetResponse
func (c *ClientWithResponses) PostCreateNewStickerSetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCreateNewStickerSetResponse, error) {
	rsp, err := c.PostCreateNewStickerSetWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCreateNewStickerSetResponse(rsp)
}

// PostDeclineChatJoinRequestWithBodyWithResponse request with arbitrary body returning *PostDeclineChatJoinRequestResponse
func (c *ClientWithResponses) PostDeclineChatJoinRequestWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDeclineChatJoinRequestResponse, error) {
	rsp, err := c.PostDeclineChatJoinRequestWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDeclineChatJoinRequestResponse(rsp)
}

func (c *ClientWithResponses) PostDeclineChatJoinRequestWithResponse(ctx context.Context, body PostDeclineChatJoinRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDeclineChatJoinRequestResponse, error) {
	rsp, err := c.PostDeclineChatJoinRequest(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDeclineChatJoinRequestResponse(rsp)
}

// PostDeleteChatPhotoWithBodyWithResponse request with arbitrary body returning *PostDeleteChatPhotoResponse
func (c *ClientWithResponses) PostDeleteChatPhotoWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDeleteChatPhotoResponse, error) {
	rsp, err := c.PostDeleteChatPhotoWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDeleteChatPhotoResponse(rsp)
}

func (c *ClientWithResponses) PostDeleteChatPhotoWithResponse(ctx context.Context, body PostDeleteChatPhotoJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDeleteChatPhotoResponse, error) {
	rsp, err := c.PostDeleteChatPhoto(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDeleteChatPhotoResponse(rsp)
}

// PostDeleteChatStickerSetWithBodyWithResponse request with arbitrary body returning *PostDeleteChatStickerSetResponse
func (c *ClientWithResponses) PostDeleteChatStickerSetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDeleteChatStickerSetResponse, error) {
	rsp, err := c.PostDeleteChatStickerSetWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDeleteChatStickerSetResponse(rsp)
}

func (c *ClientWithResponses) PostDeleteChatStickerSetWithResponse(ctx context.Context, body PostDeleteChatStickerSetJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDeleteChatStickerSetResponse, error) {
	rsp, err := c.PostDeleteChatStickerSet(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDeleteChatStickerSetResponse(rsp)
}

// PostDeleteMessageWithBodyWithResponse request with arbitrary body returning *PostDeleteMessageResponse
func (c *ClientWithResponses) PostDeleteMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDeleteMessageResponse, error) {
	rsp, err := c.PostDeleteMessageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDeleteMessageResponse(rsp)
}

func (c *ClientWithResponses) PostDeleteMessageWithResponse(ctx context.Context, body PostDeleteMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDeleteMessageResponse, error) {
	rsp, err := c.PostDeleteMessage(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDeleteMessageResponse(rsp)
}

// PostDeleteMyCommandsWithBodyWithResponse request with arbitrary body returning *PostDeleteMyCommandsResponse
func (c *ClientWithResponses) PostDeleteMyCommandsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDeleteMyCommandsResponse, error) {
	rsp, err := c.PostDeleteMyCommandsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDeleteMyCommandsResponse(rsp)
}

func (c *ClientWithResponses) PostDeleteMyCommandsWithResponse(ctx context.Context, body PostDeleteMyCommandsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDeleteMyCommandsResponse, error) {
	rsp, err := c.PostDeleteMyCommands(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDeleteMyCommandsResponse(rsp)
}

// PostDeleteStickerFromSetWithBodyWithResponse request with arbitrary body returning *PostDeleteStickerFromSetResponse
func (c *ClientWithResponses) PostDeleteStickerFromSetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDeleteStickerFromSetResponse, error) {
	rsp, err := c.PostDeleteStickerFromSetWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDeleteStickerFromSetResponse(rsp)
}

func (c *ClientWithResponses) PostDeleteStickerFromSetWithResponse(ctx context.Context, body PostDeleteStickerFromSetJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDeleteStickerFromSetResponse, error) {
	rsp, err := c.PostDeleteStickerFromSet(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDeleteStickerFromSetResponse(rsp)
}

// PostDeleteWebhookWithBodyWithResponse request with arbitrary body returning *PostDeleteWebhookResponse
func (c *ClientWithResponses) PostDeleteWebhookWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDeleteWebhookResponse, error) {
	rsp, err := c.PostDeleteWebhookWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDeleteWebhookResponse(rsp)
}

func (c *ClientWithResponses) PostDeleteWebhookWithResponse(ctx context.Context, body PostDeleteWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDeleteWebhookResponse, error) {
	rsp, err := c.PostDeleteWebhook(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDeleteWebhookResponse(rsp)
}

// PostEditChatInviteLinkWithBodyWithResponse request with arbitrary body returning *PostEditChatInviteLinkResponse
func (c *ClientWithResponses) PostEditChatInviteLinkWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostEditChatInviteLinkResponse, error) {
	rsp, err := c.PostEditChatInviteLinkWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostEditChatInviteLinkResponse(rsp)
}

func (c *ClientWithResponses) PostEditChatInviteLinkWithResponse(ctx context.Context, body PostEditChatInviteLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*PostEditChatInviteLinkResponse, error) {
	rsp, err := c.PostEditChatInviteLink(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostEditChatInviteLinkResponse(rsp)
}

// PostEditMessageCaptionWithBodyWithResponse request with arbitrary body returning *PostEditMessageCaptionResponse
func (c *ClientWithResponses) PostEditMessageCaptionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostEditMessageCaptionResponse, error) {
	rsp, err := c.PostEditMessageCaptionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostEditMessageCaptionResponse(rsp)
}

func (c *ClientWithResponses) PostEditMessageCaptionWithResponse(ctx context.Context, body PostEditMessageCaptionJSONRequestBody, reqEditors ...RequestEditorFn) (*PostEditMessageCaptionResponse, error) {
	rsp, err := c.PostEditMessageCaption(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostEditMessageCaptionResponse(rsp)
}

// PostEditMessageLiveLocationWithBodyWithResponse request with arbitrary body returning *PostEditMessageLiveLocationResponse
func (c *ClientWithResponses) PostEditMessageLiveLocationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostEditMessageLiveLocationResponse, error) {
	rsp, err := c.PostEditMessageLiveLocationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostEditMessageLiveLocationResponse(rsp)
}

func (c *ClientWithResponses) PostEditMessageLiveLocationWithResponse(ctx context.Context, body PostEditMessageLiveLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*PostEditMessageLiveLocationResponse, error) {
	rsp, err := c.PostEditMessageLiveLocation(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostEditMessageLiveLocationResponse(rsp)
}

// PostEditMessageMediaWithBodyWithResponse request with arbitrary body returning *PostEditMessageMediaResponse
func (c *ClientWithResponses) PostEditMessageMediaWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostEditMessageMediaResponse, error) {
	rsp, err := c.PostEditMessageMediaWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostEditMessageMediaResponse(rsp)
}

// PostEditMessageReplyMarkupWithBodyWithResponse request with arbitrary body returning *PostEditMessageReplyMarkupResponse
func (c *ClientWithResponses) PostEditMessageReplyMarkupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostEditMessageReplyMarkupResponse, error) {
	rsp, err := c.PostEditMessageReplyMarkupWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostEditMessageReplyMarkupResponse(rsp)
}

func (c *ClientWithResponses) PostEditMessageReplyMarkupWithResponse(ctx context.Context, body PostEditMessageReplyMarkupJSONRequestBody, reqEditors ...RequestEditorFn) (*PostEditMessageReplyMarkupResponse, error) {
	rsp, err := c.PostEditMessageReplyMarkup(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostEditMessageReplyMarkupResponse(rsp)
}

// PostEditMessageTextWithBodyWithResponse request with arbitrary body returning *PostEditMessageTextResponse
func (c *ClientWithResponses) PostEditMessageTextWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostEditMessageTextResponse, error) {
	rsp, err := c.PostEditMessageTextWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostEditMessageTextResponse(rsp)
}

func (c *ClientWithResponses) PostEditMessageTextWithResponse(ctx context.Context, body PostEditMessageTextJSONRequestBody, reqEditors ...RequestEditorFn) (*PostEditMessageTextResponse, error) {
	rsp, err := c.PostEditMessageText(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostEditMessageTextResponse(rsp)
}

// PostExportChatInviteLinkWithBodyWithResponse request with arbitrary body returning *PostExportChatInviteLinkResponse
func (c *ClientWithResponses) PostExportChatInviteLinkWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostExportChatInviteLinkResponse, error) {
	rsp, err := c.PostExportChatInviteLinkWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostExportChatInviteLinkResponse(rsp)
}

func (c *ClientWithResponses) PostExportChatInviteLinkWithResponse(ctx context.Context, body PostExportChatInviteLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*PostExportChatInviteLinkResponse, error) {
	rsp, err := c.PostExportChatInviteLink(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostExportChatInviteLinkResponse(rsp)
}

// PostForwardMessageWithBodyWithResponse request with arbitrary body returning *PostForwardMessageResponse
func (c *ClientWithResponses) PostForwardMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostForwardMessageResponse, error) {
	rsp, err := c.PostForwardMessageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostForwardMessageResponse(rsp)
}

func (c *ClientWithResponses) PostForwardMessageWithResponse(ctx context.Context, body PostForwardMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*PostForwardMessageResponse, error) {
	rsp, err := c.PostForwardMessage(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostForwardMessageResponse(rsp)
}

// PostGetChatWithBodyWithResponse request with arbitrary body returning *PostGetChatResponse
func (c *ClientWithResponses) PostGetChatWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostGetChatResponse, error) {
	rsp, err := c.PostGetChatWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostGetChatResponse(rsp)
}

func (c *ClientWithResponses) PostGetChatWithResponse(ctx context.Context, body PostGetChatJSONRequestBody, reqEditors ...RequestEditorFn) (*PostGetChatResponse, error) {
	rsp, err := c.PostGetChat(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostGetChatResponse(rsp)
}

// PostGetChatAdministratorsWithBodyWithResponse request with arbitrary body returning *PostGetChatAdministratorsResponse
func (c *ClientWithResponses) PostGetChatAdministratorsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostGetChatAdministratorsResponse, error) {
	rsp, err := c.PostGetChatAdministratorsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostGetChatAdministratorsResponse(rsp)
}

func (c *ClientWithResponses) PostGetChatAdministratorsWithResponse(ctx context.Context, body PostGetChatAdministratorsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostGetChatAdministratorsResponse, error) {
	rsp, err := c.PostGetChatAdministrators(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostGetChatAdministratorsResponse(rsp)
}

// PostGetChatMemberWithBodyWithResponse request with arbitrary body returning *PostGetChatMemberResponse
func (c *ClientWithResponses) PostGetChatMemberWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostGetChatMemberResponse, error) {
	rsp, err := c.PostGetChatMemberWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostGetChatMemberResponse(rsp)
}

func (c *ClientWithResponses) PostGetChatMemberWithResponse(ctx context.Context, body PostGetChatMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*PostGetChatMemberResponse, error) {
	rsp, err := c.PostGetChatMember(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostGetChatMemberResponse(rsp)
}

// PostGetChatMemberCountWithBodyWithResponse request with arbitrary body returning *PostGetChatMemberCountResponse
func (c *ClientWithResponses) PostGetChatMemberCountWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostGetChatMemberCountResponse, error) {
	rsp, err := c.PostGetChatMemberCountWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostGetChatMemberCountResponse(rsp)
}

func (c *ClientWithResponses) PostGetChatMemberCountWithResponse(ctx context.Context, body PostGetChatMemberCountJSONRequestBody, reqEditors ...RequestEditorFn) (*PostGetChatMemberCountResponse, error) {
	rsp, err := c.PostGetChatMemberCount(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostGetChatMemberCountResponse(rsp)
}

// PostGetChatMenuButtonWithBodyWithResponse request with arbitrary body returning *PostGetChatMenuButtonResponse
func (c *ClientWithResponses) PostGetChatMenuButtonWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostGetChatMenuButtonResponse, error) {
	rsp, err := c.PostGetChatMenuButtonWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostGetChatMenuButtonResponse(rsp)
}

func (c *ClientWithResponses) PostGetChatMenuButtonWithResponse(ctx context.Context, body PostGetChatMenuButtonJSONRequestBody, reqEditors ...RequestEditorFn) (*PostGetChatMenuButtonResponse, error) {
	rsp, err := c.PostGetChatMenuButton(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostGetChatMenuButtonResponse(rsp)
}

// PostGetFileWithBodyWithResponse request with arbitrary body returning *PostGetFileResponse
func (c *ClientWithResponses) PostGetFileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostGetFileResponse, error) {
	rsp, err := c.PostGetFileWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostGetFileResponse(rsp)
}

func (c *ClientWithResponses) PostGetFileWithResponse(ctx context.Context, body PostGetFileJSONRequestBody, reqEditors ...RequestEditorFn) (*PostGetFileResponse, error) {
	rsp, err := c.PostGetFile(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostGetFileResponse(rsp)
}

// PostGetGameHighScoresWithBodyWithResponse request with arbitrary body returning *PostGetGameHighScoresResponse
func (c *ClientWithResponses) PostGetGameHighScoresWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostGetGameHighScoresResponse, error) {
	rsp, err := c.PostGetGameHighScoresWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostGetGameHighScoresResponse(rsp)
}

func (c *ClientWithResponses) PostGetGameHighScoresWithResponse(ctx context.Context, body PostGetGameHighScoresJSONRequestBody, reqEditors ...RequestEditorFn) (*PostGetGameHighScoresResponse, error) {
	rsp, err := c.PostGetGameHighScores(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostGetGameHighScoresResponse(rsp)
}

// PostGetMeWithResponse request returning *PostGetMeResponse
func (c *ClientWithResponses) PostGetMeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostGetMeResponse, error) {
	rsp, err := c.PostGetMe(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostGetMeResponse(rsp)
}

// PostGetMyCommandsWithBodyWithResponse request with arbitrary body returning *PostGetMyCommandsResponse
func (c *ClientWithResponses) PostGetMyCommandsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostGetMyCommandsResponse, error) {
	rsp, err := c.PostGetMyCommandsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostGetMyCommandsResponse(rsp)
}

func (c *ClientWithResponses) PostGetMyCommandsWithResponse(ctx context.Context, body PostGetMyCommandsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostGetMyCommandsResponse, error) {
	rsp, err := c.PostGetMyCommands(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostGetMyCommandsResponse(rsp)
}

// PostGetMyDefaultAdministratorRightsWithBodyWithResponse request with arbitrary body returning *PostGetMyDefaultAdministratorRightsResponse
func (c *ClientWithResponses) PostGetMyDefaultAdministratorRightsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostGetMyDefaultAdministratorRightsResponse, error) {
	rsp, err := c.PostGetMyDefaultAdministratorRightsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostGetMyDefaultAdministratorRightsResponse(rsp)
}

func (c *ClientWithResponses) PostGetMyDefaultAdministratorRightsWithResponse(ctx context.Context, body PostGetMyDefaultAdministratorRightsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostGetMyDefaultAdministratorRightsResponse, error) {
	rsp, err := c.PostGetMyDefaultAdministratorRights(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostGetMyDefaultAdministratorRightsResponse(rsp)
}

// PostGetStickerSetWithBodyWithResponse request with arbitrary body returning *PostGetStickerSetResponse
func (c *ClientWithResponses) PostGetStickerSetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostGetStickerSetResponse, error) {
	rsp, err := c.PostGetStickerSetWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostGetStickerSetResponse(rsp)
}

func (c *ClientWithResponses) PostGetStickerSetWithResponse(ctx context.Context, body PostGetStickerSetJSONRequestBody, reqEditors ...RequestEditorFn) (*PostGetStickerSetResponse, error) {
	rsp, err := c.PostGetStickerSet(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostGetStickerSetResponse(rsp)
}

// PostGetUpdatesWithBodyWithResponse request with arbitrary body returning *PostGetUpdatesResponse
func (c *ClientWithResponses) PostGetUpdatesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostGetUpdatesResponse, error) {
	rsp, err := c.PostGetUpdatesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostGetUpdatesResponse(rsp)
}

func (c *ClientWithResponses) PostGetUpdatesWithResponse(ctx context.Context, body PostGetUpdatesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostGetUpdatesResponse, error) {
	rsp, err := c.PostGetUpdates(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostGetUpdatesResponse(rsp)
}

// PostGetUserProfilePhotosWithBodyWithResponse request with arbitrary body returning *PostGetUserProfilePhotosResponse
func (c *ClientWithResponses) PostGetUserProfilePhotosWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostGetUserProfilePhotosResponse, error) {
	rsp, err := c.PostGetUserProfilePhotosWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostGetUserProfilePhotosResponse(rsp)
}

func (c *ClientWithResponses) PostGetUserProfilePhotosWithResponse(ctx context.Context, body PostGetUserProfilePhotosJSONRequestBody, reqEditors ...RequestEditorFn) (*PostGetUserProfilePhotosResponse, error) {
	rsp, err := c.PostGetUserProfilePhotos(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostGetUserProfilePhotosResponse(rsp)
}

// PostGetWebhookInfoWithResponse request returning *PostGetWebhookInfoResponse
func (c *ClientWithResponses) PostGetWebhookInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostGetWebhookInfoResponse, error) {
	rsp, err := c.PostGetWebhookInfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostGetWebhookInfoResponse(rsp)
}

// PostLeaveChatWithBodyWithResponse request with arbitrary body returning *PostLeaveChatResponse
func (c *ClientWithResponses) PostLeaveChatWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostLeaveChatResponse, error) {
	rsp, err := c.PostLeaveChatWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostLeaveChatResponse(rsp)
}

func (c *ClientWithResponses) PostLeaveChatWithResponse(ctx context.Context, body PostLeaveChatJSONRequestBody, reqEditors ...RequestEditorFn) (*PostLeaveChatResponse, error) {
	rsp, err := c.PostLeaveChat(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostLeaveChatResponse(rsp)
}

// PostLogOutWithResponse request returning *PostLogOutResponse
func (c *ClientWithResponses) PostLogOutWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostLogOutResponse, error) {
	rsp, err := c.PostLogOut(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostLogOutResponse(rsp)
}

// PostPinChatMessageWithBodyWithResponse request with arbitrary body returning *PostPinChatMessageResponse
func (c *ClientWithResponses) PostPinChatMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPinChatMessageResponse, error) {
	rsp, err := c.PostPinChatMessageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPinChatMessageResponse(rsp)
}

func (c *ClientWithResponses) PostPinChatMessageWithResponse(ctx context.Context, body PostPinChatMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPinChatMessageResponse, error) {
	rsp, err := c.PostPinChatMessage(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPinChatMessageResponse(rsp)
}

// PostPromoteChatMemberWithBodyWithResponse request with arbitrary body returning *PostPromoteChatMemberResponse
func (c *ClientWithResponses) PostPromoteChatMemberWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPromoteChatMemberResponse, error) {
	rsp, err := c.PostPromoteChatMemberWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPromoteChatMemberResponse(rsp)
}

func (c *ClientWithResponses) PostPromoteChatMemberWithResponse(ctx context.Context, body PostPromoteChatMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPromoteChatMemberResponse, error) {
	rsp, err := c.PostPromoteChatMember(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPromoteChatMemberResponse(rsp)
}

// PostRestrictChatMemberWithBodyWithResponse request with arbitrary body returning *PostRestrictChatMemberResponse
func (c *ClientWithResponses) PostRestrictChatMemberWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostRestrictChatMemberResponse, error) {
	rsp, err := c.PostRestrictChatMemberWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRestrictChatMemberResponse(rsp)
}

func (c *ClientWithResponses) PostRestrictChatMemberWithResponse(ctx context.Context, body PostRestrictChatMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*PostRestrictChatMemberResponse, error) {
	rsp, err := c.PostRestrictChatMember(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRestrictChatMemberResponse(rsp)
}

// PostRevokeChatInviteLinkWithBodyWithResponse request with arbitrary body returning *PostRevokeChatInviteLinkResponse
func (c *ClientWithResponses) PostRevokeChatInviteLinkWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostRevokeChatInviteLinkResponse, error) {
	rsp, err := c.PostRevokeChatInviteLinkWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRevokeChatInviteLinkResponse(rsp)
}

func (c *ClientWithResponses) PostRevokeChatInviteLinkWithResponse(ctx context.Context, body PostRevokeChatInviteLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*PostRevokeChatInviteLinkResponse, error) {
	rsp, err := c.PostRevokeChatInviteLink(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRevokeChatInviteLinkResponse(rsp)
}

// PostSendAnimationWithBodyWithResponse request with arbitrary body returning *PostSendAnimationResponse
func (c *ClientWithResponses) PostSendAnimationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSendAnimationResponse, error) {
	rsp, err := c.PostSendAnimationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSendAnimationResponse(rsp)
}

// PostSendAudioWithBodyWithResponse request with arbitrary body returning *PostSendAudioResponse
func (c *ClientWithResponses) PostSendAudioWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSendAudioResponse, error) {
	rsp, err := c.PostSendAudioWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSendAudioResponse(rsp)
}

// PostSendChatActionWithBodyWithResponse request with arbitrary body returning *PostSendChatActionResponse
func (c *ClientWithResponses) PostSendChatActionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSendChatActionResponse, error) {
	rsp, err := c.PostSendChatActionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSendChatActionResponse(rsp)
}

func (c *ClientWithResponses) PostSendChatActionWithResponse(ctx context.Context, body PostSendChatActionJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSendChatActionResponse, error) {
	rsp, err := c.PostSendChatAction(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSendChatActionResponse(rsp)
}

// PostSendContactWithBodyWithResponse request with arbitrary body returning *PostSendContactResponse
func (c *ClientWithResponses) PostSendContactWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSendContactResponse, error) {
	rsp, err := c.PostSendContactWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSendContactResponse(rsp)
}

func (c *ClientWithResponses) PostSendContactWithResponse(ctx context.Context, body PostSendContactJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSendContactResponse, error) {
	rsp, err := c.PostSendContact(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSendContactResponse(rsp)
}

// PostSendDiceWithBodyWithResponse request with arbitrary body returning *PostSendDiceResponse
func (c *ClientWithResponses) PostSendDiceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSendDiceResponse, error) {
	rsp, err := c.PostSendDiceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSendDiceResponse(rsp)
}

func (c *ClientWithResponses) PostSendDiceWithResponse(ctx context.Context, body PostSendDiceJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSendDiceResponse, error) {
	rsp, err := c.PostSendDice(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSendDiceResponse(rsp)
}

// PostSendDocumentWithBodyWithResponse request with arbitrary body returning *PostSendDocumentResponse
func (c *ClientWithResponses) PostSendDocumentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSendDocumentResponse, error) {
	rsp, err := c.PostSendDocumentWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSendDocumentResponse(rsp)
}

// PostSendGameWithBodyWithResponse request with arbitrary body returning *PostSendGameResponse
func (c *ClientWithResponses) PostSendGameWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSendGameResponse, error) {
	rsp, err := c.PostSendGameWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSendGameResponse(rsp)
}

func (c *ClientWithResponses) PostSendGameWithResponse(ctx context.Context, body PostSendGameJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSendGameResponse, error) {
	rsp, err := c.PostSendGame(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSendGameResponse(rsp)
}

// PostSendInvoiceWithBodyWithResponse request with arbitrary body returning *PostSendInvoiceResponse
func (c *ClientWithResponses) PostSendInvoiceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSendInvoiceResponse, error) {
	rsp, err := c.PostSendInvoiceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSendInvoiceResponse(rsp)
}

func (c *ClientWithResponses) PostSendInvoiceWithResponse(ctx context.Context, body PostSendInvoiceJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSendInvoiceResponse, error) {
	rsp, err := c.PostSendInvoice(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSendInvoiceResponse(rsp)
}

// PostSendLocationWithBodyWithResponse request with arbitrary body returning *PostSendLocationResponse
func (c *ClientWithResponses) PostSendLocationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSendLocationResponse, error) {
	rsp, err := c.PostSendLocationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSendLocationResponse(rsp)
}

func (c *ClientWithResponses) PostSendLocationWithResponse(ctx context.Context, body PostSendLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSendLocationResponse, error) {
	rsp, err := c.PostSendLocation(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSendLocationResponse(rsp)
}

// PostSendMediaGroupWithBodyWithResponse request with arbitrary body returning *PostSendMediaGroupResponse
func (c *ClientWithResponses) PostSendMediaGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSendMediaGroupResponse, error) {
	rsp, err := c.PostSendMediaGroupWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSendMediaGroupResponse(rsp)
}

// PostSendMessageWithBodyWithResponse request with arbitrary body returning *PostSendMessageResponse
func (c *ClientWithResponses) PostSendMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSendMessageResponse, error) {
	rsp, err := c.PostSendMessageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSendMessageResponse(rsp)
}

func (c *ClientWithResponses) PostSendMessageWithResponse(ctx context.Context, body PostSendMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSendMessageResponse, error) {
	rsp, err := c.PostSendMessage(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSendMessageResponse(rsp)
}

// PostSendPhotoWithBodyWithResponse request with arbitrary body returning *PostSendPhotoResponse
func (c *ClientWithResponses) PostSendPhotoWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSendPhotoResponse, error) {
	rsp, err := c.PostSendPhotoWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSendPhotoResponse(rsp)
}

// PostSendPollWithBodyWithResponse request with arbitrary body returning *PostSendPollResponse
func (c *ClientWithResponses) PostSendPollWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSendPollResponse, error) {
	rsp, err := c.PostSendPollWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSendPollResponse(rsp)
}

func (c *ClientWithResponses) PostSendPollWithResponse(ctx context.Context, body PostSendPollJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSendPollResponse, error) {
	rsp, err := c.PostSendPoll(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSendPollResponse(rsp)
}

// PostSendStickerWithBodyWithResponse request with arbitrary body returning *PostSendStickerResponse
func (c *ClientWithResponses) PostSendStickerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSendStickerResponse, error) {
	rsp, err := c.PostSendStickerWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSendStickerResponse(rsp)
}

// PostSendVenueWithBodyWithResponse request with arbitrary body returning *PostSendVenueResponse
func (c *ClientWithResponses) PostSendVenueWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSendVenueResponse, error) {
	rsp, err := c.PostSendVenueWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSendVenueResponse(rsp)
}

func (c *ClientWithResponses) PostSendVenueWithResponse(ctx context.Context, body PostSendVenueJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSendVenueResponse, error) {
	rsp, err := c.PostSendVenue(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSendVenueResponse(rsp)
}

// PostSendVideoWithBodyWithResponse request with arbitrary body returning *PostSendVideoResponse
func (c *ClientWithResponses) PostSendVideoWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSendVideoResponse, error) {
	rsp, err := c.PostSendVideoWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSendVideoResponse(rsp)
}

// PostSendVideoNoteWithBodyWithResponse request with arbitrary body returning *PostSendVideoNoteResponse
func (c *ClientWithResponses) PostSendVideoNoteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSendVideoNoteResponse, error) {
	rsp, err := c.PostSendVideoNoteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSendVideoNoteResponse(rsp)
}

// PostSendVoiceWithBodyWithResponse request with arbitrary body returning *PostSendVoiceResponse
func (c *ClientWithResponses) PostSendVoiceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSendVoiceResponse, error) {
	rsp, err := c.PostSendVoiceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSendVoiceResponse(rsp)
}

// PostSetChatAdministratorCustomTitleWithBodyWithResponse request with arbitrary body returning *PostSetChatAdministratorCustomTitleResponse
func (c *ClientWithResponses) PostSetChatAdministratorCustomTitleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSetChatAdministratorCustomTitleResponse, error) {
	rsp, err := c.PostSetChatAdministratorCustomTitleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSetChatAdministratorCustomTitleResponse(rsp)
}

func (c *ClientWithResponses) PostSetChatAdministratorCustomTitleWithResponse(ctx context.Context, body PostSetChatAdministratorCustomTitleJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSetChatAdministratorCustomTitleResponse, error) {
	rsp, err := c.PostSetChatAdministratorCustomTitle(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSetChatAdministratorCustomTitleResponse(rsp)
}

// PostSetChatDescriptionWithBodyWithResponse request with arbitrary body returning *PostSetChatDescriptionResponse
func (c *ClientWithResponses) PostSetChatDescriptionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSetChatDescriptionResponse, error) {
	rsp, err := c.PostSetChatDescriptionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSetChatDescriptionResponse(rsp)
}

func (c *ClientWithResponses) PostSetChatDescriptionWithResponse(ctx context.Context, body PostSetChatDescriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSetChatDescriptionResponse, error) {
	rsp, err := c.PostSetChatDescription(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSetChatDescriptionResponse(rsp)
}

// PostSetChatMenuButtonWithBodyWithResponse request with arbitrary body returning *PostSetChatMenuButtonResponse
func (c *ClientWithResponses) PostSetChatMenuButtonWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSetChatMenuButtonResponse, error) {
	rsp, err := c.PostSetChatMenuButtonWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSetChatMenuButtonResponse(rsp)
}

func (c *ClientWithResponses) PostSetChatMenuButtonWithResponse(ctx context.Context, body PostSetChatMenuButtonJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSetChatMenuButtonResponse, error) {
	rsp, err := c.PostSetChatMenuButton(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSetChatMenuButtonResponse(rsp)
}

// PostSetChatPermissionsWithBodyWithResponse request with arbitrary body returning *PostSetChatPermissionsResponse
func (c *ClientWithResponses) PostSetChatPermissionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSetChatPermissionsResponse, error) {
	rsp, err := c.PostSetChatPermissionsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSetChatPermissionsResponse(rsp)
}

func (c *ClientWithResponses) PostSetChatPermissionsWithResponse(ctx context.Context, body PostSetChatPermissionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSetChatPermissionsResponse, error) {
	rsp, err := c.PostSetChatPermissions(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSetChatPermissionsResponse(rsp)
}

// PostSetChatPhotoWithBodyWithResponse request with arbitrary body returning *PostSetChatPhotoResponse
func (c *ClientWithResponses) PostSetChatPhotoWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSetChatPhotoResponse, error) {
	rsp, err := c.PostSetChatPhotoWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSetChatPhotoResponse(rsp)
}

// PostSetChatStickerSetWithBodyWithResponse request with arbitrary body returning *PostSetChatStickerSetResponse
func (c *ClientWithResponses) PostSetChatStickerSetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSetChatStickerSetResponse, error) {
	rsp, err := c.PostSetChatStickerSetWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSetChatStickerSetResponse(rsp)
}

func (c *ClientWithResponses) PostSetChatStickerSetWithResponse(ctx context.Context, body PostSetChatStickerSetJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSetChatStickerSetResponse, error) {
	rsp, err := c.PostSetChatStickerSet(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSetChatStickerSetResponse(rsp)
}

// PostSetChatTitleWithBodyWithResponse request with arbitrary body returning *PostSetChatTitleResponse
func (c *ClientWithResponses) PostSetChatTitleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSetChatTitleResponse, error) {
	rsp, err := c.PostSetChatTitleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSetChatTitleResponse(rsp)
}

func (c *ClientWithResponses) PostSetChatTitleWithResponse(ctx context.Context, body PostSetChatTitleJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSetChatTitleResponse, error) {
	rsp, err := c.PostSetChatTitle(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSetChatTitleResponse(rsp)
}

// PostSetGameScoreWithBodyWithResponse request with arbitrary body returning *PostSetGameScoreResponse
func (c *ClientWithResponses) PostSetGameScoreWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSetGameScoreResponse, error) {
	rsp, err := c.PostSetGameScoreWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSetGameScoreResponse(rsp)
}

func (c *ClientWithResponses) PostSetGameScoreWithResponse(ctx context.Context, body PostSetGameScoreJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSetGameScoreResponse, error) {
	rsp, err := c.PostSetGameScore(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSetGameScoreResponse(rsp)
}

// PostSetMyCommandsWithBodyWithResponse request with arbitrary body returning *PostSetMyCommandsResponse
func (c *ClientWithResponses) PostSetMyCommandsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSetMyCommandsResponse, error) {
	rsp, err := c.PostSetMyCommandsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSetMyCommandsResponse(rsp)
}

func (c *ClientWithResponses) PostSetMyCommandsWithResponse(ctx context.Context, body PostSetMyCommandsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSetMyCommandsResponse, error) {
	rsp, err := c.PostSetMyCommands(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSetMyCommandsResponse(rsp)
}

// PostSetMyDefaultAdministratorRightsWithBodyWithResponse request with arbitrary body returning *PostSetMyDefaultAdministratorRightsResponse
func (c *ClientWithResponses) PostSetMyDefaultAdministratorRightsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSetMyDefaultAdministratorRightsResponse, error) {
	rsp, err := c.PostSetMyDefaultAdministratorRightsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSetMyDefaultAdministratorRightsResponse(rsp)
}

func (c *ClientWithResponses) PostSetMyDefaultAdministratorRightsWithResponse(ctx context.Context, body PostSetMyDefaultAdministratorRightsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSetMyDefaultAdministratorRightsResponse, error) {
	rsp, err := c.PostSetMyDefaultAdministratorRights(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSetMyDefaultAdministratorRightsResponse(rsp)
}

// PostSetPassportDataErrorsWithBodyWithResponse request with arbitrary body returning *PostSetPassportDataErrorsResponse
func (c *ClientWithResponses) PostSetPassportDataErrorsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSetPassportDataErrorsResponse, error) {
	rsp, err := c.PostSetPassportDataErrorsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSetPassportDataErrorsResponse(rsp)
}

func (c *ClientWithResponses) PostSetPassportDataErrorsWithResponse(ctx context.Context, body PostSetPassportDataErrorsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSetPassportDataErrorsResponse, error) {
	rsp, err := c.PostSetPassportDataErrors(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSetPassportDataErrorsResponse(rsp)
}

// PostSetStickerPositionInSetWithBodyWithResponse request with arbitrary body returning *PostSetStickerPositionInSetResponse
func (c *ClientWithResponses) PostSetStickerPositionInSetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSetStickerPositionInSetResponse, error) {
	rsp, err := c.PostSetStickerPositionInSetWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSetStickerPositionInSetResponse(rsp)
}

func (c *ClientWithResponses) PostSetStickerPositionInSetWithResponse(ctx context.Context, body PostSetStickerPositionInSetJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSetStickerPositionInSetResponse, error) {
	rsp, err := c.PostSetStickerPositionInSet(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSetStickerPositionInSetResponse(rsp)
}

// PostSetStickerSetThumbWithBodyWithResponse request with arbitrary body returning *PostSetStickerSetThumbResponse
func (c *ClientWithResponses) PostSetStickerSetThumbWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSetStickerSetThumbResponse, error) {
	rsp, err := c.PostSetStickerSetThumbWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSetStickerSetThumbResponse(rsp)
}

// PostSetWebhookWithBodyWithResponse request with arbitrary body returning *PostSetWebhookResponse
func (c *ClientWithResponses) PostSetWebhookWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSetWebhookResponse, error) {
	rsp, err := c.PostSetWebhookWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSetWebhookResponse(rsp)
}

// PostStopMessageLiveLocationWithBodyWithResponse request with arbitrary body returning *PostStopMessageLiveLocationResponse
func (c *ClientWithResponses) PostStopMessageLiveLocationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostStopMessageLiveLocationResponse, error) {
	rsp, err := c.PostStopMessageLiveLocationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostStopMessageLiveLocationResponse(rsp)
}

func (c *ClientWithResponses) PostStopMessageLiveLocationWithResponse(ctx context.Context, body PostStopMessageLiveLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*PostStopMessageLiveLocationResponse, error) {
	rsp, err := c.PostStopMessageLiveLocation(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostStopMessageLiveLocationResponse(rsp)
}

// PostStopPollWithBodyWithResponse request with arbitrary body returning *PostStopPollResponse
func (c *ClientWithResponses) PostStopPollWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostStopPollResponse, error) {
	rsp, err := c.PostStopPollWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostStopPollResponse(rsp)
}

func (c *ClientWithResponses) PostStopPollWithResponse(ctx context.Context, body PostStopPollJSONRequestBody, reqEditors ...RequestEditorFn) (*PostStopPollResponse, error) {
	rsp, err := c.PostStopPoll(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostStopPollResponse(rsp)
}

// PostUnbanChatMemberWithBodyWithResponse request with arbitrary body returning *PostUnbanChatMemberResponse
func (c *ClientWithResponses) PostUnbanChatMemberWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUnbanChatMemberResponse, error) {
	rsp, err := c.PostUnbanChatMemberWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUnbanChatMemberResponse(rsp)
}

func (c *ClientWithResponses) PostUnbanChatMemberWithResponse(ctx context.Context, body PostUnbanChatMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUnbanChatMemberResponse, error) {
	rsp, err := c.PostUnbanChatMember(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUnbanChatMemberResponse(rsp)
}

// PostUnbanChatSenderChatWithBodyWithResponse request with arbitrary body returning *PostUnbanChatSenderChatResponse
func (c *ClientWithResponses) PostUnbanChatSenderChatWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUnbanChatSenderChatResponse, error) {
	rsp, err := c.PostUnbanChatSenderChatWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUnbanChatSenderChatResponse(rsp)
}

func (c *ClientWithResponses) PostUnbanChatSenderChatWithResponse(ctx context.Context, body PostUnbanChatSenderChatJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUnbanChatSenderChatResponse, error) {
	rsp, err := c.PostUnbanChatSenderChat(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUnbanChatSenderChatResponse(rsp)
}

// PostUnpinAllChatMessagesWithBodyWithResponse request with arbitrary body returning *PostUnpinAllChatMessagesResponse
func (c *ClientWithResponses) PostUnpinAllChatMessagesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUnpinAllChatMessagesResponse, error) {
	rsp, err := c.PostUnpinAllChatMessagesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUnpinAllChatMessagesResponse(rsp)
}

func (c *ClientWithResponses) PostUnpinAllChatMessagesWithResponse(ctx context.Context, body PostUnpinAllChatMessagesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUnpinAllChatMessagesResponse, error) {
	rsp, err := c.PostUnpinAllChatMessages(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUnpinAllChatMessagesResponse(rsp)
}

// PostUnpinChatMessageWithBodyWithResponse request with arbitrary body returning *PostUnpinChatMessageResponse
func (c *ClientWithResponses) PostUnpinChatMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUnpinChatMessageResponse, error) {
	rsp, err := c.PostUnpinChatMessageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUnpinChatMessageResponse(rsp)
}

func (c *ClientWithResponses) PostUnpinChatMessageWithResponse(ctx context.Context, body PostUnpinChatMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUnpinChatMessageResponse, error) {
	rsp, err := c.PostUnpinChatMessage(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUnpinChatMessageResponse(rsp)
}

// PostUploadStickerFileWithBodyWithResponse request with arbitrary body returning *PostUploadStickerFileResponse
func (c *ClientWithResponses) PostUploadStickerFileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUploadStickerFileResponse, error) {
	rsp, err := c.PostUploadStickerFileWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUploadStickerFileResponse(rsp)
}

// ParsePostAddStickerToSetResponse parses an HTTP response from a PostAddStickerToSetWithResponse call
func ParsePostAddStickerToSetResponse(rsp *http.Response) (*PostAddStickerToSetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAddStickerToSetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool `json:"ok"`
			Result bool `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostAnswerCallbackQueryResponse parses an HTTP response from a PostAnswerCallbackQueryWithResponse call
func ParsePostAnswerCallbackQueryResponse(rsp *http.Response) (*PostAnswerCallbackQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAnswerCallbackQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool `json:"ok"`
			Result bool `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostAnswerInlineQueryResponse parses an HTTP response from a PostAnswerInlineQueryWithResponse call
func ParsePostAnswerInlineQueryResponse(rsp *http.Response) (*PostAnswerInlineQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAnswerInlineQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool `json:"ok"`
			Result bool `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostAnswerPreCheckoutQueryResponse parses an HTTP response from a PostAnswerPreCheckoutQueryWithResponse call
func ParsePostAnswerPreCheckoutQueryResponse(rsp *http.Response) (*PostAnswerPreCheckoutQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAnswerPreCheckoutQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool `json:"ok"`
			Result bool `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostAnswerShippingQueryResponse parses an HTTP response from a PostAnswerShippingQueryWithResponse call
func ParsePostAnswerShippingQueryResponse(rsp *http.Response) (*PostAnswerShippingQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAnswerShippingQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool `json:"ok"`
			Result bool `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostAnswerWebAppQueryResponse parses an HTTP response from a PostAnswerWebAppQueryWithResponse call
func ParsePostAnswerWebAppQueryResponse(rsp *http.Response) (*PostAnswerWebAppQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAnswerWebAppQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok bool `json:"ok"`

			// Describes an inline message sent by a [Web App](https://core.telegram.org/bots/webapps) on behalf of a user.
			Result SentWebAppMessage `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostApproveChatJoinRequestResponse parses an HTTP response from a PostApproveChatJoinRequestWithResponse call
func ParsePostApproveChatJoinRequestResponse(rsp *http.Response) (*PostApproveChatJoinRequestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApproveChatJoinRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool `json:"ok"`
			Result bool `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostBanChatMemberResponse parses an HTTP response from a PostBanChatMemberWithResponse call
func ParsePostBanChatMemberResponse(rsp *http.Response) (*PostBanChatMemberResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostBanChatMemberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool `json:"ok"`
			Result bool `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostBanChatSenderChatResponse parses an HTTP response from a PostBanChatSenderChatWithResponse call
func ParsePostBanChatSenderChatResponse(rsp *http.Response) (*PostBanChatSenderChatResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostBanChatSenderChatResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool `json:"ok"`
			Result bool `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostCloseResponse parses an HTTP response from a PostCloseWithResponse call
func ParsePostCloseResponse(rsp *http.Response) (*PostCloseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCloseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool `json:"ok"`
			Result bool `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostCopyMessageResponse parses an HTTP response from a PostCopyMessageWithResponse call
func ParsePostCopyMessageResponse(rsp *http.Response) (*PostCopyMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCopyMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok bool `json:"ok"`

			// This object represents a unique message identifier.
			Result MessageId `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostCreateChatInviteLinkResponse parses an HTTP response from a PostCreateChatInviteLinkWithResponse call
func ParsePostCreateChatInviteLinkResponse(rsp *http.Response) (*PostCreateChatInviteLinkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCreateChatInviteLinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok bool `json:"ok"`

			// Represents an invite link for a chat.
			Result ChatInviteLink `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostCreateInvoiceLinkResponse parses an HTTP response from a PostCreateInvoiceLinkWithResponse call
func ParsePostCreateInvoiceLinkResponse(rsp *http.Response) (*PostCreateInvoiceLinkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCreateInvoiceLinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool   `json:"ok"`
			Result string `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostCreateNewStickerSetResponse parses an HTTP response from a PostCreateNewStickerSetWithResponse call
func ParsePostCreateNewStickerSetResponse(rsp *http.Response) (*PostCreateNewStickerSetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCreateNewStickerSetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool `json:"ok"`
			Result bool `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostDeclineChatJoinRequestResponse parses an HTTP response from a PostDeclineChatJoinRequestWithResponse call
func ParsePostDeclineChatJoinRequestResponse(rsp *http.Response) (*PostDeclineChatJoinRequestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostDeclineChatJoinRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool `json:"ok"`
			Result bool `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostDeleteChatPhotoResponse parses an HTTP response from a PostDeleteChatPhotoWithResponse call
func ParsePostDeleteChatPhotoResponse(rsp *http.Response) (*PostDeleteChatPhotoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostDeleteChatPhotoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool `json:"ok"`
			Result bool `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostDeleteChatStickerSetResponse parses an HTTP response from a PostDeleteChatStickerSetWithResponse call
func ParsePostDeleteChatStickerSetResponse(rsp *http.Response) (*PostDeleteChatStickerSetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostDeleteChatStickerSetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool `json:"ok"`
			Result bool `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostDeleteMessageResponse parses an HTTP response from a PostDeleteMessageWithResponse call
func ParsePostDeleteMessageResponse(rsp *http.Response) (*PostDeleteMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostDeleteMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool `json:"ok"`
			Result bool `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostDeleteMyCommandsResponse parses an HTTP response from a PostDeleteMyCommandsWithResponse call
func ParsePostDeleteMyCommandsResponse(rsp *http.Response) (*PostDeleteMyCommandsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostDeleteMyCommandsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool `json:"ok"`
			Result bool `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostDeleteStickerFromSetResponse parses an HTTP response from a PostDeleteStickerFromSetWithResponse call
func ParsePostDeleteStickerFromSetResponse(rsp *http.Response) (*PostDeleteStickerFromSetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostDeleteStickerFromSetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool `json:"ok"`
			Result bool `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostDeleteWebhookResponse parses an HTTP response from a PostDeleteWebhookWithResponse call
func ParsePostDeleteWebhookResponse(rsp *http.Response) (*PostDeleteWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostDeleteWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool `json:"ok"`
			Result bool `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostEditChatInviteLinkResponse parses an HTTP response from a PostEditChatInviteLinkWithResponse call
func ParsePostEditChatInviteLinkResponse(rsp *http.Response) (*PostEditChatInviteLinkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostEditChatInviteLinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok bool `json:"ok"`

			// Represents an invite link for a chat.
			Result ChatInviteLink `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostEditMessageCaptionResponse parses an HTTP response from a PostEditMessageCaptionWithResponse call
func ParsePostEditMessageCaptionResponse(rsp *http.Response) (*PostEditMessageCaptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostEditMessageCaptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool        `json:"ok"`
			Result interface{} `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostEditMessageLiveLocationResponse parses an HTTP response from a PostEditMessageLiveLocationWithResponse call
func ParsePostEditMessageLiveLocationResponse(rsp *http.Response) (*PostEditMessageLiveLocationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostEditMessageLiveLocationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool        `json:"ok"`
			Result interface{} `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostEditMessageMediaResponse parses an HTTP response from a PostEditMessageMediaWithResponse call
func ParsePostEditMessageMediaResponse(rsp *http.Response) (*PostEditMessageMediaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostEditMessageMediaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool        `json:"ok"`
			Result interface{} `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostEditMessageReplyMarkupResponse parses an HTTP response from a PostEditMessageReplyMarkupWithResponse call
func ParsePostEditMessageReplyMarkupResponse(rsp *http.Response) (*PostEditMessageReplyMarkupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostEditMessageReplyMarkupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool        `json:"ok"`
			Result interface{} `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostEditMessageTextResponse parses an HTTP response from a PostEditMessageTextWithResponse call
func ParsePostEditMessageTextResponse(rsp *http.Response) (*PostEditMessageTextResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostEditMessageTextResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool        `json:"ok"`
			Result interface{} `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostExportChatInviteLinkResponse parses an HTTP response from a PostExportChatInviteLinkWithResponse call
func ParsePostExportChatInviteLinkResponse(rsp *http.Response) (*PostExportChatInviteLinkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostExportChatInviteLinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool   `json:"ok"`
			Result string `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostForwardMessageResponse parses an HTTP response from a PostForwardMessageWithResponse call
func ParsePostForwardMessageResponse(rsp *http.Response) (*PostForwardMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostForwardMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok bool `json:"ok"`

			// This object represents a message.
			Result Message `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostGetChatResponse parses an HTTP response from a PostGetChatWithResponse call
func ParsePostGetChatResponse(rsp *http.Response) (*PostGetChatResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostGetChatResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok bool `json:"ok"`

			// This object represents a chat.
			Result Chat `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostGetChatAdministratorsResponse parses an HTTP response from a PostGetChatAdministratorsWithResponse call
func ParsePostGetChatAdministratorsResponse(rsp *http.Response) (*PostGetChatAdministratorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostGetChatAdministratorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool         `json:"ok"`
			Result []ChatMember `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostGetChatMemberResponse parses an HTTP response from a PostGetChatMemberWithResponse call
func ParsePostGetChatMemberResponse(rsp *http.Response) (*PostGetChatMemberResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostGetChatMemberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok bool `json:"ok"`

			// This object contains information about one member of a chat. Currently, the following 6 types of chat members are supported:
			//
			// * [ChatMemberOwner](https://core.telegram.org/bots/api/#chatmemberowner)
			// * [ChatMemberAdministrator](https://core.telegram.org/bots/api/#chatmemberadministrator)
			// * [ChatMemberMember](https://core.telegram.org/bots/api/#chatmembermember)
			// * [ChatMemberRestricted](https://core.telegram.org/bots/api/#chatmemberrestricted)
			// * [ChatMemberLeft](https://core.telegram.org/bots/api/#chatmemberleft)
			// * [ChatMemberBanned](https://core.telegram.org/bots/api/#chatmemberbanned)
			Result ChatMember `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostGetChatMemberCountResponse parses an HTTP response from a PostGetChatMemberCountWithResponse call
func ParsePostGetChatMemberCountResponse(rsp *http.Response) (*PostGetChatMemberCountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostGetChatMemberCountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool `json:"ok"`
			Result int  `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostGetChatMenuButtonResponse parses an HTTP response from a PostGetChatMenuButtonWithResponse call
func ParsePostGetChatMenuButtonResponse(rsp *http.Response) (*PostGetChatMenuButtonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostGetChatMenuButtonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok bool `json:"ok"`

			// This object describes the bot's menu button in a private chat. It should be one of
			//
			// * [MenuButtonCommands](https://core.telegram.org/bots/api/#menubuttoncommands)
			// * [MenuButtonWebApp](https://core.telegram.org/bots/api/#menubuttonwebapp)
			// * [MenuButtonDefault](https://core.telegram.org/bots/api/#menubuttondefault)
			Result MenuButton `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostGetFileResponse parses an HTTP response from a PostGetFileWithResponse call
func ParsePostGetFileResponse(rsp *http.Response) (*PostGetFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostGetFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok bool `json:"ok"`

			// This object represents a file ready to be downloaded. The file can be downloaded via the link `https://api.telegram.org/file/bot<token>/<file_path>`. It is guaranteed that the link will be valid for at least 1 hour. When the link expires, a new one can be requested by calling [getFile](https://core.telegram.org/bots/api/#getfile).
			//
			// The maximum file size to download is 20 MB
			Result File `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostGetGameHighScoresResponse parses an HTTP response from a PostGetGameHighScoresWithResponse call
func ParsePostGetGameHighScoresResponse(rsp *http.Response) (*PostGetGameHighScoresResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostGetGameHighScoresResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool            `json:"ok"`
			Result []GameHighScore `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostGetMeResponse parses an HTTP response from a PostGetMeWithResponse call
func ParsePostGetMeResponse(rsp *http.Response) (*PostGetMeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostGetMeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok bool `json:"ok"`

			// This object represents a Telegram user or bot.
			Result User `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostGetMyCommandsResponse parses an HTTP response from a PostGetMyCommandsWithResponse call
func ParsePostGetMyCommandsResponse(rsp *http.Response) (*PostGetMyCommandsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostGetMyCommandsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool         `json:"ok"`
			Result []BotCommand `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostGetMyDefaultAdministratorRightsResponse parses an HTTP response from a PostGetMyDefaultAdministratorRightsWithResponse call
func ParsePostGetMyDefaultAdministratorRightsResponse(rsp *http.Response) (*PostGetMyDefaultAdministratorRightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostGetMyDefaultAdministratorRightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok bool `json:"ok"`

			// Represents the rights of an administrator in a chat.
			Result ChatAdministratorRights `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostGetStickerSetResponse parses an HTTP response from a PostGetStickerSetWithResponse call
func ParsePostGetStickerSetResponse(rsp *http.Response) (*PostGetStickerSetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostGetStickerSetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok bool `json:"ok"`

			// This object represents a sticker set.
			Result StickerSet `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostGetUpdatesResponse parses an HTTP response from a PostGetUpdatesWithResponse call
func ParsePostGetUpdatesResponse(rsp *http.Response) (*PostGetUpdatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostGetUpdatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool     `json:"ok"`
			Result []Update `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostGetUserProfilePhotosResponse parses an HTTP response from a PostGetUserProfilePhotosWithResponse call
func ParsePostGetUserProfilePhotosResponse(rsp *http.Response) (*PostGetUserProfilePhotosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostGetUserProfilePhotosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok bool `json:"ok"`

			// This object represent a user's profile pictures.
			Result UserProfilePhotos `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostGetWebhookInfoResponse parses an HTTP response from a PostGetWebhookInfoWithResponse call
func ParsePostGetWebhookInfoResponse(rsp *http.Response) (*PostGetWebhookInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostGetWebhookInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok bool `json:"ok"`

			// Describes the current status of a webhook.
			Result WebhookInfo `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostLeaveChatResponse parses an HTTP response from a PostLeaveChatWithResponse call
func ParsePostLeaveChatResponse(rsp *http.Response) (*PostLeaveChatResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostLeaveChatResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool `json:"ok"`
			Result bool `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostLogOutResponse parses an HTTP response from a PostLogOutWithResponse call
func ParsePostLogOutResponse(rsp *http.Response) (*PostLogOutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostLogOutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool `json:"ok"`
			Result bool `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostPinChatMessageResponse parses an HTTP response from a PostPinChatMessageWithResponse call
func ParsePostPinChatMessageResponse(rsp *http.Response) (*PostPinChatMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostPinChatMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool `json:"ok"`
			Result bool `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostPromoteChatMemberResponse parses an HTTP response from a PostPromoteChatMemberWithResponse call
func ParsePostPromoteChatMemberResponse(rsp *http.Response) (*PostPromoteChatMemberResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostPromoteChatMemberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool `json:"ok"`
			Result bool `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostRestrictChatMemberResponse parses an HTTP response from a PostRestrictChatMemberWithResponse call
func ParsePostRestrictChatMemberResponse(rsp *http.Response) (*PostRestrictChatMemberResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostRestrictChatMemberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool `json:"ok"`
			Result bool `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostRevokeChatInviteLinkResponse parses an HTTP response from a PostRevokeChatInviteLinkWithResponse call
func ParsePostRevokeChatInviteLinkResponse(rsp *http.Response) (*PostRevokeChatInviteLinkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostRevokeChatInviteLinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok bool `json:"ok"`

			// Represents an invite link for a chat.
			Result ChatInviteLink `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostSendAnimationResponse parses an HTTP response from a PostSendAnimationWithResponse call
func ParsePostSendAnimationResponse(rsp *http.Response) (*PostSendAnimationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSendAnimationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok bool `json:"ok"`

			// This object represents a message.
			Result Message `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostSendAudioResponse parses an HTTP response from a PostSendAudioWithResponse call
func ParsePostSendAudioResponse(rsp *http.Response) (*PostSendAudioResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSendAudioResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok bool `json:"ok"`

			// This object represents a message.
			Result Message `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostSendChatActionResponse parses an HTTP response from a PostSendChatActionWithResponse call
func ParsePostSendChatActionResponse(rsp *http.Response) (*PostSendChatActionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSendChatActionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool `json:"ok"`
			Result bool `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostSendContactResponse parses an HTTP response from a PostSendContactWithResponse call
func ParsePostSendContactResponse(rsp *http.Response) (*PostSendContactResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSendContactResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok bool `json:"ok"`

			// This object represents a message.
			Result Message `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostSendDiceResponse parses an HTTP response from a PostSendDiceWithResponse call
func ParsePostSendDiceResponse(rsp *http.Response) (*PostSendDiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSendDiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok bool `json:"ok"`

			// This object represents a message.
			Result Message `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostSendDocumentResponse parses an HTTP response from a PostSendDocumentWithResponse call
func ParsePostSendDocumentResponse(rsp *http.Response) (*PostSendDocumentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSendDocumentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok bool `json:"ok"`

			// This object represents a message.
			Result Message `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostSendGameResponse parses an HTTP response from a PostSendGameWithResponse call
func ParsePostSendGameResponse(rsp *http.Response) (*PostSendGameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSendGameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok bool `json:"ok"`

			// This object represents a message.
			Result Message `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostSendInvoiceResponse parses an HTTP response from a PostSendInvoiceWithResponse call
func ParsePostSendInvoiceResponse(rsp *http.Response) (*PostSendInvoiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSendInvoiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok bool `json:"ok"`

			// This object represents a message.
			Result Message `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostSendLocationResponse parses an HTTP response from a PostSendLocationWithResponse call
func ParsePostSendLocationResponse(rsp *http.Response) (*PostSendLocationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSendLocationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok bool `json:"ok"`

			// This object represents a message.
			Result Message `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostSendMediaGroupResponse parses an HTTP response from a PostSendMediaGroupWithResponse call
func ParsePostSendMediaGroupResponse(rsp *http.Response) (*PostSendMediaGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSendMediaGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool      `json:"ok"`
			Result []Message `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostSendMessageResponse parses an HTTP response from a PostSendMessageWithResponse call
func ParsePostSendMessageResponse(rsp *http.Response) (*PostSendMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSendMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok bool `json:"ok"`

			// This object represents a message.
			Result Message `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostSendPhotoResponse parses an HTTP response from a PostSendPhotoWithResponse call
func ParsePostSendPhotoResponse(rsp *http.Response) (*PostSendPhotoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSendPhotoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok bool `json:"ok"`

			// This object represents a message.
			Result Message `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostSendPollResponse parses an HTTP response from a PostSendPollWithResponse call
func ParsePostSendPollResponse(rsp *http.Response) (*PostSendPollResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSendPollResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok bool `json:"ok"`

			// This object represents a message.
			Result Message `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostSendStickerResponse parses an HTTP response from a PostSendStickerWithResponse call
func ParsePostSendStickerResponse(rsp *http.Response) (*PostSendStickerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSendStickerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok bool `json:"ok"`

			// This object represents a message.
			Result Message `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostSendVenueResponse parses an HTTP response from a PostSendVenueWithResponse call
func ParsePostSendVenueResponse(rsp *http.Response) (*PostSendVenueResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSendVenueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok bool `json:"ok"`

			// This object represents a message.
			Result Message `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostSendVideoResponse parses an HTTP response from a PostSendVideoWithResponse call
func ParsePostSendVideoResponse(rsp *http.Response) (*PostSendVideoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSendVideoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok bool `json:"ok"`

			// This object represents a message.
			Result Message `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostSendVideoNoteResponse parses an HTTP response from a PostSendVideoNoteWithResponse call
func ParsePostSendVideoNoteResponse(rsp *http.Response) (*PostSendVideoNoteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSendVideoNoteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok bool `json:"ok"`

			// This object represents a message.
			Result Message `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostSendVoiceResponse parses an HTTP response from a PostSendVoiceWithResponse call
func ParsePostSendVoiceResponse(rsp *http.Response) (*PostSendVoiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSendVoiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok bool `json:"ok"`

			// This object represents a message.
			Result Message `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostSetChatAdministratorCustomTitleResponse parses an HTTP response from a PostSetChatAdministratorCustomTitleWithResponse call
func ParsePostSetChatAdministratorCustomTitleResponse(rsp *http.Response) (*PostSetChatAdministratorCustomTitleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSetChatAdministratorCustomTitleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool `json:"ok"`
			Result bool `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostSetChatDescriptionResponse parses an HTTP response from a PostSetChatDescriptionWithResponse call
func ParsePostSetChatDescriptionResponse(rsp *http.Response) (*PostSetChatDescriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSetChatDescriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool `json:"ok"`
			Result bool `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostSetChatMenuButtonResponse parses an HTTP response from a PostSetChatMenuButtonWithResponse call
func ParsePostSetChatMenuButtonResponse(rsp *http.Response) (*PostSetChatMenuButtonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSetChatMenuButtonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool `json:"ok"`
			Result bool `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostSetChatPermissionsResponse parses an HTTP response from a PostSetChatPermissionsWithResponse call
func ParsePostSetChatPermissionsResponse(rsp *http.Response) (*PostSetChatPermissionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSetChatPermissionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool `json:"ok"`
			Result bool `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostSetChatPhotoResponse parses an HTTP response from a PostSetChatPhotoWithResponse call
func ParsePostSetChatPhotoResponse(rsp *http.Response) (*PostSetChatPhotoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSetChatPhotoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool `json:"ok"`
			Result bool `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostSetChatStickerSetResponse parses an HTTP response from a PostSetChatStickerSetWithResponse call
func ParsePostSetChatStickerSetResponse(rsp *http.Response) (*PostSetChatStickerSetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSetChatStickerSetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool `json:"ok"`
			Result bool `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostSetChatTitleResponse parses an HTTP response from a PostSetChatTitleWithResponse call
func ParsePostSetChatTitleResponse(rsp *http.Response) (*PostSetChatTitleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSetChatTitleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool `json:"ok"`
			Result bool `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostSetGameScoreResponse parses an HTTP response from a PostSetGameScoreWithResponse call
func ParsePostSetGameScoreResponse(rsp *http.Response) (*PostSetGameScoreResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSetGameScoreResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool        `json:"ok"`
			Result interface{} `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostSetMyCommandsResponse parses an HTTP response from a PostSetMyCommandsWithResponse call
func ParsePostSetMyCommandsResponse(rsp *http.Response) (*PostSetMyCommandsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSetMyCommandsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool `json:"ok"`
			Result bool `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostSetMyDefaultAdministratorRightsResponse parses an HTTP response from a PostSetMyDefaultAdministratorRightsWithResponse call
func ParsePostSetMyDefaultAdministratorRightsResponse(rsp *http.Response) (*PostSetMyDefaultAdministratorRightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSetMyDefaultAdministratorRightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool `json:"ok"`
			Result bool `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostSetPassportDataErrorsResponse parses an HTTP response from a PostSetPassportDataErrorsWithResponse call
func ParsePostSetPassportDataErrorsResponse(rsp *http.Response) (*PostSetPassportDataErrorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSetPassportDataErrorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool `json:"ok"`
			Result bool `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostSetStickerPositionInSetResponse parses an HTTP response from a PostSetStickerPositionInSetWithResponse call
func ParsePostSetStickerPositionInSetResponse(rsp *http.Response) (*PostSetStickerPositionInSetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSetStickerPositionInSetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool `json:"ok"`
			Result bool `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostSetStickerSetThumbResponse parses an HTTP response from a PostSetStickerSetThumbWithResponse call
func ParsePostSetStickerSetThumbResponse(rsp *http.Response) (*PostSetStickerSetThumbResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSetStickerSetThumbResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool `json:"ok"`
			Result bool `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostSetWebhookResponse parses an HTTP response from a PostSetWebhookWithResponse call
func ParsePostSetWebhookResponse(rsp *http.Response) (*PostSetWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSetWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool `json:"ok"`
			Result bool `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostStopMessageLiveLocationResponse parses an HTTP response from a PostStopMessageLiveLocationWithResponse call
func ParsePostStopMessageLiveLocationResponse(rsp *http.Response) (*PostStopMessageLiveLocationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostStopMessageLiveLocationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool        `json:"ok"`
			Result interface{} `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostStopPollResponse parses an HTTP response from a PostStopPollWithResponse call
func ParsePostStopPollResponse(rsp *http.Response) (*PostStopPollResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostStopPollResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok bool `json:"ok"`

			// This object contains information about a poll.
			Result Poll `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostUnbanChatMemberResponse parses an HTTP response from a PostUnbanChatMemberWithResponse call
func ParsePostUnbanChatMemberResponse(rsp *http.Response) (*PostUnbanChatMemberResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostUnbanChatMemberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool `json:"ok"`
			Result bool `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostUnbanChatSenderChatResponse parses an HTTP response from a PostUnbanChatSenderChatWithResponse call
func ParsePostUnbanChatSenderChatResponse(rsp *http.Response) (*PostUnbanChatSenderChatResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostUnbanChatSenderChatResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool `json:"ok"`
			Result bool `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostUnpinAllChatMessagesResponse parses an HTTP response from a PostUnpinAllChatMessagesWithResponse call
func ParsePostUnpinAllChatMessagesResponse(rsp *http.Response) (*PostUnpinAllChatMessagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostUnpinAllChatMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool `json:"ok"`
			Result bool `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostUnpinChatMessageResponse parses an HTTP response from a PostUnpinChatMessageWithResponse call
func ParsePostUnpinChatMessageResponse(rsp *http.Response) (*PostUnpinChatMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostUnpinChatMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok     bool `json:"ok"`
			Result bool `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostUploadStickerFileResponse parses an HTTP response from a PostUploadStickerFileWithResponse call
func ParsePostUploadStickerFileResponse(rsp *http.Response) (*PostUploadStickerFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostUploadStickerFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ok bool `json:"ok"`

			// This object represents a file ready to be downloaded. The file can be downloaded via the link `https://api.telegram.org/file/bot<token>/<file_path>`. It is guaranteed that the link will be valid for at least 1 hour. When the link expires, a new one can be requested by calling [getFile](https://core.telegram.org/bots/api/#getfile).
			//
			// The maximum file size to download is 20 MB
			Result File `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}
